/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	 TODO:

	 1) clone this repo
	 2) replace the require-pipelines below; commit your changes
	 3) npm run buildDeploy

	 That's it! If your heroku is set to auto-deploy on push, you are done!
	 */
	__webpack_require__(2);

	__webpack_require__(146);


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(3).addModules({
	  Auth: __webpack_require__(22),
	  FilterLocation: __webpack_require__(144),
	  MyRemote: __webpack_require__(145)
	});


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var ClientServer, Pipelines,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ClientServer = __webpack_require__(4);

	module.exports = ClientServer.Pipelines || ClientServer.addNamespace('Pipelines', Pipelines = (function(superClass) {
	  extend(Pipelines, superClass);

	  function Pipelines() {
	    return Pipelines.__super__.constructor.apply(this, arguments);
	  }

	  return Pipelines;

	})(Neptune.Base));


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var ClientServer, Ery,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Ery = __webpack_require__(5);

	module.exports = Ery.ClientServer || Ery.addNamespace('ClientServer', ClientServer = (function(superClass) {
	  extend(ClientServer, superClass);

	  function ClientServer() {
	    return ClientServer.__super__.constructor.apply(this, arguments);
	  }

	  return ClientServer;

	})(Neptune.Base));


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Ery,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Art = __webpack_require__(6);

	module.exports = Art.Ery || Art.addNamespace('Ery', Ery = (function(superClass) {
	  extend(Ery, superClass);

	  function Ery() {
	    return Ery.__super__.constructor.apply(this, arguments);
	  }

	  return Ery;

	})(Neptune.Base));


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Tests,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Tests = __webpack_require__(7);

	module.exports = Tests.Art || Tests.addNamespace('Art', Art = (function(superClass) {
	  extend(Art, superClass);

	  function Art() {
	    return Art.__super__.constructor.apply(this, arguments);
	  }

	  return Art;

	})(Neptune.Base));


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var Neptune, Tests,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Neptune = __webpack_require__(8);

	module.exports = Neptune.Tests || Neptune.addNamespace('Tests', Tests = (function(superClass) {
	  extend(Tests, superClass);

	  function Tests() {
	    return Tests.__super__.constructor.apply(this, arguments);
	  }

	  return Tests;

	})(Neptune.Base));


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(9);


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	TODO: Make NN ugifly-mangler friendly. In order to do that, we need
	to stop using the function.name attribute.

	I think we can do that with one change: addNamespace needs to
	change to take a name argument: @addNamespace: (name, namespace) ->
	 */
	var Base, Neptune, NeptuneLib, isFunction, isPlainArray,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	__webpack_require__(10);

	__webpack_require__(11);

	isFunction = function(f) {
	  return typeof f === "function";
	};

	isPlainArray = function(o) {
	  return o.constructor === Array;
	};

	NeptuneLib = null;

	Base = (function() {
	  var excludedPropNames;

	  function Base() {}

	  Base.allNamespaces = {};

	  Base.getAllNamespacePaths = function() {
	    return Object.keys(Base.allNamespaces).sort();
	  };

	  Base.toString = function() {
	    return this.namespacePath;
	  };

	  Base.inspect = function() {
	    return this.namespacePath;
	  };

	  Base._name = "Base";

	  Base.namespacePath = "Neptune.Base";

	  Base.namespace = null;

	  Base.namespaces = {};

	  Base.modules = {};

	  Base.getNamespacePath = function() {
	    return this.namespacePath;
	  };

	  Base.getNamespaceNames = function() {
	    return Object.keys(this.namespaces).sort();
	  };

	  Base.getModuleNames = function() {
	    return Object.keys(this.modules).sort();
	  };

	  Base.getNeptuneLib = function() {
	    return NeptuneLib || (NeptuneLib = __webpack_require__(12));
	  };

	  Base.getInspectedObjects = function(includeModules) {
	    var name, namespace, obj;
	    if (includeModules == null) {
	      includeModules = true;
	    }
	    return (
	      obj = {},
	      obj["" + this.namespacePath] = this.getNeptuneLib().merge(this.version ? {
	        version: this.version
	      } : void 0, (function() {
	        var ref, results;
	        ref = this.namespaces;
	        results = [];
	        for (name in ref) {
	          namespace = ref[name];
	          results.push(namespace.getInspectedObjects(includeModules));
	        }
	        return results;
	      }).call(this), includeModules && this.getModuleNames().length > 0 ? {
	        modules: this.getModuleNames().join(', ')
	      } : void 0),
	      obj
	    );
	  };

	  Base.addNamespace = function(name, namespace) {
	    return this.allNamespaces[namespace.namespacePath] = this.namespaces[name] = this[name] = namespace._init(name, this);
	  };

	  Base.addModules = function(map) {
	    var module, name;
	    for (name in map) {
	      module = map[name];
	      this._setChildNamespaceProps(name, module);
	      if (!name.match(/^-/)) {
	        this.modules[name] = this[name] = module;
	      }
	    }
	    return this;
	  };


	  /*
	  IN: any combination of objects or arrays
	    object: all properties in the object are added to the namespace
	  
	    array: [fromObject, property names as one or more strings]
	      for propName in every sub-string in args matching: /[0-9a-z_]+/ig
	        @_addToNamespace propName, fromObject
	  
	      Each string is parsed to find everything that matches: /[0-9a-z_]+/ig
	      All resulting property names are concated into a one list.
	      Every property in fromObject that matches one of the property-names is added to the namespace.
	   */

	  Base.includeInNamespace = function() {
	    var arg, args, fromObject, i, j, k, l, len, len1, propName, ref, ref1, v;
	    args = arguments.length === 1 && isPlainArray(arguments[0]) ? arguments[0] : arguments;
	    for (j = 0, len = args.length; j < len; j++) {
	      arg = args[j];
	      if (arg) {
	        if (isPlainArray(arg)) {
	          fromObject = arg[0];
	          for (i = k = 1, ref = arg.length; 1 <= ref ? k < ref : k > ref; i = 1 <= ref ? ++k : --k) {
	            ref1 = arg[i].match(/[0-9a-z_]+/ig);
	            for (l = 0, len1 = ref1.length; l < len1; l++) {
	              propName = ref1[l];
	              this._addToNamespace(propName, fromObject);
	            }
	          }
	        } else {
	          for (propName in arg) {
	            v = arg[propName];
	            this._addToNamespace(propName, arg);
	          }
	        }
	      }
	    }
	    return this;
	  };


	  /*
	  Every child of a namespace gets these properties:
	  
	    namespace:      pointer to the parent namespace
	    namespacePath:  string path from global to child
	  
	  NOTE: only modules which return a class or function
	    get their namespace-props set.
	   */

	  Base._setChildNamespaceProps = function(name, child) {
	    if (isFunction(child)) {
	      if (isFunction(child["class"])) {
	        this._setChildNamespaceProps(name, child["class"]);
	      }
	      child.namespace = this;
	      return child.namespacePath = this.namespacePath + "." + name;
	    }
	  };


	  /*
	  CoffeeScript classes copy all class props when inheriting,
	  but some props need to be unique to each instance. This
	  function initializes those props.
	   */

	  Base._init = function(name, namespace1) {
	    this.namespace = namespace1;
	    this._name = name;
	    this.modules = {};
	    this.namespaces = {};
	    this.namespace._setChildNamespaceProps(name, this);
	    return this;
	  };

	  excludedPropNames = ["__super__"].concat(Object.keys(Base));


	  /*
	  Helper for includeInNamespace.
	  Add anything to the namespace.
	  
	  IN:
	    propName:   property name to  value will be assigned to in the namespace (string)
	    addingFrom: object
	      used for reporting errors if attempting to overwrite an
	      existing item.
	  
	  EFFECT:
	    Only adds value if @[propName] is not already set.
	    Otherwise, reports error and continues.
	  
	  OUT: value
	   */

	  Base._addToNamespace = function(propName, addingFrom) {
	    var addingFromString, value;
	    if (propName === "inspect" && (value = addingFrom[propName]).length > 0) {
	      return this[propName] = value;
	    }
	    if (indexOf.call(excludedPropNames, propName) >= 0) {
	      return;
	    }
	    if (!(value = addingFrom[propName])) {
	      return;
	    }
	    if (this[propName]) {
	      if (this[propName] !== value) {
	        addingFromString = addingFrom.namespacePath || addingFrom.propName || (Object.keys(addingFrom)).join(', ');
	        console.error(this.namespacePath + " already has key: " + propName + ". Adding from: " + addingFromString);
	      }
	      return this[propName];
	    } else {
	      return this[propName] = value;
	    }
	  };

	  return Base;

	})();

	module.exports = global.Neptune = Neptune = (function(superClass) {
	  var _package;

	  extend(Neptune, superClass);

	  function Neptune() {
	    return Neptune.__super__.constructor.apply(this, arguments);
	  }

	  Neptune.Base = Base;

	  Neptune.namespacePath = "Neptune";

	  Neptune.namespace = null;

	  Neptune.isNamespace = function(klass) {
	    return (klass != null ? klass.prototype : void 0) instanceof Base;
	  };

	  Neptune.isNode = __webpack_require__(20);

	  Neptune["package"] = _package = __webpack_require__(21);

	  Neptune.version = _package.version;

	  return Neptune;

	})(Base);

	Base.namespace = Neptune;


/***/ },
/* 10 */
/***/ function(module, exports) {

	if (typeof global !== "undefined" && global !== null) {
	  global.self = global;
	} else if (typeof self !== "undefined" && self !== null) {
	  self.global = self;
	}


/***/ },
/* 11 */
/***/ function(module, exports) {

	if ((function() {}).name == null) {
	  Object.defineProperty(global.Function.prototype, 'name', {
	    get: function() {
	      var matches, name;
	      name = (matches = this.toString().match(/^\s*function\s*([^\s(]+)/)) ? matches[1] : "";
	      Object.defineProperty(this, 'name', {
	        value: name
	      });
	      return name;
	    }
	  });
	}

	global.Function.prototype.getName = function() {
	  return this._name || this.name || "anonymousFunction";
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(13);


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(14).includeInNamespace(__webpack_require__(15)).addModules({
	  ArrayCompactFlatten: __webpack_require__(16),
	  Merge: __webpack_require__(18),
	  StringCase: __webpack_require__(17),
	  Types: __webpack_require__(19)
	});


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var Neptune, NeptuneLib,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Neptune = __webpack_require__(8);

	module.exports = Neptune.NeptuneLib || Neptune.addNamespace('NeptuneLib', NeptuneLib = (function(superClass) {
	  extend(NeptuneLib, superClass);

	  function NeptuneLib() {
	    return NeptuneLib.__super__.constructor.apply(this, arguments);
	  }

	  return NeptuneLib;

	})(Neptune.Base));


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [__webpack_require__(16), __webpack_require__(17), __webpack_require__(18)];


/***/ },
/* 16 */
/***/ function(module, exports) {

	var ArrayCompactFlatten;

	module.exports = ArrayCompactFlatten = (function() {
	  var arraySlice, compact, compactFlattenIfNeeded, deepArrayEach, doFlattenInternal, flatten, isArguments, isArrayOrArguments, keepAll, keepUnlessNullOrUndefined, needsFlatteningOrCompacting;

	  function ArrayCompactFlatten() {}

	  ArrayCompactFlatten.isArguments = isArguments = function(o) {
	    return o.constructor === Object && (typeof o.callee === "function") && (typeof o.length === "number");
	  };

	  ArrayCompactFlatten.isArrayOrArguments = isArrayOrArguments = function(o) {
	    return o && (o.constructor === Array || isArguments(o));
	  };

	  ArrayCompactFlatten.needsFlatteningOrCompacting = needsFlatteningOrCompacting = function(array, keepTester) {
	    var a, i, len;
	    for (i = 0, len = array.length; i < len; i++) {
	      a = array[i];
	      if (isArrayOrArguments(a) || !keepTester(a)) {
	        return true;
	      }
	    }
	    return false;
	  };

	  ArrayCompactFlatten.keepUnlessNullOrUndefined = keepUnlessNullOrUndefined = function(a) {
	    return a !== null && a !== void 0;
	  };


	  /*
	  IN:
	    array: array or arguments-object
	    keepTester: (value) -> true/false
	      OUT: return true if that element should be in the output
	  
	  OUT: array where all elements test true to keepTester
	  NOTE: NOT recursive - just does a shallow pass
	   */

	  ArrayCompactFlatten.compact = compact = function(array, keepTester) {
	    var a, i, len;
	    if (keepTester == null) {
	      keepTester = keepUnlessNullOrUndefined;
	    }
	    for (i = 0, len = array.length; i < len; i++) {
	      a = array[i];
	      if (!keepTester(a)) {
	        return (function() {
	          var j, len1, results;
	          results = [];
	          for (j = 0, len1 = array.length; j < len1; j++) {
	            a = array[j];
	            if (keepTester(a)) {
	              results.push(a);
	            }
	          }
	          return results;
	        })();
	      }
	    }
	    return array;
	  };


	  /*
	  IN: accepts any number of arguments
	  NOTE: RECURSIVE: recurses into all arry or arguments-objects and adds their contents
	    to the top level (flatten)
	   */

	  ArrayCompactFlatten.flatten = flatten = function(firstArg) {
	    return compactFlattenIfNeeded(arguments.length === 1 ? isArrayOrArguments(firstArg) ? firstArg : [firstArg] : arguments);
	  };


	  /*
	  IN: array: any object that has a length
	  
	  EFFECT:
	    itterates over array and recurse over any element which isArrayOrArguments
	    invokes f on every element that is not isArrayOrArguments
	  OUT: array (same as passed in)
	   */

	  ArrayCompactFlatten.deepArrayEach = deepArrayEach = function(array, f) {
	    var el, i, len;
	    for (i = 0, len = array.length; i < len; i++) {
	      el = array[i];
	      if (isArrayOrArguments(el)) {
	        deepArrayEach(el, f);
	      } else {
	        f(el);
	      }
	    }
	    return array;
	  };


	  /*
	  IN:
	    array: array or arguments-object
	    keepTester: (value) -> true/false
	      OUT: return true if that element should be in the output
	  
	  OUT: array where all elements test true to keepTester
	  NOTE: RECURSIVE: recurses into all arry or arguments-objects and adds their contents
	    to the top level (flatten)
	   */

	  ArrayCompactFlatten.compactFlatten = function(array, keepTester) {
	    if (keepTester == null) {
	      keepTester = keepUnlessNullOrUndefined;
	    }
	    return compactFlattenIfNeeded(array, keepTester);
	  };

	  arraySlice = Array.prototype.slice;

	  doFlattenInternal = function(array, keepTester) {
	    var output;
	    output = [];
	    deepArrayEach(array, function(el) {
	      if (keepTester(el)) {
	        return output.push(el);
	      }
	    });
	    return output;
	  };

	  keepAll = function() {
	    return true;
	  };

	  compactFlattenIfNeeded = function(array, keepTester) {
	    if (keepTester == null) {
	      keepTester = keepAll;
	    }
	    if (needsFlatteningOrCompacting(array, keepTester)) {
	      return doFlattenInternal(array, keepTester);
	    } else if (array.constructor !== Array) {
	      return arraySlice.call(array);
	    } else {
	      return array;
	    }
	  };

	  return ArrayCompactFlatten;

	})();


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var StringCase, compactFlatten;

	compactFlatten = __webpack_require__(16).compactFlatten;

	module.exports = StringCase = (function() {
	  function StringCase() {}

	  StringCase.getCodeWords = function(str) {
	    var _words, word, words;
	    _words = str.match(/[a-zA-Z][a-zA-Z0-9]*/g);
	    if (!_words) {
	      return [];
	    }
	    words = (function() {
	      var i, len, results;
	      results = [];
	      for (i = 0, len = _words.length; i < len; i++) {
	        word = _words[i];
	        results.push(word.match(/(?:[A-Z]{2,}(?![a-z]))|[A-Z][a-z0-9]*|[a-z0-9]+/g));
	      }
	      return results;
	    })();
	    return compactFlatten(words);
	  };

	  StringCase.capitalize = function(str) {
	    return str.charAt(0).toUpperCase() + str.slice(1);
	  };

	  StringCase.decapitalize = function(str) {
	    return str.charAt(0).toLowerCase() + str.slice(1);
	  };

	  StringCase.getLowerCaseCodeWords = function(str) {
	    var i, len, ref, results, word;
	    ref = StringCase.getCodeWords(str);
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      word = ref[i];
	      results.push(word.toLowerCase());
	    }
	    return results;
	  };

	  StringCase.upperCamelCase = function(str) {
	    var word;
	    return ((function() {
	      var i, len, ref, results;
	      ref = this.getLowerCaseCodeWords(str);
	      results = [];
	      for (i = 0, len = ref.length; i < len; i++) {
	        word = ref[i];
	        results.push(this.capitalize(word));
	      }
	      return results;
	    }).call(StringCase)).join("");
	  };

	  StringCase.lowerCamelCase = function(str) {
	    return StringCase.decapitalize(StringCase.upperCamelCase(str));
	  };

	  StringCase.snakeCase = function(str) {
	    return (StringCase.getLowerCaseCodeWords(str)).join("_");
	  };

	  StringCase.dashCase = function(str) {
	    return (StringCase.getLowerCaseCodeWords(str)).join("-");
	  };

	  return StringCase;

	})();


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var Merge, compactFlatten, isPlainObject;

	compactFlatten = __webpack_require__(16).compactFlatten;

	isPlainObject = __webpack_require__(19).isPlainObject;

	module.exports = Merge = (function() {
	  var deepMerge, merge, mergeInto, pureMerge;

	  function Merge() {}


	  /*
	  
	  merge "flattens" its arguments and then adds all keys from all objects in
	  the list into a new object which is returned.
	  
	  return: new object
	  
	  The first object's keys are added first. If two or more objects have the same
	  keys, the value set in the result is the last object's in the list with that key.
	   */

	  Merge.merge = merge = function() {
	    return mergeInto({}, arguments);
	  };


	  /*
	  The same as 'merge' with one difference:
	  
	  Instead of a new object, all objects are merged into the first object in the list.
	  
	  return: first object in the flattened list
	  return: null if no source objects
	   */

	  Merge.mergeInto = mergeInto = function() {
	    var i, j, k, ref, result, source, sources, v;
	    sources = compactFlatten(arguments);
	    if (sources.length === 0) {
	      return null;
	    }
	    result = sources[0] || {};
	    for (i = j = 1, ref = sources.length; j < ref; i = j += 1) {
	      source = sources[i];
	      for (k in source) {
	        v = source[k];
	        result[k] = v;
	      }
	    }
	    return result;
	  };


	  /*
	  Just like mergeInfo except only merge into the result object UNLESs result.hasOwnProperty
	  
	  if
	    mergeInfo a, b is just like merge a, b except it modifies and returns a instead of returning a new object
	  then
	    mergeIntoUnless b, a is just like merge a, b except it modifies and returns b instead of returning a new object
	  
	  Note: mergeIntoUnless a, b, c, d, e, f is like merge f, e, d, c, b, a
	   */

	  Merge.mergeIntoUnless = function() {
	    var i, j, k, ref, result, source, sources, v;
	    sources = compactFlatten(arguments);
	    if (sources.length === 0) {
	      return null;
	    }
	    result = sources[0] || {};
	    for (i = j = 1, ref = sources.length; j < ref; i = j += 1) {
	      source = sources[i];
	      for (k in source) {
	        v = source[k];
	        if (!result.hasOwnProperty(k)) {
	          result[k] = v;
	        }
	      }
	    }
	    return result;
	  };

	  Merge.deepMerge = deepMerge = function() {
	    var k, list, out, v, val;
	    list = compactFlatten(arguments);
	    out = merge(list);
	    for (k in out) {
	      v = out[k];
	      if (isPlainObject(v)) {
	        out[k] = deepMerge((function() {
	          var j, len, results;
	          results = [];
	          for (j = 0, len = list.length; j < len; j++) {
	            val = list[j];
	            results.push(val[k]);
	          }
	          return results;
	        })());
	      }
	    }
	    return out;
	  };

	  Merge.hasAllProps = function(o1, o2) {
	    var k, v;
	    for (k in o1) {
	      v = o1[k];
	      if (!o2.hasOwnProperty(k)) {
	        return false;
	      }
	    }
	    return true;
	  };

	  Merge.pureMerge = pureMerge = function() {
	    var j, last, len, source, sources;
	    sources = compactFlatten(arguments);
	    if (sources.length === 0) {
	      return null;
	    }
	    if (sources.length === 1) {
	      return sources[0];
	    }
	    last = sources[sources.length - 1];
	    for (j = 0, len = sources.length; j < len; j++) {
	      source = sources[j];
	      if (source !== last) {
	        if (!Merge.hasAllProps(source, last)) {
	          return Merge.merge(sources);
	        }
	      }
	    }
	    return last;
	  };


	  /*
	  I might consider adding "o" - which works like Object-Tree constructors:
	    First, it compact-flattens args
	    Second, it gathers up and merges all plain-objects in its arguments list
	    Last, all remaining items get added to the "children" list
	  The question is, what does it return? Options:
	  
	    OPTION: If only plain-objects after compact-flatten, just return the merged object ELSE:
	  
	  Options if both objects and non-object values are present:
	    a. return compactFlatten [plainObject, nonObjectValues]
	    b. return merge plainObject, children: nonObjectValues
	    c. return new MClass plainObject, nonObjectValues
	      class MClass extends BaseObject
	        @properties "props children"
	        constructor: (@props, @children) ->
	   */

	  Merge.m = pureMerge;

	  return Merge;

	})();


/***/ },
/* 19 */
/***/ function(module, exports) {

	var Types;

	module.exports = Types = (function() {
	  var hasOwnProperties, hasProperties, isArray, isClass, isFunction, isJsonAtomicType, isNumber, isObject, isPlainArray, isPlainObject, isString;

	  function Types() {}

	  Types.isPromise = function(obj) {
	    return isFunction(obj != null ? obj.then : void 0);
	  };

	  Types.isRegExp = function(obj) {
	    return obj instanceof RegExp;
	  };

	  Types.isNumber = isNumber = function(obj) {
	    return typeof obj === "number";
	  };


	  /*
	  Maybe we should just the API for array compatibility rather than specific types.
	    typeof obj == "object" &&
	      && isFunction obj.forEach
	      && isFunction obj.indexOf
	      && isNumber obj.length
	   */

	  Types.isArray = isArray = self.Uint8ClampedArray ? function(obj) {
	    return !!obj && (obj.constructor === Array || obj instanceof Uint8ClampedArray || obj instanceof Int8Array || obj instanceof Uint8Array || obj instanceof Int16Array || obj instanceof Uint16Array || obj instanceof Int32Array || obj instanceof Uint32Array || obj instanceof Float32Array || obj instanceof Float64Array);
	  } : function(obj) {
	    return !!obj && (obj.constructor === Array || obj instanceof Int8Array || obj instanceof Uint8Array || obj instanceof Int16Array || obj instanceof Uint16Array || obj instanceof Int32Array || obj instanceof Uint32Array || obj instanceof Float32Array || obj instanceof Float64Array);
	  };

	  Types.isDate = function(obj) {
	    return obj && obj.constructor === Date;
	  };

	  Types.isString = isString = function(obj) {
	    return typeof obj === "string";
	  };

	  Types.isFunction = isFunction = function(obj) {
	    return typeof obj === "function";
	  };

	  Types.isEmptyObject = function(obj) {
	    return Object.keys(obj).length === 0;
	  };

	  Types.isBoolean = function(obj) {
	    return obj === true || obj === false;
	  };

	  Types.isClass = isClass = function(obj) {
	    return !!(typeof obj === "function" && ((typeof obj.__super__ === "object") || (hasOwnProperties(obj)) || (obj.prototype && hasProperties(obj.prototype))));
	  };

	  Types.isJsonAtomicType = isJsonAtomicType = function(a) {
	    return isString(a) || isNumber(a) || a === true || a === false || a === null;
	  };

	  Types.isJsonType = function(a) {
	    return isJsonAtomicType(a) || isPlainObject(a) || isPlainArray(a);
	  };

	  Types.isObject = isObject = function(obj) {
	    return !!obj && typeof obj === "object" && !isPlainArray(obj);
	  };

	  Types.isPlainArray = isPlainArray = function(v) {
	    if (v) {
	      return v.constructor === Array;
	    } else {
	      return false;
	    }
	  };

	  Types.isPlainObject = isPlainObject = function(v) {
	    if (v) {
	      return v.constructor === Object;
	    } else {
	      return false;
	    }
	  };

	  Types.hasProperties = hasProperties = function(o) {
	    var k;
	    for (k in o) {
	      return true;
	    }
	    return false;
	  };

	  Types.hasOwnProperties = hasOwnProperties = function(o) {
	    var k;
	    for (k in o) {
	      if (o.hasOwnProperty(k)) {
	        return true;
	      }
	    }
	    return false;
	  };

	  return Types;

	})();


/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = false;

	// Only Node.JS has a process variable that is of [[Class]] process
	try {
	 module.exports = Object.prototype.toString.call(global.process) === '[object process]' 
	} catch(e) {}


/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = {
		"name": "neptune-namespaces",
		"version": "1.6.0",
		"description": "Generate index.coffee and namespace.coffee files from directory structures",
		"scripts": {
			"test": "neptune-namespaces --std;mocha -u tdd --compilers coffee:coffee-script/register -w"
		},
		"author": "Shane Brinkman-Davis Delamore",
		"license": "MIT",
		"preferGlobal": true,
		"bin": {
			"nn": "./neptune-namespaces",
			"neptune-namespaces": "./neptune-namespaces"
		},
		"repository": {
			"type": "git",
			"url": "https://github.com/Imikimi-LLC/neptune-namespaces"
		},
		"main": "index.coffee",
		"dependencies": {
			"coffee-loader": "^0.7.2",
			"coffee-script": "^1.10.0",
			"colors": "^1.1.2",
			"detect-node": "^2.0.3",
			"fs-promise": "^0.5.0",
			"glob": "^7.1.1",
			"commander": "^2.9.0"
		},
		"devDependencies": {
			"chai": "^3.5.0",
			"mocha": "^2.5.3"
		}
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var Auth, CommunicationStatus, Pipeline, Request, Response, Session, defineModule, failure, isPresentString, isString, log, missing, present, ref, ref1, ref2, success, wordsArray,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(24), defineModule = ref.defineModule, log = ref.log;

	ref1 = __webpack_require__(24), defineModule = ref1.defineModule, log = ref1.log, isString = ref1.isString, present = ref1.present, CommunicationStatus = ref1.CommunicationStatus, wordsArray = ref1.wordsArray;

	ref2 = __webpack_require__(116), Response = ref2.Response, Request = ref2.Request, Pipeline = ref2.Pipeline, Session = ref2.Session;

	success = CommunicationStatus.success, failure = CommunicationStatus.failure, missing = CommunicationStatus.missing;

	isPresentString = function(s) {
	  return isString(s) && present(s);
	};

	defineModule(module, Auth = (function(superClass) {
	  var authenticationFailed;

	  extend(Auth, superClass);

	  function Auth() {
	    return Auth.__super__.constructor.apply(this, arguments);
	  }

	  Auth.remoteServer("http://localhost:8085");

	  authenticationFailed = function(data) {
	    var password, ref3, username;
	    ref3 = data || {}, username = ref3.username, password = ref3.password;
	    if (!isPresentString(username)) {
	      return "username not present";
	    }
	    if (!isPresentString(password)) {
	      return "password not present";
	    }
	    if (username !== password) {
	      return "username and password don't match";
	    }
	  };

	  Auth.handlers({
	    authenticate: function(request) {
	      var data, message;
	      data = request.data;
	      if (message = authenticationFailed(data)) {
	        return request.failure({
	          data: {
	            message: message
	          }
	        });
	      } else {
	        return request.success({
	          session: {
	            username: data.username
	          }
	        });
	      }
	    },
	    loggedInAs: function(request) {
	      var username;
	      if (username = isPresentString(request.session.username)) {
	        return username;
	      } else {
	        return request.success();
	      }
	    }
	  });

	  return Auth;

	})(Pipeline));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 23 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var ref, ref1;

	module.exports = ((ref = global.Neptune) != null ? (ref1 = ref.Art) != null ? ref1.Foundation : void 0 : void 0) || __webpack_require__(25);


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(26).includeInNamespace(__webpack_require__(28));

	__webpack_require__(71);

	__webpack_require__(109);

	__webpack_require__(78);

	__webpack_require__(29);

	__webpack_require__(87);


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Foundation,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Art = __webpack_require__(27);

	module.exports = Art.Foundation || Art.addNamespace('Foundation', Foundation = (function(superClass) {
	  extend(Foundation, superClass);

	  function Foundation() {
	    return Foundation.__super__.constructor.apply(this, arguments);
	  }

	  return Foundation;

	})(Neptune.Base));


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Neptune,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Neptune = __webpack_require__(8);

	module.exports = Neptune.Art || Neptune.addNamespace('Art', Art = (function(superClass) {
	  extend(Art, superClass);

	  function Art() {
	    return Art.__super__.constructor.apply(this, arguments);
	  }

	  return Art;

	})(Neptune.Base));


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var _package;

	module.exports = [
	  __webpack_require__(29), __webpack_require__(71), __webpack_require__(78), __webpack_require__(87), {
	    "package": _package = __webpack_require__(108),
	    version: _package.version
	  }
	];


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(30).includeInNamespace(__webpack_require__(31)).addModules({
	  ArrayExtensions: __webpack_require__(35),
	  AsyncExtensions: __webpack_require__(38),
	  CallStack: __webpack_require__(70),
	  Clone: __webpack_require__(68),
	  CommonJs: __webpack_require__(49),
	  Eq: __webpack_require__(39),
	  Function: __webpack_require__(41),
	  Hash: __webpack_require__(40),
	  Log: __webpack_require__(69),
	  Map: __webpack_require__(54),
	  Math: __webpack_require__(36),
	  MinimalBaseObject: __webpack_require__(56),
	  ObjectDiff: __webpack_require__(42),
	  ParseUrl: __webpack_require__(43),
	  Promise: __webpack_require__(32),
	  PromisedFileReader: __webpack_require__(44),
	  Regexp: __webpack_require__(37),
	  Ruby: __webpack_require__(45),
	  ShallowClone: __webpack_require__(46),
	  String: __webpack_require__(47),
	  Time: __webpack_require__(48),
	  Types: __webpack_require__(34),
	  Unique: __webpack_require__(55)
	});

	__webpack_require__(50);


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var Foundation, StandardLib,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(26);

	module.exports = Foundation.StandardLib || Foundation.addNamespace('StandardLib', StandardLib = (function(superClass) {
	  extend(StandardLib, superClass);

	  function StandardLib() {
	    return StandardLib.__super__.constructor.apply(this, arguments);
	  }

	  return StandardLib;

	})(Neptune.Base));


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [[__webpack_require__(32), "testPromise", "containsPromises", "deepAll"], __webpack_require__(12), __webpack_require__(35), __webpack_require__(38), __webpack_require__(39), __webpack_require__(41), __webpack_require__(42), __webpack_require__(40), __webpack_require__(36), __webpack_require__(43), __webpack_require__(44), __webpack_require__(37), __webpack_require__(45), __webpack_require__(46), __webpack_require__(47), __webpack_require__(48), __webpack_require__(34), __webpack_require__(49), __webpack_require__(50), __webpack_require__(68), __webpack_require__(69), __webpack_require__(70)];


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var ArtPromise, Promise, deepEach, deepMap, isFunction, ref;

	Promise = __webpack_require__(33);

	ref = __webpack_require__(34), deepMap = ref.deepMap, deepEach = ref.deepEach, isFunction = ref.isFunction;


	/*
	ArtPromise extends ES6 Promises in the following ways:

	- constructing a promise with no parameters is allowed
	- promise.resolve and promise.reject are supported as
	  alternative ways to resolve or reject a promise

	If native promises are supported, they are used,
	otherwise a polyfill is used.

	TODO:
	  ES6 says Promises are designed to be extensible:
	  http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects

	  If I properly extend Promise, will my new methods be available on all promise objects... ???
	    At least all promises chained off of one created using my Promise class... ???

	  But I had problems doing that. Maybe it's how CoffeeScript extends things?

	TODO:
	  I want a way to do 'then' and 'catch' without effecting any following 'thens' or 'caches'

	  It's easy to implement, but what to call it? Leaning towards tapThen. If I had Ruby's 'tap', then
	  I could do this effectively with:

	    .tap (a) -> a.then ->
	    but
	    .tapThen ->
	    is even nicer

	  Will it be available on returned promises?
	    (see ES6 Promise extension above)

	  tapThen: (successF, failF) ->
	    @then successF, failF
	    @ # return the current promise, not the one returned from the then-call above
	 */

	module.exports = ArtPromise = (function() {
	  var deepAll, isPromise, noop;

	  ArtPromise.ES6Promise = Promise;

	  ArtPromise.all = Promise.all;

	  ArtPromise.race = Promise.race;

	  ArtPromise.reject = Promise.reject;

	  ArtPromise.resolve = Promise.resolve;

	  ArtPromise.then = function(f) {
	    return Promise.resolve().then(f);
	  };

	  ArtPromise.isPromise = isPromise = function(f) {
	    return isFunction(f != null ? f.then : void 0);
	  };

	  ArtPromise.testPromise = function(promise) {
	    promise.then(function(v) {
	      return console.log("promise.resolve", v);
	    });
	    return promise["catch"](function(v) {
	      return console.log("promise.reject", v);
	    });
	  };

	  ArtPromise.mapAll = function(map) {
	    var key, keys;
	    keys = Object.keys(map);
	    return Promise.all((function() {
	      var j, len, results;
	      results = [];
	      for (j = 0, len = keys.length; j < len; j++) {
	        key = keys[j];
	        results.push(map[key]);
	      }
	      return results;
	    })()).then(function(values) {
	      var i, j, key, len, out;
	      out = {};
	      for (i = j = 0, len = keys.length; j < len; i = ++j) {
	        key = keys[i];
	        out[key] = values[i];
	      }
	      return out;
	    });
	  };

	  ArtPromise.containsPromises = function(plainStructure) {
	    var containsPromises;
	    containsPromises = false;
	    deepEach(plainStructure, function(v) {
	      return containsPromises || (containsPromises = isPromise(v));
	    });
	    return containsPromises;
	  };

	  ArtPromise.withCallback = function(startPromiseBodyFunction) {
	    return new Promise(function(resolve, reject) {
	      var callback;
	      callback = function(err, data) {
	        if (err) {
	          return reject(err);
	        }
	        return resolve(data);
	      };
	      return startPromiseBodyFunction(callback);
	    });
	  };

	  noop = function(a) {
	    return a;
	  };

	  ArtPromise.deepAll = deepAll = function(plainStructure, resolvedResultPreprocessor) {
	    var promises;
	    if (resolvedResultPreprocessor == null) {
	      resolvedResultPreprocessor = noop;
	    }
	    promises = [];
	    deepEach(plainStructure, function(v) {
	      if (isPromise(v)) {
	        return promises.push(v);
	      }
	    });
	    return Promise.all(promises).then(function(resolved) {
	      var i;
	      i = 0;
	      return deepMap(plainStructure, function(v) {
	        if (isPromise(v)) {
	          return resolvedResultPreprocessor(resolved[i++]);
	        } else {
	          return v;
	        }
	      });
	    });
	  };

	  ArtPromise.deepResolve = deepAll;


	  /*
	  Serializer makes it easy to ensure promise-returning functions are invoked in order, after each
	  promise is resolved.
	  
	  USAGE:
	  
	     * EXAMPLE 1: Basic - not too different from normal Promise sequences
	    serializer = new ArtPromise.Serializer
	    serializer.then -> doA()
	  
	     * then execute sometime later, possbly asynchronously:
	    serializer.then -> doB()
	  
	     * then execute sometime later, possbly asynchronously:
	    serializer.then (doBResult) ->
	       * doA and doB have completed and any returning promises resolved
	       * the result of the last 'then' is passed in
	  
	     * EXAMPLE 2: apply the same async function serially to each element in list
	     * - list's order is preserved
	     * - each invocation waits for the previous one to complete
	    serializer = new ArtPromise.Serializer
	    list.forEach serializer.serialize f = (element) -> # do something with element, possibly returning a promise
	    serializer.then (lastFResult) ->
	       * do something after the last invocation of f completes
	       * the result of the last invocation of 'f' is passed in
	  
	     * EXAMPLE 3: mix multiple serialized functions and manual @then invocations
	     * - invocation order is perserved
	    serializer = new ArtPromise.Serializer
	    serializedA = serializer.serialize aFunction
	    serializedB = serializer.serialize bFunction
	  
	    serializedB()
	    serializer.then -> @cFunction()
	    serializedB()
	    serializedA()
	    serializedB()
	  
	    serializer.then (lastBFunctionResult) ->
	       * this is invoked AFTER:
	       * evaluating, in order, waiting for any promises:
	       *   bFunction, cFunction, bFunction, aFunction, bFunction
	   */

	  ArtPromise.Serializer = (function() {
	    function Serializer() {
	      this._lastPromise = ArtPromise.resolve();
	    }


	    /*
	    Returns a new function, serializedF, that acts just like 'f'
	      - f is forced to be async:
	        - if f doesn't return a promise, a promise wrapping f's result is returned
	      - invoking serializedF queues f in this serializer instance's sequence via @then
	    IN: any function with any signature
	    OUT: (f's signature) -> promise.then (fResult) ->
	    
	    Example with Comparison:
	    
	       * all asyncActionReturningPromise(element)s get called immediately
	       * and may complete randomly at some later event
	      myArray.forEach (element) ->
	        asyncActionReturningPromise element
	    
	       * VS
	    
	       * asyncActionReturningPromise(element) only gets called
	       * after the previous call completes.
	       * If a previous call failes, the remaining calls never happen.
	      serializer = new Promise.Serializer
	      myArray.forEach serializer.serialize (element) ->
	        asyncActionReturningPromise element
	    
	       * bonus, you can do things when all the promises complete:
	      serializer.then =>
	    
	       * or if anything fails
	      serializer.catch =>
	    
	       * VS - shortcut
	    
	       * Just insert "Promise.serialize" before your forEach function to ensure serial invocations.
	       * However, you don't get the full functionality of the previous example.
	      myArray.forEach Promise.serialize (element) ->
	        asyncActionReturningPromise element
	     */

	    Serializer.prototype.serialize = function(f) {
	      return (function(_this) {
	        return function() {
	          var args;
	          args = arguments;
	          return _this.then(function() {
	            return f.apply(null, args);
	          });
	        };
	      })(this);
	    };

	    Serializer.prototype.then = function(resolved, rejected) {
	      return this._lastPromise = this._lastPromise.then(resolved, rejected);
	    };

	    Serializer.prototype["catch"] = function(rejected) {
	      return this._lastPromise = this._lastPromise["catch"](rejected);
	    };

	    Serializer.prototype.always = function(f) {
	      return this._lastPromise = this._lastPromise["catch"]((function(_this) {
	        return function() {
	          return null;
	        };
	      })(this)).then(f);
	    };


	    /*
	    OUT: promise that resolves / rejects only when there are no more
	      pending tasks queued with the serializer.
	    
	      .then (lastResult) ->
	      .catch (lastError) ->
	    
	    NOTE: allDonePromise could complete, then more tasks could be queued with the serializer.
	      Promises can't be resolved/rejected twice, so when the more-tasks complete, the first
	      allDonePromise won't do anything.
	      However, you can call allDonePromise again once the tasks are queued and get notified
	      when THEY are done.
	     */

	    Serializer.prototype.allDonePromise = function() {
	      var currentLastPromise;
	      currentLastPromise = this._lastPromise;
	      return currentLastPromise.then((function(_this) {
	        return function(lastResult) {
	          if (currentLastPromise === _this._lastPromise) {
	            return lastResult;
	          } else {
	            return _this.allDonePromise();
	          }
	        };
	      })(this))["catch"]((function(_this) {
	        return function(lastError) {
	          if (currentLastPromise === _this._lastPromise) {
	            throw lastError;
	          } else {
	            return _this.allDonePromise();
	          }
	        };
	      })(this));
	    };

	    return Serializer;

	  })();


	  /*
	  OUT: serializedF = -> Promise.resolve f arguments...
	    IN: any arguments
	    EFFECT: f is invoked with arguments passed in AFTER the last invocation of serializedF completes.
	    OUT: promise.then -> results from f
	  
	  NOTE: 'f' can return a promise, but it doesn't have to. If it does return a promise, the next
	    'f' invocation will not start until and if the previous one's promise completes.
	  
	  USAGE:
	    serializedF = Promise.serialize f = -> # do something, possibly returning a promise
	    serializedF()
	    serializedF()
	    serializedF()
	    .then (resultOfLastF)->
	       * executed after f was executed and any returned promises resolved, 3 times, sequentially
	  
	  OR
	    serializedF = Promise.serialize f = (element) -> # do something with element, possibly returning a promise
	    Promise.all (serializedF item for item in list)
	    .then (results) ->
	       * f was excuted list.length times sequentially
	       * results contains the result values from each execution, in order
	   */

	  ArtPromise.serialize = function(f) {
	    return new ArtPromise.Serializer().serialize(f);
	  };

	  function ArtPromise(_function) {
	    this.resolve = this.reject = null;
	    this._nativePromise = null;
	    this._nativePromise = new Promise((function(_this) {
	      return function(resolve1, reject1) {
	        _this.resolve = resolve1;
	        _this.reject = reject1;
	        return typeof _function === "function" ? _function(_this.resolve, _this.reject) : void 0;
	      };
	    })(this));
	  }

	  ArtPromise.prototype.then = function(a, b) {
	    return this._nativePromise.then(a, b);
	  };

	  ArtPromise.prototype["catch"] = function(a) {
	    return this._nativePromise["catch"](a);
	  };

	  return ArtPromise;

	})();

	self.Promise || (self.Promise = ArtPromise);


/***/ },
/* 33 */
/***/ function(module, exports) {

	(function (root) {

	  // Store setTimeout reference so promise-polyfill will be unaffected by
	  // other code modifying setTimeout (like sinon.useFakeTimers())
	  var setTimeoutFunc = setTimeout;

	  function noop() {}
	  
	  // Polyfill for Function.prototype.bind
	  function bind(fn, thisArg) {
	    return function () {
	      fn.apply(thisArg, arguments);
	    };
	  }

	  function Promise(fn) {
	    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
	    if (typeof fn !== 'function') throw new TypeError('not a function');
	    this._state = 0;
	    this._handled = false;
	    this._value = undefined;
	    this._deferreds = [];

	    doResolve(fn, this);
	  }

	  function handle(self, deferred) {
	    while (self._state === 3) {
	      self = self._value;
	    }
	    if (self._state === 0) {
	      self._deferreds.push(deferred);
	      return;
	    }
	    self._handled = true;
	    Promise._immediateFn(function () {
	      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
	      if (cb === null) {
	        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
	        return;
	      }
	      var ret;
	      try {
	        ret = cb(self._value);
	      } catch (e) {
	        reject(deferred.promise, e);
	        return;
	      }
	      resolve(deferred.promise, ret);
	    });
	  }

	  function resolve(self, newValue) {
	    try {
	      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
	      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
	        var then = newValue.then;
	        if (newValue instanceof Promise) {
	          self._state = 3;
	          self._value = newValue;
	          finale(self);
	          return;
	        } else if (typeof then === 'function') {
	          doResolve(bind(then, newValue), self);
	          return;
	        }
	      }
	      self._state = 1;
	      self._value = newValue;
	      finale(self);
	    } catch (e) {
	      reject(self, e);
	    }
	  }

	  function reject(self, newValue) {
	    self._state = 2;
	    self._value = newValue;
	    finale(self);
	  }

	  function finale(self) {
	    if (self._state === 2 && self._deferreds.length === 0) {
	      Promise._immediateFn(function() {
	        if (!self._handled) {
	          Promise._unhandledRejectionFn(self._value);
	        }
	      });
	    }

	    for (var i = 0, len = self._deferreds.length; i < len; i++) {
	      handle(self, self._deferreds[i]);
	    }
	    self._deferreds = null;
	  }

	  function Handler(onFulfilled, onRejected, promise) {
	    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	    this.promise = promise;
	  }

	  /**
	   * Take a potentially misbehaving resolver function and make sure
	   * onFulfilled and onRejected are only called once.
	   *
	   * Makes no guarantees about asynchrony.
	   */
	  function doResolve(fn, self) {
	    var done = false;
	    try {
	      fn(function (value) {
	        if (done) return;
	        done = true;
	        resolve(self, value);
	      }, function (reason) {
	        if (done) return;
	        done = true;
	        reject(self, reason);
	      });
	    } catch (ex) {
	      if (done) return;
	      done = true;
	      reject(self, ex);
	    }
	  }

	  Promise.prototype['catch'] = function (onRejected) {
	    return this.then(null, onRejected);
	  };

	  Promise.prototype.then = function (onFulfilled, onRejected) {
	    var prom = new (this.constructor)(noop);

	    handle(this, new Handler(onFulfilled, onRejected, prom));
	    return prom;
	  };

	  Promise.all = function (arr) {
	    var args = Array.prototype.slice.call(arr);

	    return new Promise(function (resolve, reject) {
	      if (args.length === 0) return resolve([]);
	      var remaining = args.length;

	      function res(i, val) {
	        try {
	          if (val && (typeof val === 'object' || typeof val === 'function')) {
	            var then = val.then;
	            if (typeof then === 'function') {
	              then.call(val, function (val) {
	                res(i, val);
	              }, reject);
	              return;
	            }
	          }
	          args[i] = val;
	          if (--remaining === 0) {
	            resolve(args);
	          }
	        } catch (ex) {
	          reject(ex);
	        }
	      }

	      for (var i = 0; i < args.length; i++) {
	        res(i, args[i]);
	      }
	    });
	  };

	  Promise.resolve = function (value) {
	    if (value && typeof value === 'object' && value.constructor === Promise) {
	      return value;
	    }

	    return new Promise(function (resolve) {
	      resolve(value);
	    });
	  };

	  Promise.reject = function (value) {
	    return new Promise(function (resolve, reject) {
	      reject(value);
	    });
	  };

	  Promise.race = function (values) {
	    return new Promise(function (resolve, reject) {
	      for (var i = 0, len = values.length; i < len; i++) {
	        values[i].then(resolve, reject);
	      }
	    });
	  };

	  // Use polyfill for setImmediate for performance gains
	  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
	    function (fn) {
	      setTimeoutFunc(fn, 0);
	    };

	  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
	    if (typeof console !== 'undefined' && console) {
	      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
	    }
	  };

	  /**
	   * Set the immediate function to execute callbacks
	   * @param fn {function} Function to execute
	   * @deprecated
	   */
	  Promise._setImmediateFn = function _setImmediateFn(fn) {
	    Promise._immediateFn = fn;
	  };

	  /**
	   * Change the function to execute on unhandled rejection
	   * @param {function} fn Function to execute on unhandled rejection
	   * @deprecated
	   */
	  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
	    Promise._unhandledRejectionFn = fn;
	  };
	  
	  if (typeof module !== 'undefined' && module.exports) {
	    module.exports = Promise;
	  } else if (!root.Promise) {
	    root.Promise = Promise;
	  }

	})(this);


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var NeptuneLib, Types, isFunction, isJsonAtomicType, isObject, isPlainArray, isPlainObject, isString, ref;

	NeptuneLib = __webpack_require__(12);

	ref = NeptuneLib.Types, isPlainObject = ref.isPlainObject, isString = ref.isString, isFunction = ref.isFunction, isObject = ref.isObject, isPlainArray = ref.isPlainArray, isJsonAtomicType = ref.isJsonAtomicType;

	module.exports = Types = (function() {
	  var cloneObjectUpToKey, deepEach, deepEachAll, deepMap, deepMapArray, deepMapObject, functionName, noopMapper, objectName, toJsonStructure, toPostMessageStructure;

	  function Types() {}

	  NeptuneLib.mergeInto(Types, NeptuneLib.Types);

	  Types.gt = function(a, b) {
	    if (isFunction(a.gt)) {
	      return a.gt(b);
	    } else {
	      return a > b;
	    }
	  };

	  Types.lt = function(a, b) {
	    if (isFunction(a.lt)) {
	      return a.lt(b);
	    } else {
	      return a < b;
	    }
	  };

	  Types.gte = function(a, b) {
	    if (isFunction(a.gte)) {
	      return a.gte(b);
	    } else {
	      return a >= b;
	    }
	  };

	  Types.lte = function(a, b) {
	    if (isFunction(a.lte)) {
	      return a.lte(b);
	    } else {
	      return a <= b;
	    }
	  };


	  /*
	  like RubyOnRails#present:
	    "An object is present if it's not blank."
	  
	  basic:
	    present null, undefined or "" returns false (or whatever returnIfNotPresent is set to)
	    all other values return something truish - generally themselves
	  
	  custom:
	    for bar where isFunction bar.present
	      present bar returns bar.present()
	  
	  special-case truish results:
	    present 0 or false returns true
	  
	  for any other value foo,
	    present foo returns foo
	  
	  IN:
	    obj:
	      object tested for presence
	    returnIfNotPresent: [false]
	      what to return if not present
	  
	  OUT:
	    returnIfNotPresent, true, or the value passed in
	  
	  If 'obj' has method: obj.present() => obj.present()
	   */

	  Types.present = function(obj, returnIfNotPresent) {
	    var present;
	    if (returnIfNotPresent == null) {
	      returnIfNotPresent = false;
	    }
	    present = isFunction(obj != null ? obj.getPresent : void 0) ? obj.getPresent() : isFunction(obj != null ? obj.present : void 0) ? obj.present() : isString(obj) ? !obj.match(/^\s*$/) : obj !== void 0 && obj !== null;
	    if (present) {
	      return obj || true;
	    } else {
	      return returnIfNotPresent;
	    }
	  };

	  Types.functionName = functionName = function(f) {
	    var matched;
	    return f.name || ((matched = ("" + f).match(/function ([a-zA-Z]+)\(/)) && matched[1]) || "function";
	  };

	  Types.objectName = objectName = function(obj) {
	    var a, name, ref1;
	    if (!obj) {
	      return "" + obj;
	    } else if (a = typeof obj.getNamespacePath === "function" ? obj.getNamespacePath() : void 0) {
	      return a;
	    } else if (a = obj.classPathName) {
	      return a;
	    } else if (obj.constructor === Object) {
	      return "Object";
	    } else if (isFunction(obj)) {
	      return functionName(obj);
	    } else if (isString(name = (ref1 = obj.constructor) != null ? ref1.name : void 0) && name.length > 0) {
	      return name;
	    } else if (obj instanceof Object) {
	      return "(anonymous instanceof Object)";
	    } else {
	      return "(objectName unknown)";
	    }
	  };

	  Types.isBrowserObject = function(obj) {
	    var name;
	    if (!Types.isObject(obj)) {
	      return false;
	    }
	    name = Types.objectName(obj);
	    return name.slice(0, 4) === "HTML" || name.slice(0, 22) === "CanvasRenderingContext";
	  };


	  /*
	  IN:
	    f: (value, [key]) ->
	      f is called on every non-plainObject and non-plainArray reachable by traversing
	      the plainObject/plainArray structure
	      If f is called on a propery of a plainObject, the key for that property is also passed in.
	   */

	  Types.deepEach = deepEach = function(v, f, key) {
	    var j, k, len, subV;
	    if (isPlainArray(v)) {
	      for (j = 0, len = v.length; j < len; j++) {
	        subV = v[j];
	        deepEach(subV, f);
	      }
	    } else if (isPlainObject(v)) {
	      for (k in v) {
	        subV = v[k];
	        deepEach(subV, f, k);
	      }
	    } else {
	      f(v, key);
	    }
	    return v;
	  };


	  /*
	  deepEachAll: just like deepEach except 'f' gets called on every value found including the initial value.
	   */

	  Types.deepEachAll = deepEachAll = function(v, f, key) {
	    var j, k, len, subV;
	    f(v, key);
	    if (isPlainArray(v)) {
	      for (j = 0, len = v.length; j < len; j++) {
	        subV = v[j];
	        deepEachAll(subV, f);
	      }
	    } else if (isPlainObject(v)) {
	      for (k in v) {
	        subV = v[k];
	        deepEachAll(subV, f, k);
	      }
	    } else {

	    }
	    return v;
	  };


	  /*
	  only creates a new array if the children changed
	   */

	  deepMapArray = function(array, mapper, options) {
	    var i, j, len, r, res, v;
	    res = null;
	    for (i = j = 0, len = array.length; j < len; i = ++j) {
	      v = array[i];
	      r = deepMap(v, mapper, options);
	      if (r !== v) {
	        res || (res = array.slice());
	        res[i] = r;
	      }
	    }
	    return res || array;
	  };

	  cloneObjectUpToKey = function(obj, k) {
	    var k2, res, v;
	    res = {};
	    for (k2 in obj) {
	      v = obj[k2];
	      if (k2 === k) {
	        break;
	      }
	      res[k2] = v;
	    }
	    return res;
	  };

	  deepMapObject = function(obj, mapper, options) {
	    var k, r, res, v;
	    res = null;
	    for (k in obj) {
	      v = obj[k];
	      r = deepMap(v, mapper, options);
	      if (r !== v || res) {
	        res || (res = cloneObjectUpToKey(obj, k));
	        res[k] = r;
	      }
	    }
	    return res || obj;
	  };

	  noopMapper = function(v) {
	    return v;
	  };


	  /*
	  Applies "f" to every -value- in a nested structure of plain arrays and objects.
	  Pure functional efficient:
	    If an array or object, and all its sub values, didn't change, the original array/object is reused.
	  
	  NOTE: deepMap only yields values to 'mapper' which are NOT plain arrays nor plain objects.
	   */

	  Types.deepMap = deepMap = function(v, mapper, options) {
	    var arrayMapper, objectMapper;
	    arrayMapper = (options != null ? options.arrays : void 0) || noopMapper;
	    objectMapper = (options != null ? options.objects : void 0) || noopMapper;
	    mapper || (mapper = noopMapper);
	    if (isPlainArray(v)) {
	      return deepMapArray(arrayMapper(v), mapper, options);
	    } else if (isPlainObject(v)) {
	      return deepMapObject(objectMapper(v), mapper, options);
	    } else {
	      return mapper(v);
	    }
	  };

	  Types.toPlainStructure = function(o) {
	    return deepMap(o, function(o) {
	      if (isObject(o)) {
	        if (o.toPlainStructure) {
	          return o.toPlainStructure();
	        } else {
	          return objectName(o);
	        }
	      } else {
	        return o;
	      }
	    });
	  };


	  /*
	  similar to toPlainStructure, except all non-JSON types are converted to strings
	   */

	  Types.toJsonStructure = toJsonStructure = function(o) {
	    return deepMap(o, function(o) {
	      if (isObject(o)) {
	        if (o.toJsonStructure) {
	          return o.toJsonStructure();
	        } else {
	          return toJsonStructure(o.toPlainStructure ? o.toPlainStructure() : "" + o);
	        }
	      } else if (isJsonAtomicType(o)) {
	        return o;
	      } else {
	        return "" + o;
	      }
	    });
	  };

	  Types.toPostMessageStructure = toPostMessageStructure = function(o) {
	    return deepMap(o, function(o) {
	      switch (o.constructor) {
	        case ArrayBuffer:
	        case Date:
	        case RegExp:
	        case Blob:
	        case File:
	        case FileList:
	        case ImageData:
	        case Boolean:
	        case String:
	          return o;
	        default:
	          if (isObject(o)) {
	            if (o.toPostMessageStructure) {
	              return o.toPostMessageStructure();
	            } else {
	              if (o.toPlainStructure) {
	                return toPostMessageStructure(o.toPlainStructure());
	              } else {
	                return "" + o;
	              }
	            }
	          } else {
	            return "" + o;
	          }
	      }
	    });
	  };

	  return Types;

	})();


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var ArrayExtensions, bound, exactlyOneWordRegex, intRand, isNumber, isString, max, modulo, ref, ref1, ref2, wordsRegex,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	ref = __webpack_require__(36), bound = ref.bound, max = ref.max, intRand = ref.intRand, modulo = ref.modulo;

	ref1 = __webpack_require__(34), isNumber = ref1.isNumber, isString = ref1.isString;

	ref2 = __webpack_require__(37), wordsRegex = ref2.wordsRegex, exactlyOneWordRegex = ref2.exactlyOneWordRegex;

	module.exports = ArrayExtensions = (function() {
	  var _moveArrayElementLargeArray, _moveArrayElementSmallArray, a, arrayWithElementMoved, basicCompareFunction, indexOfOrLength, keepAll, keepIfRubyTrue, leftOfIndex, longestCommonSubsequence, moveArrayElement, randomElement, rightOfIndex, w;

	  function ArrayExtensions() {}


	  /*
	  Useful compact and compactFlatten keepTester functions
	   */

	  ArrayExtensions.keepAll = keepAll = function() {
	    return true;
	  };

	  ArrayExtensions.keepIfRubyTrue = keepIfRubyTrue = function(a) {
	    return a !== void 0 && a !== null && a !== false;
	  };

	  ArrayExtensions.reverseForEach = function(array, f) {
	    var p, v;
	    for (p = array.length - 1; p >= 0; p += -1) {
	      v = array[p];
	      f(v);
	    }
	    return array;
	  };

	  ArrayExtensions.arrayToTruthMap = function(array) {
	    var a, len1, p, res;
	    res = {};
	    for (p = 0, len1 = array.length; p < len1; p++) {
	      a = array[p];
	      res[a] = true;
	    }
	    return res;
	  };

	  ArrayExtensions.arrayToFalseMap = function(array) {
	    var a, len1, p, res;
	    res = {};
	    for (p = 0, len1 = array.length; p < len1; p++) {
	      a = array[p];
	      res[a] = false;
	    }
	    return res;
	  };

	  ArrayExtensions.concatInto = function(array, b) {
	    return array.push.apply(array, b);
	  };

	  ArrayExtensions.uniqueValues = function(sortedArray, eqF) {
	    var i, len1, p, results, v;
	    if (eqF == null) {
	      eqF = (function(a, b) {
	        return a === b;
	      });
	    }
	    results = [];
	    for (i = p = 0, len1 = sortedArray.length; p < len1; i = ++p) {
	      v = sortedArray[i];
	      if (i === 0 || !eqF(v, sortedArray[i - 1])) {
	        results.push(v);
	      }
	    }
	    return results;
	  };


	  /*
	  IN:
	    array: an array or falsy value
	    element: anything
	  OUT:
	    array containing element as the last element
	  
	  EFFECT:
	    if array was falsy, a new length-1 array is returned
	    else, array was mutated by pushing the current element
	  
	  WHY?
	    Why write this when arrays alread have push?
	  
	    1) if array is null, this works as desired
	    2) this returns array, not array.length
	      Returning the array is what Ruby's push does.
	      It makes chaining pushes easy.
	   */

	  ArrayExtensions.push = function(array, element) {
	    if (array) {
	      array.push(element);
	      return array;
	    } else {
	      return [element];
	    }
	  };

	  ArrayExtensions.peek = function(array, offset) {
	    if (offset == null) {
	      offset = -1;
	    }
	    if (array) {
	      return array[array.length + offset];
	    } else {
	      return void 0;
	    }
	  };

	  basicCompareFunction = function(a, b) {
	    return a - b;
	  };

	  ArrayExtensions.leftOfIndex = leftOfIndex = function(array, index) {
	    if (!array) {
	      return array;
	    }
	    return array.slice(0, index);
	  };

	  ArrayExtensions.rightOfIndex = rightOfIndex = function(array, index) {
	    if (!array) {
	      return array;
	    }
	    if (index < 0) {
	      index += array.length;
	    }
	    return array.slice(index + 1);
	  };

	  indexOfOrLength = function(array, value) {
	    var i;
	    if (0 > (i = array.indexOf(value))) {
	      return array.length;
	    } else {
	      return i;
	    }
	  };

	  ArrayExtensions.leftOf = function(array, value) {
	    return leftOfIndex(array, indexOfOrLength(array, value));
	  };

	  ArrayExtensions.rightOf = function(array, value) {
	    return rightOfIndex(array, indexOfOrLength(array, value));
	  };

	  ArrayExtensions.splitArray = function(array, value) {
	    var index;
	    index = indexOfOrLength(array, value);
	    return [leftOfIndex(array, index), rightOfIndex(array, index)];
	  };


	  /*
	  findSortedFirst
	  
	  Acts as-if it sorted the array and returned the first element.
	  
	  Details:
	    tests each element in the array againts the current "smallest"
	    returns the element for which tests "smaller" than every other
	    element a is "smaller" than b if compareFunction(a, b) returns >0 value
	  
	  IN:
	    array - the array to search or null
	    compareFunction - (a, b) -> # standard compare function
	      returns:
	        0: if a and b are equal
	        <0: if b is greater than a
	        >0: if a is greater than b
	      default: (a, b) -> a - b
	  
	  OUT:
	    largest value in array or undefined if array is null or length 0
	   */

	  ArrayExtensions.findSortedFirst = function(array, compareFunction) {
	    var element, i, p, ref3, returnElement;
	    if (compareFunction == null) {
	      compareFunction = basicCompareFunction;
	    }
	    if (!((array != null ? array.length : void 0) > 0)) {
	      return void 0;
	    }
	    returnElement = array[0];
	    for (i = p = 1, ref3 = array.length; p < ref3; i = p += 1) {
	      if (0 < compareFunction(returnElement, element = array[i])) {
	        returnElement = element;
	      }
	    }
	    return returnElement;
	  };

	  ArrayExtensions.first = function(array) {
	    return array[0];
	  };

	  ArrayExtensions.second = function(array) {
	    return array[1];
	  };

	  ArrayExtensions.third = function(array) {
	    return array[2];
	  };

	  ArrayExtensions.forth = function(array) {
	    return array[3];
	  };

	  ArrayExtensions.fifth = function(array) {
	    return array[4];
	  };

	  ArrayExtensions.last = function(array) {
	    if (array) {
	      return array[array.length - 1];
	    } else {
	      return void 0;
	    }
	  };

	  ArrayExtensions.pushIfNotPresent = function(array, item) {
	    if (indexOf.call(array, item) >= 0) {
	      return false;
	    } else {
	      array.push(item);
	      return true;
	    }
	  };

	  ArrayExtensions.randomElement = randomElement = function(array, fromFirstN) {
	    if (fromFirstN == null) {
	      fromFirstN = array.length;
	    }
	    return array[Math.random() * fromFirstN | 0];
	  };

	  ArrayExtensions.randomSort = function(array) {
	    var a, i, j, len, p, ref3;
	    len = array.length;
	    for (i = p = ref3 = len - 1; p >= 0; i = p += -1) {
	      j = intRand(i);
	      a = array[i];
	      array[i] = array[j];
	      array[j] = a;
	    }
	    return array;
	  };

	  ArrayExtensions.insert = function(array, index, item) {
	    if (index < 0) {
	      index = array.length + index + 1;
	    }
	    array.splice(index, 0, item);
	    return array;
	  };

	  ArrayExtensions.withInserted = function(array, index, item) {
	    return ArrayExtensions.insert(array.slice(), index, item);
	  };

	  ArrayExtensions.withSort = function(array, sortFunction) {
	    array = array.slice();
	    return array.sort(sortFunction);
	  };

	  ArrayExtensions.remove = function(array, index, amount) {
	    if (amount == null) {
	      amount = 1;
	    }
	    if (index < 0) {
	      index = array.length + index + 1;
	    }
	    array.splice(index, amount);
	    return array;
	  };

	  ArrayExtensions.removeFirstMatch = function(array, toMatchValue) {
	    var index;
	    index = array.indexOf(toMatchValue);
	    if (index >= 0) {
	      return ArrayExtensions.remove(array, index);
	    } else {
	      return array;
	    }
	  };

	  ArrayExtensions.arrayWithout = function(array, index, amount) {
	    if (amount == null) {
	      amount = 1;
	    }
	    if (index == null) {
	      index = array.length - 1;
	    }
	    return ArrayExtensions.remove(array.slice(), index, amount);
	  };

	  ArrayExtensions.arrayWithoutValue = function(array, value) {
	    return ArrayExtensions.remove(array.slice(), array.indexOf(value), 1);
	  };

	  ArrayExtensions.arrayWith = function(array, value) {
	    if (!array) {
	      return [value];
	    }
	    array = array.slice();
	    array.push(value);
	    return array;
	  };

	  ArrayExtensions.truncatedArrayWith = function(array, length, value) {
	    if (!array) {
	      return [value];
	    }
	    array = array.slice(0, length);
	    array.push(value);
	    return array;
	  };

	  ArrayExtensions.poppedArray = function(array) {
	    return array.slice(0, array.length - 1);
	  };

	  ArrayExtensions.arrayWithOne = function(array, value) {
	    if (!array) {
	      return [value];
	    }
	    array = array.slice();
	    if (indexOf.call(array, value) < 0) {
	      array.push(value);
	    }
	    return array;
	  };

	  ArrayExtensions.slice = function(a, b, c) {
	    return arraySlice.call(a, b, c);
	  };

	  ArrayExtensions.shuffleArray = function(a) {
	    var i, j, t;
	    i = a.length;
	    while (--i > 0) {
	      j = ~~(Math.random() * (i + 1));
	      t = a[j];
	      a[j] = a[i];
	      a[i] = t;
	    }
	    return a;
	  };

	  ArrayExtensions._moveArrayElementLargeArray = _moveArrayElementLargeArray = function(array, from, to) {
	    array.splice(to, 0, array.splice(from, 1)[0]);
	    return array;
	  };

	  ArrayExtensions._moveArrayElementSmallArray = _moveArrayElementSmallArray = function(array, from, to) {
	    var i, p, q, ref3, ref4, ref5, ref6, tmp;
	    from = from | 0;
	    to = to | 0;
	    tmp = array[from];
	    if (from < to) {
	      for (i = p = ref3 = from, ref4 = to - 1; p <= ref4; i = p += 1) {
	        array[i] = array[i + 1];
	      }
	    } else {
	      for (i = q = ref5 = from, ref6 = to + 1; q >= ref6; i = q += -1) {
	        array[i] = array[i - 1];
	      }
	    }
	    array[to] = tmp;
	    return array;
	  };

	  ArrayExtensions.moveArrayElement = moveArrayElement = function(array, from, to) {
	    from = modulo(from | 0, array.length);
	    to = modulo(to | 0, array.length);
	    if (Math.abs(from - to) > 300) {
	      _moveArrayElementLargeArray(array, from, to);
	    } else {
	      _moveArrayElementSmallArray(array, from, to);
	    }
	    return array;
	  };

	  ArrayExtensions.arrayWithElementMoved = arrayWithElementMoved = function(array, from, to) {
	    from = modulo(from | 0, array.length);
	    to = modulo(to | 0, array.length);
	    if (from === to) {
	      return array;
	    }
	    array = array.slice();
	    return moveArrayElement(array, from, to);
	  };

	  ArrayExtensions.arrayWithElementValueMoved = function(array, value, to) {
	    var from;
	    from = array.indexOf(value);
	    if (from < 0) {
	      return array;
	    }
	    return arrayWithElementMoved(array, from, to);
	  };

	  ArrayExtensions.arrayWithElementReplaced = function(array, value, index) {
	    array = array.slice();
	    array[index] = value;
	    return array;
	  };

	  ArrayExtensions.stableSort = function(array, compare) {
	    var a, b, i, length, notSorted, p, ref3;
	    compare || (compare = function(a, b) {
	      return a - b;
	    });
	    notSorted = true;
	    length = array.length;
	    while (notSorted) {
	      notSorted = false;
	      for (i = p = 1, ref3 = length; p < ref3; i = p += 1) {
	        if (compare(a = array[i - 1], b = array[i]) > 0) {
	          array[i - 1] = b;
	          array[i] = a;
	          notSorted = true;
	        }
	      }
	    }
	    return array;
	  };

	  ArrayExtensions.longestCommonSubsequence = longestCommonSubsequence = function(a, b) {
	    var c, diag, i, j, latch, lcs, left, m, n, p, q, r, ref3, ref4, ref5, row, s;
	    lcs = [];
	    row = [];
	    c = [];
	    if (m < n) {
	      s = a;
	      a = b;
	      b = s;
	    }
	    m = a.length;
	    n = b.length;
	    for (j = p = 0, ref3 = n; p < ref3; j = p += 1) {
	      row[j] = 0;
	    }
	    for (i = q = 0, ref4 = m; q < ref4; i = q += 1) {
	      c[i] = row = row.slice();
	      diag = 0;
	      for (j = r = 0, ref5 = n - 1; r <= ref5; j = r += 1) {
	        latch = row[j];
	        if (a[i] === b[j]) {
	          row[j] = diag + 1;
	        } else {
	          left = row[j - 1] || 0;
	          if (left > row[j]) {
	            row[j] = left;
	          }
	        }
	        diag = latch;
	      }
	    }
	    i--;
	    j--;
	    while (i > -1 && j > -1) {
	      switch (c[i][j]) {
	        case i && c[i - 1][j]:
	          i--;
	          continue;
	        case j && c[i][j - 1]:
	          j--;
	          break;
	        default:
	          j--;
	          lcs.unshift(a[i]);
	          i--;
	          continue;
	      }
	    }
	    return lcs;
	  };

	  ArrayExtensions.minimumOrderedOverlappingMerge = function(a, b) {
	    var ai, bj, c, ck, i, j, k, l, m, n, o, out;
	    c = longestCommonSubsequence(a, b);
	    m = a.length;
	    n = b.length;
	    o = c.length;
	    out = new Array(n);
	    i = 0;
	    j = 0;
	    k = 0;
	    l = 0;
	    while (i < m && j < n && k < o) {
	      ai = a[i];
	      bj = b[j];
	      ck = c[k];
	      if (ai === ck && bj === ck) {
	        i++;
	        j++;
	        k++;
	        out[l++] = ai;
	      } else if (ai !== ck) {
	        i++;
	        if (indexOf.call(b, ai) < 0) {
	          out[l++] = ai;
	        }
	      } else {
	        j++;
	        out[l++] = bj;
	      }
	    }
	    while (i < m) {
	      ai = a[i++];
	      if (indexOf.call(b, ai) < 0) {
	        out[l++] = ai;
	      }
	    }
	    while (j < n) {
	      out[l++] = b[j++];
	    }
	    return out;
	  };

	  ArrayExtensions.wordsArray = w = function() {
	    var arg, len1, out, p;
	    out = [];
	    for (p = 0, len1 = arguments.length; p < len1; p++) {
	      arg = arguments[p];
	      if (isString(arg) && !arg.match(exactlyOneWordRegex)) {
	        out = out.concat(arg.match(wordsRegex));
	      } else {
	        out.push(arg);
	      }
	    }
	    return out;
	  };

	  ArrayExtensions.wordArray = ArrayExtensions.wordsArray;

	  ArrayExtensions.w = ArrayExtensions.wordsArray;

	  ArrayExtensions.a = a = function() {
	    var arg, len1, out, p;
	    out = [];
	    for (p = 0, len1 = arguments.length; p < len1; p++) {
	      arg = arguments[p];
	      out.push(arg);
	    }
	    return out;
	  };

	  return ArrayExtensions;

	})();


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var Foundation, Math, Regexp, abs, ceil, float32Precision, float64Precision, floor, inverseFloat64Precision, inverstFlaot32Precision, max, min, numberRegexp, pow, random, ref, round;

	Foundation = __webpack_require__(30);

	Regexp = __webpack_require__(37);

	numberRegexp = Regexp.numberRegexp;

	float64Precision = 0.0000000001;

	float32Precision = 0.0000001;

	inverseFloat64Precision = 1 / float64Precision;

	inverstFlaot32Precision = 1 / float32Precision;

	ref = self.Math, abs = ref.abs, min = ref.min, max = ref.max, ceil = ref.ceil, floor = ref.floor, round = ref.round, random = ref.random, pow = ref.pow;

	module.exports = Math = (function() {
	  var bound;

	  function Math() {}

	  Math.nearInfinity = pow(10, 100);

	  Math.nearInfinityResult = pow(10, 50);

	  Math.float32Precision = float32Precision;

	  Math.float64Precision = float64Precision;

	  Math.modulo = function(a, b) {
	    var r;
	    r = a % b;
	    if (r < 0) {
	      return r + b;
	    } else {
	      return r;
	    }
	  };

	  Math.stringToNumberArray = function(string) {
	    var a, i, j, len, match, v;
	    a = string.split(",");
	    for (i = j = 0, len = a.length; j < len; i = ++j) {
	      v = a[i];
	      match = v.match(numberRegexp);
	      a[i] = match != null ? match[0] - 0 : 0;
	    }
	    return a;
	  };

	  Math.minMagnitude = function(a, magnitude) {
	    if (a < 0) {
	      return min(a, -magnitude);
	    } else {
	      return max(a, magnitude);
	    }
	  };

	  Math.maxMagnitude = function(a, magnitude) {
	    return bound(-magnitude, a, magnitude);
	  };

	  Math.maxChange = function(newValue, oldValue, maxChangeV) {
	    return bound(oldValue - maxChangeV, newValue, oldValue + maxChangeV);
	  };

	  Math.bound = bound = function(a, b, c) {
	    if (isNaN(b)) {
	      return a;
	    }
	    if (b < a) {
	      return a;
	    } else if (b > c) {
	      return c;
	    } else {
	      return b;
	    }
	  };

	  Math.absGt = function(a, b) {
	    return abs(a) > abs(b);
	  };

	  Math.absLt = function(a, b) {
	    return abs(a) < abs(b);
	  };

	  Math.absGte = function(a, b) {
	    return abs(a) >= abs(b);
	  };

	  Math.absLte = function(a, b) {
	    return abs(a) <= abs(b);
	  };

	  Math.abs = abs;

	  Math.min = min;

	  Math.max = max;

	  Math.round = round;

	  Math.ceil = function(v, m) {
	    if (m == null) {
	      m = 1;
	    }
	    return ceil(v / m) * m;
	  };

	  Math.floor = function(v, m) {
	    if (m == null) {
	      m = 1;
	    }
	    return floor(v / m) * m;
	  };

	  Math.round = function(v, m) {
	    if (m == null) {
	      m = 1;
	    }
	    return round(v / m) * m;
	  };

	  Math.simplifyNum = function(num) {
	    return round(num * inverseFloat64Precision) * float64Precision;
	  };

	  Math.floatEq = function(n1, n2) {
	    return n1 === n2 || float64Precision > abs(n1 - n2);
	  };

	  Math.float32Eq = function(n1, n2) {
	    return n1 === n2 || float32Precision > abs(n1 - n2);
	  };

	  Math.floatEq0 = function(n) {
	    return n === 0 || float64Precision > abs(n);
	  };

	  Math.float32Eq0 = function(n) {
	    return n === 0 || float32Precision > abs(n);
	  };

	  Math.floatTrue0 = function(n) {
	    if (n === 0 || float64Precision > abs(n)) {
	      return 0;
	    } else {
	      return n;
	    }
	  };

	  Math.float32True0 = function(n) {
	    if (n === 0 || float32Precision > abs(n)) {
	      return 0;
	    } else {
	      return n;
	    }
	  };

	  Math.random = random;

	  Math.intRand = function(max) {
	    return random() * max | 0;
	  };

	  Math.iPart = function(v) {
	    return v - (v % 1);
	  };

	  Math.fPart = function(v) {
	    return v % 1;
	  };

	  Math.commaize = function(x) {
	    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
	  };

	  Math.cyclingSequenceFunction = function(sequence) {
	    var sequencePos;
	    sequencePos = sequence.length;
	    return function() {
	      sequencePos++;
	      if (sequencePos >= sequence.length) {
	        sequencePos = 0;
	      }
	      return sequence[sequencePos];
	    };
	  };

	  return Math;

	})();


/***/ },
/* 37 */
/***/ function(module, exports) {

	var Regexp;

	module.exports = Regexp = (function() {
	  function Regexp() {}

	  Regexp.escapeRegExp = function(string) {
	    return string.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
	  };

	  Regexp.findUrlProtocolRegexp = /([\w-]+)(:\/\/)/;

	  Regexp.findDomainRegexp = /localhost|[\w]+(?:-[\w]+)*(?:\.[\w]+(?:-[\w]+)*)*(?:\.[a-z]{2,20})/;

	  Regexp.urlQueryParamsRegexp = /(?:[-+=&*._\w]|%[a-f\d]{2})+/i;

	  Regexp.findUrlPathRegexp = /(?:\/~?(?:[-+*._\w]|%[a-f\d]{2})*)*/;

	  Regexp.findUrlPortRegexp = /(\:)(\d+)/;

	  Regexp.findEmailRegexp = RegExp("([_\\w-]+(?:\\.[_\\w]+)*)@(" + Regexp.findDomainRegexp.source + ")", "i");

	  Regexp.emailRegexp = RegExp("^" + Regexp.findEmailRegexp.source + "$", "i");

	  Regexp.numberRegexp = /([-]?\.[0-9]+)|([-]?[0-9]+(\.[0-9]+)?)/;

	  Regexp.urlProtocolRegexp = RegExp("^" + Regexp.findUrlProtocolRegexp.source + "$", "i");

	  Regexp.domainRegexp = RegExp("^" + Regexp.findDomainRegexp.source + "$", "i");

	  Regexp.urlPathRegexp = RegExp("^" + Regexp.findUrlPathRegexp.source + "$", "i");

	  Regexp.urlQueryRegexp = RegExp("^" + Regexp.urlQueryParamsRegexp.source + "$", "i");

	  Regexp.isoDateRegexp = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24\:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;

	  Regexp.hex16ColorRegex = /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?$/i;

	  Regexp.hex256ColorRegex = /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?$/i;

	  Regexp.rgbColorRegex = /rgb *\( *(\d+%?) *, *(\d+%?) *, *(\d+%?) *\)/;

	  Regexp.rgbaColorRegex = /rgba *\( *(\d+%?) *, *(\d+%?) *, *(\d+%?) *, *(\d*\.?\d*)\)/;

	  Regexp.colorRegex = new RegExp("(" + Regexp.hex16ColorRegex.source + ")|(" + Regexp.hex256ColorRegex.source + ")|(" + Regexp.rgbColorRegex.source + ")|(" + Regexp.rgbaColorRegex.source + ")");

	  Regexp.wordsRegex = /[^\s]+/g;

	  Regexp.exactlyOneWordRegex = /^[^\s]+$/;


	  /*
	  match OUTPUT: [url, protocol, '://', domain, ':', port, path, '?', query]
	  
	  USAGE:
	    [__, protocol, __, domain, __, port, path, __, query] = str.match findUrlRegexp
	  
	  DESIGN NOTE:
	    The reason why I included the fixed strings ('://', ':' and '?') was so that
	    you can take the matchResult, alter individual elements and create a value url easily by:
	  
	      matchResult.slice(1).join ''
	   */

	  Regexp.findUrlRegexp = RegExp("(?:" + Regexp.findUrlProtocolRegexp.source + ")(" + Regexp.findDomainRegexp.source + ")(?:" + Regexp.findUrlPortRegexp.source + ")?(" + Regexp.findUrlPathRegexp.source + ")?(?:(\\?)(" + Regexp.urlQueryParamsRegexp.source + ")?)?", "i");

	  Regexp.findSourceReferenceUrlRegexp = RegExp("(" + Regexp.findUrlProtocolRegexp.source + ")(" + Regexp.findDomainRegexp.source + ")?(?:" + Regexp.findUrlPortRegexp.source + ")?(" + Regexp.findUrlPathRegexp.source + ")?(?:(\\?)(" + Regexp.urlQueryParamsRegexp.source + ")?)?(?:\\:(\\d+))?(?:\\:(\\d+))?", "i");

	  Regexp.urlRegexp = RegExp("^" + Regexp.findUrlRegexp.source + "$", "i");

	  return Regexp;

	})();


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var AsyncExtensions, Promise;

	Promise = __webpack_require__(32);

	module.exports = AsyncExtensions = (function() {
	  var timeout;

	  function AsyncExtensions() {}

	  AsyncExtensions.timeout = timeout = function(ms, f) {
	    return new Promise(function(resolve) {
	      return setTimeout(function() {
	        if (typeof f === "function") {
	          f();
	        }
	        return resolve();
	      }, ms);
	    });
	  };

	  AsyncExtensions.requestAnimationFrame = self.requestAnimationFrame || self.webkitRequestAnimationFrame || self.mozRequestAnimationFrame || self.oRequestAnimationFrame || self.msRequestAnimationFrame || function(f) {
	    return setTimeout(f, 1000 / 60);
	  };

	  AsyncExtensions.nextTick = function(f) {
	    return Promise.resolve().then(f);
	  };

	  AsyncExtensions.throwErrorOutOfStack = function(e) {
	    return timeout(0, function() {
	      throw e;
	    });
	  };

	  AsyncExtensions.evalAndThrowErrorsOutOfStack = function(f) {
	    var e;
	    try {
	      return f();
	    } catch (error) {
	      e = error;
	      Neptune.Art.Foundation.log.error("evalAndThrowErrorsOutOfStack", e);
	      return AsyncExtensions.throwErrorOutOfStack(e);
	    }
	  };

	  return AsyncExtensions;

	})();


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var Eq, floatTrue0, isNumber, isString, min, objectKeyCount, ref, remove,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	remove = __webpack_require__(35).remove;

	objectKeyCount = __webpack_require__(40).objectKeyCount;

	floatTrue0 = __webpack_require__(36).floatTrue0;

	ref = __webpack_require__(34), isString = ref.isString, isNumber = ref.isNumber;

	min = Math.min;

	module.exports = Eq = (function() {
	  var plainObjectsDeepDiff, plainObjectsDeepEq;

	  function Eq() {}


	  /*
	  IN: see @compare
	  OUT:
	    true: if a and b are structurally equal
	    false: otherwise
	   */

	  Eq.eq = function(a, b) {
	    return 0 === Eq.compare(a, b, true);
	  };

	  Eq.neq = function(a, b) {
	    return 0 !== Eq.compare(a, b, true);
	  };

	  Eq.fastEq = function(a, b) {
	    return 0 === Eq.compare(a, b, false);
	  };

	  Eq.fastNeq = function(a, b) {
	    return 0 !== Eq.compare(a, b, false);
	  };

	  Eq._compareArray = function(a, b, recursionBlockArray) {
	    var aLength, av, bLength, bv, i, j, ref1, val;
	    aLength = a.length;
	    bLength = b.length;
	    for (i = j = 0, ref1 = Math.min(aLength, bLength); j < ref1; i = j += 1) {
	      av = a[i];
	      bv = b[i];
	      if (0 !== (val = Eq._compare(av, bv, recursionBlockArray))) {
	        return val;
	      }
	    }
	    return aLength - bLength;
	  };

	  Eq._compareObject = function(a, b, recursionBlockArray) {
	    var aLength, av, bv, compared, k, val;
	    aLength = 0;
	    compared = 0;
	    for (k in a) {
	      av = a[k];
	      aLength++;
	      av = a[k];
	      bv = b[k];
	      if (bv !== void 0 || b.hasOwnProperty(k)) {
	        compared++;
	        if (0 !== (val = Eq._compare(av, bv, recursionBlockArray))) {
	          return val;
	        }
	      }
	    }
	    if (aLength === compared && compared === objectKeyCount(b)) {
	      return 0;
	    } else {
	      return 0/0;
	    }
	  };


	  /*
	  compare is recursive. However, it only recurses for 'plain' objects and arrays.
	  
	  If you want to compare custom objects deeply, you must add an .eq or .compare function to your custom objects.
	    signature: a.eq b, recursionBlockArray => truthy if a equals b
	    signature: a.compare b, recursionBlockArray => NaN / <0 / 0 / >0 for incomparable / a<b / a==b / a>b respectively
	    IN:
	      a: => this/@
	      b: compared with a
	      recursionBlockArray: an array of objects already on the stack being tested, pass this to
	    It is an array of every object recursively currently being tested - don't test an object in this array
	    recursionBlockArray can be altered, but should be returned in its original state. It may be null.
	  
	  IN:
	    a and b: compare a and b
	    recursionBlockEnabled:
	      truthy: recursive structures will be handled correctly
	      falsey: (default) faster, but recursive structures result in infinite recursion
	  OUT:
	    NaN:
	      a and b are different types
	      a and b are otherwise not comparable
	  
	    <0: a < b
	    0:  a == b
	    >0: a > b
	   */

	  Eq.compare = function(a, b, recursionBlockEnabled) {
	    return Eq._compare(a, b, recursionBlockEnabled && []);
	  };

	  Eq._compare = function(a, b, recursionBlockArray) {
	    var _constructor;
	    if (a === b) {
	      return 0;
	    }
	    if ((a != null) && (b != null) && a.constructor === (_constructor = b.constructor)) {
	      if (isString(a)) {
	        return a.localeCompare(b);
	      }
	      if (isNumber(a)) {
	        return floatTrue0(a - b);
	      }
	      if (recursionBlockArray) {
	        if (indexOf.call(recursionBlockArray, a) >= 0 || indexOf.call(recursionBlockArray, b) >= 0) {
	          return 0;
	        }
	        recursionBlockArray.push(a);
	        recursionBlockArray.push(b);
	      }
	      if (a.compare) {
	        return a.compare(b, recursionBlockArray);
	      }
	      if (_constructor === Array) {
	        return Eq._compareArray(a, b, recursionBlockArray);
	      }
	      if (_constructor === Object) {
	        return Eq._compareObject(a, b, recursionBlockArray);
	      }
	      if (a.eq && a.eq(b, recursionBlockArray)) {
	        return 0;
	      }
	      if (recursionBlockArray) {
	        remove(recursionBlockArray, recursionBlockArray.length - 2, 2);
	      }
	    }
	    return 0/0;
	  };

	  Eq.plainObjectsDeepEqArray = function(a, b) {
	    var av, i, j, len1;
	    if (a.length !== b.length) {
	      return false;
	    }
	    for (i = j = 0, len1 = a.length; j < len1; i = ++j) {
	      av = a[i];
	      if (!Eq.plainObjectsDeepEq(av, b[i])) {
	        return false;
	      }
	    }
	    return true;
	  };

	  Eq.plainObjectsDeepEqObject = function(a, b) {
	    var aLength, av, bv, k;
	    aLength = 0;
	    for (k in a) {
	      av = a[k];
	      aLength++;
	      bv = b[k];
	      if (!((bv !== void 0 || b.hasOwnProperty(k)) && Eq.plainObjectsDeepEq(av, bv))) {
	        return false;
	      }
	    }
	    return aLength === objectKeyCount(b);
	  };

	  Eq.plainObjectsDeepEq = plainObjectsDeepEq = function(a, b) {
	    var _constructor;
	    if (a === b) {
	      return true;
	    } else if (a && b && a.constructor === (_constructor = b.constructor)) {
	      if (a.eq) {
	        return a.eq(b);
	      } else if (_constructor === Array) {
	        return Eq.plainObjectsDeepEqArray(a, b);
	      } else if (_constructor === Object) {
	        return Eq.plainObjectsDeepEqObject(a, b);
	      } else {
	        return false;
	      }
	    } else {
	      return false;
	    }
	  };

	  Eq.propsEq = plainObjectsDeepEq;

	  Eq.plainObjectsDeepDiffArray = function(before, after) {
	    var diff, i, j, l, len, m, ref1, ref2, ref3, ref4, ref5, res;
	    res = null;
	    len = min(before.length, after.length);
	    for (i = j = 0, ref1 = len; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
	      if (!(diff = plainObjectsDeepDiff(before[i], after[i]))) {
	        continue;
	      }
	      res || (res = {});
	      res[i] = diff;
	    }
	    if (len < before.length) {
	      for (i = l = ref2 = len, ref3 = before.length; ref2 <= ref3 ? l < ref3 : l > ref3; i = ref2 <= ref3 ? ++l : --l) {
	        res || (res = {});
	        res[i] = {
	          removed: before[i]
	        };
	      }
	    }
	    if (len < after.length) {
	      for (i = m = ref4 = len, ref5 = after.length; ref4 <= ref5 ? m < ref5 : m > ref5; i = ref4 <= ref5 ? ++m : --m) {
	        res || (res = {});
	        res[i] = {
	          added: after[i]
	        };
	      }
	    }
	    return res;
	  };

	  Eq.plainObjectsDeepDiffObject = function(before, after) {
	    var afterV, beforeV, diff, k, res;
	    res = null;
	    for (k in before) {
	      beforeV = before[k];
	      if (after.hasOwnProperty(k)) {
	        if (diff = plainObjectsDeepDiff(beforeV, after[k])) {
	          res || (res = {});
	          res[k] = diff;
	        }
	      } else {
	        res || (res = {});
	        res[k] = {
	          removed: beforeV
	        };
	      }
	    }
	    for (k in after) {
	      afterV = after[k];
	      if (!(!before.hasOwnProperty(k))) {
	        continue;
	      }
	      res || (res = {});
	      res[k] = {
	        added: afterV
	      };
	    }
	    return res;
	  };

	  Eq.plainObjectsDeepDiff = plainObjectsDeepDiff = function(before, after) {
	    var _constructor;
	    if (before === after) {
	      return null;
	    } else if (before && after && before.constructor === (_constructor = after.constructor)) {
	      if (before.eq) {
	        if (before.eq(after)) {
	          return null;
	        } else {
	          return {
	            before: before,
	            after: after
	          };
	        }
	      } else if (_constructor === Array) {
	        return Eq.plainObjectsDeepDiffArray(before, after);
	      } else if (_constructor === Object) {
	        return Eq.plainObjectsDeepDiffObject(before, after);
	      } else {
	        return {
	          before: before,
	          after: after
	        };
	      }
	    } else {
	      return {
	        before: before,
	        after: after
	      };
	    }
	  };

	  Eq.diff = plainObjectsDeepDiff;

	  Eq.shallowEq = function(a, b) {
	    return a === b || (a && b && a.eq && a.eq(b));
	  };

	  return Eq;

	})();


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var Hash, compactFlatten, deepArrayEach, isArrayOrArguments, isFunction, isPlainArray, isPlainObject, mergeInto, ref, ref1,
	  slice = [].slice,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	ref = Neptune.NeptuneLib, compactFlatten = ref.compactFlatten, deepArrayEach = ref.deepArrayEach, isArrayOrArguments = ref.isArrayOrArguments, mergeInto = ref.mergeInto;

	ref1 = __webpack_require__(34), isPlainObject = ref1.isPlainObject, isFunction = ref1.isFunction, isPlainArray = ref1.isPlainArray;

	module.exports = Hash = (function() {
	  var inject, newObjectFromEach, objectKeyCount, toObjectInternal;

	  function Hash() {}

	  Hash.countKeys = function(o) {
	    return Object.keys(o).length;
	  };

	  Hash.objectKeyCount = objectKeyCount = function(o) {
	    var count, k, v;
	    count = 0;
	    for (k in o) {
	      v = o[k];
	      count++;
	    }
	    return count;
	  };

	  Hash.objectLength = objectKeyCount;


	  /*
	  NOTE:
	    null and undefined keys are NOT SUPPORTED
	  
	    They should be converted to strings, first,
	    which is what they would become anyway.
	  
	  IN: 0 or more arguments
	    out = {}
	    list = arguments
	  
	    for element in list
	      objects: merge into out
	      arrays or argument lists: recurse using element as the list
	      null or undefined: skip
	      else out[element] = next element (or undefined if none)
	  
	  OUT: plain object
	   */

	  toObjectInternal = function(list, out) {
	    var element, i, key, len;
	    key = null;
	    for (i = 0, len = list.length; i < len; i++) {
	      element = list[i];
	      if (key) {
	        out[key] = element;
	        key = null;
	      } else if (isPlainObject(element)) {
	        mergeInto(out, element);
	      } else if (isArrayOrArguments(element)) {
	        toObjectInternal(element, out);
	      } else if (element != null) {
	        key = element;
	      }
	    }
	    if (key) {
	      return out[key] = void 0;
	    }
	  };

	  Hash.toObject = function() {
	    var out;
	    console.error("toObject is DEPRICATED. Use toPlainObjects.");
	    out = {};
	    toObjectInternal(arguments, out);
	    return out;
	  };


	  /*
	  IN:
	    inputArray: any array
	    transformFunction: (element) -> [key, value]
	      default: transforms an array of the form: [[key1, value1], [key2, value2], etc...]
	   */

	  Hash.arrayToMap = function(inputArray, transformFunction) {
	    var element, i, key, len, outputMap, ref2, value;
	    if (transformFunction == null) {
	      transformFunction = function(element) {
	        return element;
	      };
	    }
	    outputMap = {};
	    for (i = 0, len = inputArray.length; i < len; i++) {
	      element = inputArray[i];
	      ref2 = transformFunction(element), key = ref2[0], value = ref2[1];
	      outputMap[key] = value;
	    }
	    return outputMap;
	  };


	  /*
	  IN:
	    input: array or object
	    memo: [optional] initial value; if not set, the first element is used, if no elements, null is used and returned
	    block: (memo, value) -> newMemo OR
	    block: (memo, key, value) -> newMemo
	      key is the index for arrays
	  
	      Why value or key, value? Mostly consistent with CoffeeScripts:
	        for...in and for...of signatures
	      Different from CoffeeScript?
	        for arrays, if block has two arguments, the signature is the SAME as
	        objects where indexes in arrays are equivelent to keys in objects: (memo, index, value) ->
	      Why different from CoffeeScript?
	        So two-input blocks work the same regardless of if an array or object is input.
	   */

	  Hash.inject = inject = function(input, a, b) {
	    var block, i, k, len, log, memo, memoSet, twoInputBlock, v;
	    log = Neptune.Art.Foundation.log;
	    block = arguments.length === 2 ? (memoSet = false, memo = null, a) : (memo = a, memoSet = true, b);
	    twoInputBlock = block.length >= 3;
	    if (isPlainObject(input)) {
	      for (k in input) {
	        v = input[k];
	        if (!memoSet) {
	          memo = v;
	          memoSet = true;
	        } else {
	          memo = twoInputBlock ? block(memo, k, v) : block(memo, v);
	        }
	      }
	    } else {
	      for (k = i = 0, len = input.length; i < len; k = ++i) {
	        v = input[k];
	        if (!memoSet) {
	          memo = v;
	          memoSet = true;
	        } else {
	          memo = twoInputBlock ? block(memo, k, v) : block(memo, v);
	        }
	      }
	    }
	    return memo;
	  };


	  /*
	  IN:
	    input: array or object
	    block: (map, k, v) -> OR
	    block: (k, v) -> OR
	    block: (v) -> newV
	      for arrays, k is the index
	   */

	  Hash.newObjectFromEach = newObjectFromEach = function(input, block) {
	    if (block == null) {
	      block = function(map, k, v) {
	        return map[k] = v;
	      };
	    }
	    return inject(input, {}, (function() {
	      if (isPlainArray(input)) {
	        switch (block.length) {
	          case 0:
	          case 1:
	            return function(memo, k, v) {
	              memo[v] = block(v);
	              return memo;
	            };
	          case 2:
	            return function(memo, k, v) {
	              memo[v] = block(k, v);
	              return memo;
	            };
	          case 3:
	            return function(memo, k, v) {
	              block(memo, k, v);
	              return memo;
	            };
	          default:
	            throw new Error("expecting block-function with 0, 1, 2 or 3 arguments");
	        }
	      } else {
	        switch (block.length) {
	          case 0:
	          case 1:
	            return function(memo, k, v) {
	              memo[k] = block(v);
	              return memo;
	            };
	          case 2:
	            return function(memo, k, v) {
	              memo[k] = block(k, v);
	              return memo;
	            };
	          case 3:
	            return function(memo, k, v) {
	              block(memo, k, v);
	              return memo;
	            };
	          default:
	            throw new Error("expecting block-function with 0, 1, 2 or 3 arguments");
	        }
	      }
	    })());
	  };

	  Hash.newMapFromEach = newObjectFromEach;


	  /*
	  IN:
	    obj: the object to select fields from
	  
	    2nd argument can be:
	      selectFunction: (value, key) -> true / false
	  
	    OR obj can be followed by any number of strings or arrays in any nesting, possibly with null fields
	   */

	  Hash.select = function(obj, a) {
	    var i, k, len, prop, properties, result, v;
	    if (!obj) {
	      return {};
	    }
	    result = {};
	    if (isFunction(a)) {
	      if (a.length === 1) {
	        for (k in obj) {
	          v = obj[k];
	          if (a(v)) {
	            result[k] = v;
	          }
	        }
	      } else {
	        for (k in obj) {
	          v = obj[k];
	          if (a(k, v)) {
	            result[k] = v;
	          }
	        }
	      }
	    } else {
	      properties = compactFlatten(Array.prototype.slice.call(arguments, 1));
	      for (i = 0, len = properties.length; i < len; i++) {
	        prop = properties[i];
	        if (v = obj[prop] || obj.hasOwnProperty(prop)) {
	          result[prop] = v;
	        }
	      }
	    }
	    return result;
	  };

	  Hash.selectAll = function() {
	    var i, len, obj, prop, properties, ref2, result;
	    obj = arguments[0], properties = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    if (!obj) {
	      return {};
	    }
	    result = {};
	    ref2 = compactFlatten(properties);
	    for (i = 0, len = ref2.length; i < len; i++) {
	      prop = ref2[i];
	      result[prop] = obj[prop];
	    }
	    return result;
	  };

	  Hash.objectWithout = function() {
	    var anythingToDo, i, len, obj, prop, properties, result, v;
	    obj = arguments[0], properties = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    if (properties.length === 1 && !(typeof properties[0] === "string")) {
	      properties = properties[0];
	    }
	    anythingToDo = false;
	    for (i = 0, len = properties.length; i < len; i++) {
	      prop = properties[i];
	      if (obj.hasOwnProperty(prop)) {
	        anythingToDo = true;
	        break;
	      }
	    }
	    if (anythingToDo) {
	      result = {};
	      for (prop in obj) {
	        v = obj[prop];
	        if (indexOf.call(properties, prop) < 0) {
	          result[prop] = v;
	        }
	      }
	      return result;
	    } else {
	      return obj;
	    }
	  };

	  return Hash;

	})();


/***/ },
/* 41 */
/***/ function(module, exports) {

	var Function;

	module.exports = Function = (function() {
	  function Function() {}

	  Function.fastBind = function(fn, _this) {
	    switch (fn.length) {
	      case 0:
	        return function() {
	          return fn.call(_this);
	        };
	      case 1:
	        return function(a) {
	          return fn.call(_this, a);
	        };
	      case 2:
	        return function(a, b) {
	          return fn.call(_this, a, b);
	        };
	      case 3:
	        return function(a, b, c) {
	          return fn.call(_this, a, b, c);
	        };
	      case 4:
	        return function(a, b, c, d) {
	          return fn.call(_this, a, b, c, d);
	        };
	      case 5:
	        return function(a, b, c, d, e) {
	          return fn.call(_this, a, b, c, d, e);
	        };
	      case 6:
	        return function(a, b, c, d, e, f) {
	          return fn.call(_this, a, b, c, d, e, f);
	        };
	      case 7:
	        return function(a, b, c, d, e, f, g) {
	          return fn.call(_this, a, b, c, d, e, f, g);
	        };
	      case 8:
	        return function(a, b, c, d, e, f, g, h) {
	          return fn.call(_this, a, b, c, d, e, f, g, h);
	        };
	      case 9:
	        return function(a, b, c, d, e, f, g, h, i) {
	          return fn.call(_this, a, b, c, d, e, f, g, h, i);
	        };
	      case 10:
	        return function(a, b, c, d, e, f, g, h, i, j) {
	          return fn.call(_this, a, b, c, d, e, f, g, h, i, j);
	        };
	      default:
	        return function() {
	          return fn.apply(_this, arguments);
	        };
	    }
	  };

	  return Function;

	})();


	/*
	TODO:

	The above options are not hot-reload compatible. However, this alternative would be:

	  name = fn.name
	  -> _this[name].apply _this, arguments

	I need to perf-test this. Or, I need to finally start using a global "debug" mode that could use this
	in debug mode and the faster(?), non hot-reload options in production mode.
	 */


/***/ },
/* 42 */
/***/ function(module, exports) {

	var ObjectDiff;

	module.exports = ObjectDiff = (function() {
	  var defaultEq;

	  function ObjectDiff() {}

	  defaultEq = function(a, b) {
	    return a === b;
	  };


	  /*
	  SBD this has been thouroughly benchmarked on Safari and Chrome as of 2015-11-06
	  This is as fast as I could make it.
	  
	  IN:
	    newObj:   the changed-to object   (must be set)
	    oldObj:   the changed-from object (default: {})
	    added:    (key, newValue) -> null
	              called for each key in newObj that was not in oldObj
	    removed:  (key, oldValue) -> null
	              called for each key in oldObj that is not in newObj
	    changed:  (key, newValue, oldValue) -> null
	              called for each key in both where the value changed
	    noChange: (key, value) -> null
	              called for each key in both where the value stayed the same
	    eq:       (a, b) -> true if a is equal to b
	              DEFAULT: use javascript ===
	              provided for custom concepts of equality
	    oldObjKeyCount: null or a the number of keys in oldObj
	      This last field provides an opportunity for further performance improvement.
	      If you have previously computed the number of keys in oldObj, pass it in.
	      Counting the number of keys in an object can be slow. If we know the number
	      of keys this routine can be more efficient.
	  
	      NOTE that this function returns the key-count of the new object. That way if you
	      are calling objecfDiff several times over a sequence of object changes, can you keep
	      the results from this function, you already have the oldObjKeyCount for the next call.
	  
	  OUT: newObjKeyCount - number of keys in the new object
	   */

	  ObjectDiff.objectDiff = function(newObj, oldObj, added, removed, changed, noChange, eq, oldObjKeyCount) {
	    var k, newObjKeyCount, newValue, oldObjKeyCountIsAtLeast, oldValue;
	    if (eq == null) {
	      eq = defaultEq;
	    }
	    newObjKeyCount = 0;
	    if (!oldObj) {
	      for (k in newObj) {
	        newValue = newObj[k];
	        newObjKeyCount++;
	        added(k, newValue);
	      }
	      return newObjKeyCount;
	    }
	    oldObjKeyCountIsAtLeast = 0;
	    for (k in newObj) {
	      newValue = newObj[k];
	      newObjKeyCount++;
	      if (typeof (oldValue = oldObj[k]) !== "undefined" || oldObj.hasOwnProperty(k)) {
	        oldObjKeyCountIsAtLeast++;
	        if (!eq(newValue, oldValue)) {
	          changed(k, newValue, oldValue);
	        } else {
	          if (typeof noChange === "function") {
	            noChange(k, newValue);
	          }
	        }
	      } else {
	        added(k, newValue);
	      }
	    }
	    if (!(oldObjKeyCount != null) || oldObjKeyCountIsAtLeast !== oldObjKeyCount) {
	      for (k in oldObj) {
	        if (!(typeof newObj[k] !== "undefined" || newObj.hasOwnProperty(k))) {
	          removed(k, oldObj[k]);
	        }
	      }
	    }
	    return newObjKeyCount;
	  };

	  return ObjectDiff;

	})();


/***/ },
/* 43 */
/***/ function(module, exports) {

	var ParseUrl;

	module.exports = ParseUrl = (function() {
	  function ParseUrl() {}

	  ParseUrl.parseQuery = function(qs) {
	    var i, j, key, len, obj, pair, ref, ref1, val;
	    if (qs == null) {
	      qs = ((ref = self.location) != null ? ref.search : void 0) || "";
	    }
	    obj = {};
	    ref1 = qs.replace(/^\?/, '').split('&');
	    for (j = 0, len = ref1.length; j < len; j++) {
	      pair = ref1[j];
	      i = pair.indexOf('=');
	      key = pair.slice(0, i);
	      val = pair.slice(i + 1);
	      if (key.length > 0) {
	        obj[key] = decodeURIComponent(val);
	      }
	    }
	    return obj;
	  };

	  ParseUrl.parseUrl = function(url) {
	    var __, a, anchor, fileName, host, hostWithPort, m, password, path, pathName, port, protocol, query, username;
	    m = url.match(/(([A-Za-z]+):(\/\/)?)?(([\-;&=\+\$,\w]+)(:([\-;:&=\+\$,\w]+))?@)?([A-Za-z0-9\.\-]+)(:([0-9]+))?(\/[\+~%\/\.\w\-]*)?(\?([\-\+=&;%@\.\w,]*))?(\#([\.\!\/\\\w]*))?/);
	    if (!m) {
	      return void 0;
	    }
	    __ = m[0], __ = m[1], protocol = m[2], __ = m[3], __ = m[4], username = m[5], __ = m[6], password = m[7], host = m[8], __ = m[9], port = m[10], pathName = m[11], __ = m[12], query = m[13], __ = m[14], anchor = m[15];
	    if (pathName) {
	      a = pathName.split("/");
	      fileName = a[a.length - 1];
	      path = (a.slice(0, a.length - 1)).join("/");
	    }
	    host = host.toLowerCase();
	    hostWithPort = host;
	    if (port) {
	      hostWithPort += ":" + port;
	    }
	    return {
	      protocol: protocol,
	      username: username,
	      password: password,
	      hostWithPort: hostWithPort,
	      host: host,
	      port: port,
	      pathName: pathName,
	      path: path,
	      fileName: fileName,
	      query: query && ParseUrl.parseQuery(query),
	      anchor: anchor
	    };
	  };

	  return ParseUrl;

	})();


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var Promise, PromisedFileReader;

	Promise = __webpack_require__(32);

	module.exports = PromisedFileReader = (function() {
	  function PromisedFileReader() {}

	  PromisedFileReader.readFileAsDataUrl = function(file) {
	    return new Promise(function(resolve, reject) {
	      var reader;
	      reader = new FileReader;
	      reader.readAsDataURL(file);
	      reader.onload = (function(_this) {
	        return function(e) {
	          return resolve(e.target.result);
	        };
	      })(this);
	      return reader.onerror = (function(_this) {
	        return function(e) {
	          return reject(error);
	        };
	      })(this);
	    });
	  };

	  PromisedFileReader.readFileAsArrayBuffer = function(file) {
	    return new Promise(function(resolve, reject) {
	      var reader;
	      reader = new FileReader;
	      reader.readAsArrayBuffer(file);
	      reader.onload = (function(_this) {
	        return function(e) {
	          return resolve(e.target.result);
	        };
	      })(this);
	      return reader.onerror = (function(_this) {
	        return function(e) {
	          return reject(error);
	        };
	      })(this);
	    });
	  };

	  return PromisedFileReader;

	})();


/***/ },
/* 45 */
/***/ function(module, exports) {

	var Ruby,
	  hasProp = {}.hasOwnProperty;

	module.exports = Ruby = (function() {
	  var rubyTrue;

	  function Ruby() {}

	  Ruby.rubyTrue = rubyTrue = function(a) {
	    return a !== void 0 && a !== null && a !== false;
	  };

	  Ruby.rubyFalse = function(a) {
	    return a === void 0 || a === null || a === false;
	  };

	  Ruby.rubyOr = function(a, b) {
	    var i, len;
	    if (arguments.length === 2) {
	      if (rubyTrue(a)) {
	        return a;
	      } else {
	        return b;
	      }
	    } else {
	      for (i = 0, len = arguments.length; i < len; i++) {
	        a = arguments[i];
	        if (rubyTrue(a)) {
	          break;
	        }
	      }
	      return a;
	    }
	  };

	  Ruby.rubyAnd = function(a, b) {
	    var i, len;
	    if (arguments.length === 2) {
	      if (rubyTrue(a)) {
	        return b;
	      } else {
	        return a;
	      }
	    } else {
	      for (i = 0, len = arguments.length; i < len; i++) {
	        a = arguments[i];
	        if (!rubyTrue(a)) {
	          break;
	        }
	      }
	      return a;
	    }
	  };

	  Ruby.reopenInstanceProps = function(klass, instanceProps) {
	    var k, results, v;
	    results = [];
	    for (k in instanceProps) {
	      if (!hasProp.call(instanceProps, k)) continue;
	      v = instanceProps[k];
	      results.push(klass.prototype[k] = v);
	    }
	    return results;
	  };

	  Ruby.reopenClassProps = function(klass, classProps) {
	    var k, results, v;
	    results = [];
	    for (k in classProps) {
	      if (!hasProp.call(classProps, k)) continue;
	      v = classProps[k];
	      results.push(klass[k] = v);
	    }
	    return results;
	  };

	  return Ruby;

	})();


/***/ },
/* 46 */
/***/ function(module, exports) {

	
	/*
	This current iteration of clone relies on some singleton variables shared across all invocations of clone.
	This is fine as long as javascript stays single-threaded.
	It also introduces a little bit of uglyness initializing clonedMap necessitating the "top" variable.

	FUTURE
	A potentially better solution would be to create a new closer each time clone is called at the top-most level,
	but when recursing, pass in a new function bound to that closure which is different from the global clone function.

	populateClone would need to take an additional argument - the clone function to use for recursive cloning.
	 */
	var ShallowClone;

	module.exports = ShallowClone = (function() {
	  function ShallowClone() {}

	  ShallowClone.extendClone = function(obj) {
	    if (obj.constructor === Array) {
	      return obj.slice();
	    } else {
	      return Object.create(obj);
	    }
	  };

	  ShallowClone.shallowClone = function(obj) {
	    var k, ret, v;
	    if (!obj) {
	      return obj;
	    }
	    if (obj.constructor === Array) {
	      return obj.slice();
	    } else {
	      ret = {};
	      for (k in obj) {
	        v = obj[k];
	        ret[k] = v;
	      }
	      return ret;
	    }
	  };

	  return ShallowClone;

	})();


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var FoundationMath, StringExtensions, Types, compactFlatten, escapedDoubleQuoteRegex, floor, intRand, isArray, isNumber, isPlainObject, isString, wordsRegex;

	FoundationMath = __webpack_require__(36);

	Types = __webpack_require__(34);

	wordsRegex = __webpack_require__(37).wordsRegex;

	intRand = FoundationMath.intRand;

	isString = Types.isString, isNumber = Types.isNumber, isPlainObject = Types.isPlainObject, isArray = Types.isArray;

	compactFlatten = Neptune.NeptuneLib.compactFlatten;

	escapedDoubleQuoteRegex = /[\\]["]/g;

	floor = Math.floor;

	module.exports = StringExtensions = (function() {
	  var consistentJsonStringify, escapeDoubleQuoteJavascriptString, escapeJavascriptString, getPadding, pluralize, repeat, standardIndent;

	  function StringExtensions() {}


	  /*
	  IN: an array and optionally a string, in any order
	    joiner: the string
	    array-to-flatten-and-join: the array
	  
	  OUT:
	    compactFlatten(array).join joiner || ""
	  
	  NOTE: this uses Ruby's default value for joining - the empty array, not ',' which is JavaScripts
	   */

	  StringExtensions.compactFlattenJoin = function(a, b) {
	    var array, joiner;
	    array = null;
	    joiner = isString(a) ? (array = b, a) : (array = a, b || "");
	    return compactFlatten(array).join(joiner);
	  };

	  StringExtensions.randomString = function(length, chars) {
	    var charsLength, i, result;
	    if (length == null) {
	      length = 32;
	    }
	    if (chars == null) {
	      chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
	    }
	    result = '';
	    charsLength = chars.length;
	    return ((function() {
	      var j, ref, results;
	      results = [];
	      for (i = j = 0, ref = length; j < ref; i = j += 1) {
	        results.push(chars[intRand(charsLength)]);
	      }
	      return results;
	    })()).join('');
	  };

	  StringExtensions.pluralize = pluralize = function(a, b, pluralForm) {
	    if (typeof a === "number") {
	      return a + " " + (a === 1 ? b : pluralForm || pluralize(b));
	    } else {
	      return a + "s";
	    }
	  };

	  StringExtensions.replaceLast = function(str, find, replaceWith) {
	    var index;
	    index = str.lastIndexOf(find);
	    if (index >= 0) {
	      return str.substring(0, index) + replaceWith + str.substring(index + find.length);
	    } else {
	      return str.toString();
	    }
	  };

	  StringExtensions.getPadding = getPadding = function(length, padding) {
	    if (padding == null) {
	      padding = " ";
	    }
	    return Array(length).join(padding);
	  };

	  StringExtensions.pad = function(str, length, padding, alignRight) {
	    var exactPadding;
	    str = String(str);
	    if (str.length >= length) {
	      return str;
	    }
	    exactPadding = getPadding(Math.max(length - str.length + 1, 0), padding);
	    if (alignRight) {
	      return exactPadding + str;
	    } else {
	      return str + exactPadding;
	    }
	  };

	  StringExtensions.escapeDoubleQuoteJavascriptString = escapeDoubleQuoteJavascriptString = function(str) {
	    var s;
	    s = String(str).replace(/[\\"]/g, "\\$&").replace(/[\0\b\f\n\r\t\v\u2028\u2029]/g, function(x) {
	      switch (x) {
	        case '\0':
	          return "\\0";
	        case '\b':
	          return "\\b";
	        case '\f':
	          return "\\f";
	        case '\n':
	          return "\\n";
	        case '\r':
	          return "\\r";
	        case '\t':
	          return "\\t";
	        case '\v':
	          return "\\v";
	        case '\u2028':
	          return "\\u2028";
	        case '\u2029':
	          return "\\u2029";
	      }
	    });
	    return s = '"' + s + '"';
	  };


	  /*
	  SBD for a while I only had JSON.stringify here, but I hate seeing: "I said, \"hello.\""
	  when I could be seeing: 'I said, "hello."'
	  
	  Is this going to break anything? I figure if you really need "" only, just use stringify.
	   */

	  StringExtensions.escapeJavascriptString = escapeJavascriptString = function(str) {
	    var s;
	    s = JSON.stringify(str);
	    if (s.match(escapedDoubleQuoteRegex)) {
	      return "'" + (s.replace(escapedDoubleQuoteRegex, '"').replace(/'/g, "\\'").slice(1, -1)) + "'";
	    } else {
	      return s;
	    }
	  };

	  StringExtensions.allIndexes = function(str, regex) {
	    var indexes, lastIndex, result;
	    indexes = [];
	    if (!((regex instanceof RegExp) && regex.global)) {
	      throw new Error("regex must be a global RegExp");
	    }
	    regex.lastIndex = 0;
	    while (result = regex.exec(str)) {
	      indexes.push(result.index);
	      lastIndex = result;
	    }
	    return indexes;
	  };

	  StringExtensions.repeat = repeat = " ".repeat ? function(str, times) {
	    return str.repeat(times);
	  } : function(str, count) {
	    var result;
	    count === floor(count);
	    result = '';
	    if (count > 0 && str.length > 0) {
	      while (true) {
	        if ((count & 1) === 1) {
	          result += str;
	        }
	        count >>>= 1;
	        if (count === 0) {
	          break;
	        }
	        str += str;
	      }
	    }
	    return result;
	  };

	  StringExtensions.rightAlign = function(str, width) {
	    if (str.length >= width) {
	      return str;
	    } else {
	      return repeat(" ", width - str.length) + str;
	    }
	  };

	  StringExtensions.eachMatch = function(str, regex, f) {
	    var result;
	    regex.lastIndex = 0;
	    while (result = regex.exec(str)) {
	      f(result);
	    }
	    return null;
	  };

	  standardIndent = {
	    joiner: ', ',
	    openObject: '{',
	    openArray: '[',
	    closeObject: "}",
	    closeArray: "]"
	  };

	  StringExtensions.consistentJsonStringify = consistentJsonStringify = function(object, indent) {
	    var closeArray, closeObject, error, indentObject, joiner, k, lastTotalIndent, openArray, openObject, out, totalIndent, v;
	    return out = (function() {
	      var ref;
	      if (object === false || object === true || object === null || isNumber(object)) {
	        return "" + object;
	      } else if (isString(object)) {
	        return JSON.stringify(object);
	      } else {
	        indentObject = indent ? typeof indent === "string" ? {
	          joiner: ",\n" + indent,
	          openObject: "{\n" + indent,
	          openArray: "[\n" + indent,
	          closeObject: "\n}",
	          closeArray: "\n]",
	          totalIndent: indent,
	          indent: indent
	        } : {
	          totalIndent: totalIndent = indent.indent + (lastTotalIndent = indent.totalIndent),
	          joiner: ",\n" + totalIndent,
	          openObject: "{\n" + totalIndent,
	          openArray: "[\n" + totalIndent,
	          closeObject: "\n" + lastTotalIndent + "}",
	          closeArray: "\n" + lastTotalIndent + "]",
	          indent: indent.indent
	        } : void 0;
	        ref = indentObject || standardIndent, joiner = ref.joiner, openObject = ref.openObject, openArray = ref.openArray, closeObject = ref.closeObject, closeArray = ref.closeArray;
	        if (isPlainObject(object)) {
	          return openObject + ((function() {
	            var j, len, ref1, results;
	            ref1 = (Object.keys(object)).sort();
	            results = [];
	            for (j = 0, len = ref1.length; j < len; j++) {
	              k = ref1[j];
	              if (object[k] !== void 0) {
	                results.push(JSON.stringify(k) + ": " + consistentJsonStringify(object[k], indentObject));
	              }
	            }
	            return results;
	          })()).join(joiner) + closeObject;
	        } else if (isArray(object)) {
	          return openArray + ((function() {
	            var j, len, results;
	            results = [];
	            for (j = 0, len = object.length; j < len; j++) {
	              v = object[j];
	              results.push(consistentJsonStringify(v, indentObject));
	            }
	            return results;
	          })()).join(joiner) + closeArray;
	        } else {
	          Neptine.Art.Foundation.log.error(error = "invalid object type for Json. Expecting: null, false, true, number, string, plain-object or array", object);
	          throw new Error(error);
	        }
	      }
	    })();
	  };

	  StringExtensions.splitRuns = function(str) {
	    var ch, chCount, i, j, lastCh, ref, result;
	    if (str.length === 0) {
	      return [];
	    }
	    lastCh = str[0];
	    chCount = 1;
	    result = [];
	    for (i = j = 1, ref = str.length; j < ref; i = j += 1) {
	      ch = str[i];
	      if (ch === lastCh) {
	        chCount++;
	      } else {
	        result.push([lastCh, chCount]);
	        chCount = 1;
	      }
	      lastCh = ch;
	    }
	    result.push([lastCh, chCount]);
	    return result;
	  };

	  StringExtensions.eachRunAsCharCodes = function(str, f) {
	    var ch, chCount, i, j, lastCh, ref;
	    lastCh = str.charCodeAt(0);
	    chCount = 1;
	    for (i = j = 1, ref = str.length; j < ref; i = j += 1) {
	      ch = str.charCodeAt(i);
	      if (ch === lastCh) {
	        chCount++;
	      } else {
	        f(lastCh, chCount);
	        chCount = 1;
	      }
	      lastCh = ch;
	    }
	    f(lastCh, chCount);
	    return null;
	  };


	  /*
	  TODO: I think this can be generalized to cover most all ellipsies and word-wrap scenarios:
	    a) have an options object with options:
	      maxLength: number         # similar to current maxLength
	      minLength: number         # currently implied to be maxLength / 2, in additional customizable, it would also be optional
	      brokenWordEllipsis: "…"   # used when only part of a word is included
	      moreWordsEllipsis: "…"    # used when there are more words, but the last word is whole
	      wordLengthFunction: (string) -> string.length
	         * can be replaced with, say, the font pixel-width for a string
	         * in this way, this function can be used by text-layout
	         * minLength and maxLength would then be in pixels
	      breakWords: false         # currently, this is effectively true - will break the last word on line in most situations
	      breakOnlyWord: true       # even if breakWords is false, if this is the only word on the line and it doesn't fit, should we break it?
	                                 * should this even be an option?
	       * future:
	      wordBreakFunction: (word, maxLength) -> shorterWord
	         * given a word and the maximum length of that word, returns
	         * a word <= maxLength according to wordLengthFunction
	  
	    b) Use cases
	      - TextLayout - uses pixels for length rather than characters
	      - Art.Engine.Element 'flow' layout
	        - if the input was an array of "words" and
	        - wordLengthFunction returns the Element's width...
	        I think this works. We'd need a way to handle margins though. I think this works:
	          spaceLength: (leftWord, rightWord) -> 1
	      - Shortend user display names:
	        Options:
	          wordBreakFunction: (word, maxLength) -> word[0]
	          brokenWordEllipsis: "." or ""
	        Example Output:
	          "Shane Delamore", 10 > "Shane D." or
	          "Shane Delamore", 10 > "Shane D"
	        Or, just leave breakwords: false and get:
	          "Shane Delamore", 10 > "Shane"
	  
	    c) returns both the output string and the "string remaining" - everything not included
	    d) alternate input: an array of strings already broken up by words - the "remainging" return value would then also be an array of "words"
	      (this would be for efficiency when doing multi-line layout)
	  
	  Right now, it works as follows:
	  The output string is guaranteed to be:
	    <= maxLength
	    >= maxLength / 2 in almost all secenarios as long as inputString is >= maxLength / 2
	   */

	  StringExtensions.humanFriendlyShorten = function(inputString, maxLength) {
	    var j, len, minLength, part, string, stringParts;
	    if (!(maxLength > 0)) {
	      throw new error("maxLength must be > 0");
	    }
	    inputString = inputString.trim();
	    if (!(inputString.length > maxLength)) {
	      return inputString;
	    }
	    minLength = maxLength / 2;
	    stringParts = inputString.split(/\s+/);
	    string = "";
	    for (j = 0, len = stringParts.length; j < len; j++) {
	      part = stringParts[j];
	      if (string.length === 0) {
	        string = part;
	      } else if ((string.length < minLength) || string.length + part.length + 2 <= maxLength) {
	        string += " " + part;
	      } else {
	        break;
	      }
	    }
	    if (string.length > maxLength) {
	      string = string.slice(0, maxLength - 1).trim();
	    }
	    return string + "…";
	  };

	  StringExtensions.stripTrailingWhitespace = function(a) {
	    return a.split(/[ ]*\n/).join("\n").split(/[ ]*$/)[0].replace(/\n+$/, '');
	  };

	  return StringExtensions;

	})();


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var Time, base, commaize, dateSecondMinusPerformanceSecond, initDateSecond, initPerformanceSecond;

	commaize = __webpack_require__(36).commaize;

	self.performance || (self.performance = {});

	(base = self.performance).now || (base.now = self.performance.mozNow || self.performance.msNow || self.performance.oNow || self.performance.webkitNow || function() {
	  return new Date().getTime();
	});

	initPerformanceSecond = self.performance.now() / 1000;

	initDateSecond = new Date().getTime() / 1000;

	dateSecondMinusPerformanceSecond = initDateSecond - initPerformanceSecond;

	module.exports = Time = (function() {
	  var currentSecond, multiples, timerStack;

	  function Time() {}

	  multiples = [["mo", 30 * 24 * 60 * 60], ["d", 24 * 60 * 60], ["h", 60 * 60], ["m", 60], ["s", 1], ["ms", .001], ["μs", .000001], ["ns", .000000001]];

	  Time.dateSecondToPerformanceSecond = function(dateSecond) {
	    return dateSecond - dateSecondMinusPerformanceSecond;
	  };

	  Time.performanceSecondToDateSecond = function(performanceSecond) {
	    return performanceSecond + dateSecondMinusPerformanceSecond;
	  };

	  Time.timeStampToPerformanceSecond = function(htmlEventTimeStamp) {
	    return htmlEventTimeStamp / 1000 - dateSecondMinusPerformanceSecond;
	  };

	  Time.durationString = function(seconds) {
	    var i, len, multiplier, name, ref;
	    for (i = 0, len = multiples.length; i < len; i++) {
	      ref = multiples[i], name = ref[0], multiplier = ref[1];
	      if (seconds >= multiplier) {
	        return "" + ((seconds / multiplier) | 0) + name;
	      }
	    }
	    return "0";
	  };

	  Time.dateAgeInSeconds = function(date) {
	    return ((new Date) - date) * .001;
	  };

	  Time.dateToSeconds = function(date) {
	    return post.getTime() * .001;
	  };

	  Time.perTimeString = function(secondsPerRun) {
	    var perTime;
	    perTime = 1 / secondsPerRun;
	    if (perTime > 100) {
	      return (commaize(perTime | 0)) + "/s";
	    } else if (perTime * 60 > 100) {
	      return (commaize(perTime * 60 | 0)) + "/m";
	    } else {
	      return (commaize(perTime * 3600 | 0)) + "/h";
	    }
	  };

	  Time.currentMillisecond = function() {
	    return self.performance.now();
	  };

	  Time.currentSecond = currentSecond = function() {
	    return self.performance.now() / 1000;
	  };

	  Time.currentDateSecond = function() {
	    return new Date().getTime() / 1000;
	  };

	  Time.time = function(a, b) {
	    var f, fResult, start, timeResult;
	    f = b || a;
	    start = currentSecond();
	    fResult = f();
	    timeResult = currentSecond() - start;
	    if (b) {
	      Neptune.Art.Foundation.log("time: " + a + " took " + (Time.durationString(timeResult)));
	      return fResult;
	    } else {
	      return timeResult;
	    }
	  };

	  timerStack = [];

	  Time.stackTime = function(f) {
	    var start, subTimeTotal, timeResult, tsl;
	    start = currentSecond();
	    timerStack.push(0);
	    f();
	    subTimeTotal = timerStack.pop();
	    timeResult = currentSecond() - start;
	    if ((tsl = timerStack.length) > 0) {
	      timerStack[tsl - 1] += timeResult;
	    }
	    return {
	      count: 1,
	      total: timeResult,
	      subTimeTotal: subTimeTotal,
	      remainder: timeResult - subTimeTotal
	    };
	  };

	  Time.logTimeSinceLast = function(a) {
	    var time;
	    time = Time.currentSecond();
	    console.log(a + " (" + (Time.lastTime ? Time.durationString(time - Time.lastTime) : void 0) + ")");
	    return Time.lastTime = time;
	  };

	  return Time;

	})();


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var CommonJs, isClass, isFunction, ref;

	ref = __webpack_require__(34), isClass = ref.isClass, isFunction = ref.isFunction;

	module.exports = CommonJs = (function() {
	  var definingModule;

	  function CommonJs() {}

	  definingModule = null;

	  CommonJs.getModuleBeingDefined = function() {
	    return definingModule;
	  };


	  /*
	  IN:
	    defineFunciton ||
	   */

	  CommonJs.defineModule = function(_module, a) {
	    var lastModule, mod, result;
	    lastModule = definingModule;
	    definingModule = _module;
	    mod = isFunction(a) ? isClass(a) ? a : a() : a;
	    result = _module.exports = (mod != null ? typeof mod.createWithPostCreate === "function" ? mod.createWithPostCreate(mod) : void 0 : void 0) || mod;
	    definingModule = lastModule;
	    return result;
	  };

	  return CommonJs;

	})();


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(51).includeInNamespace(__webpack_require__(52)).addModules({
	  FormattedInspect: __webpack_require__(57),
	  InspectedObjectLiteral: __webpack_require__(59),
	  Inspector: __webpack_require__(53),
	  Inspector2: __webpack_require__(61),
	  ToInspectedObjects: __webpack_require__(58),
	  ToPlainObjects: __webpack_require__(60)
	});

	__webpack_require__(62);


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var Inspect, StandardLib,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	StandardLib = __webpack_require__(30);

	module.exports = StandardLib.Inspect || StandardLib.addNamespace('Inspect', Inspect = (function(superClass) {
	  extend(Inspect, superClass);

	  function Inspect() {
	    return Inspect.__super__.constructor.apply(this, arguments);
	  }

	  return Inspect;

	})(Neptune.Base));


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	TODO: refactor so nothing in inspect/* uses BaseObject
	Then, move into StandardLib.
	 */
	module.exports = [[__webpack_require__(53), "shallowInspect inspectLean inspect"], __webpack_require__(57), __webpack_require__(58), __webpack_require__(60), __webpack_require__(59)];


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var Inspector, Map, escapeJavascriptString, isArray, isBrowserObject, isClass, isFunction, isObject, isPlainArray, isPlainObject, isString, objectName, ref,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

	Map = __webpack_require__(54);

	escapeJavascriptString = __webpack_require__(47).escapeJavascriptString;

	ref = __webpack_require__(34), objectName = ref.objectName, isString = ref.isString, isArray = ref.isArray, isFunction = ref.isFunction, isObject = ref.isObject, isClass = ref.isClass, isBrowserObject = ref.isBrowserObject, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray;

	module.exports = Inspector = (function() {
	  var inspect;

	  Inspector.unquotablePropertyRegex = /^([0-9]+|[_a-zA-Z][_0-9a-zA-Z]*)$/;

	  Inspector.customInspectable = function(obj) {
	    return obj.inspect && !(typeof obj === "function");
	  };

	  Inspector.parentString = function(distance) {
	    switch (distance) {
	      case 0:
	        return "parent";
	      case 1:
	        return "grandparent";
	      case 2:
	        return "great grandparent";
	      default:
	        return "great^" + (distance - 1) + " grandparent";
	    }
	  };

	  function Inspector(options) {
	    if (options == null) {
	      options = {};
	    }
	    this.inspect = bind(this.inspect, this);
	    this.inspectInternal = bind(this.inspectInternal, this);
	    this.inspectObject = bind(this.inspectObject, this);
	    this.inspectArray = bind(this.inspectArray, this);
	    this.maxLength = options.maxLength || 1000;
	    this.allowCustomInspectors = !options.noCustomInspectors;
	    this.maxDepth = options.maxDepth != null ? options.maxDepth : 10;
	    this.outArray = [];
	    this.length = 0;
	    this.depth = 0;
	    this.inspectingMap = new Map;
	    this.done = false;
	  }

	  Inspector.inspect = inspect = function(obj, options) {
	    var inspector;
	    if (options == null) {
	      options = {};
	    }
	    if (this !== global) {
	      return Neptune.Base.inspect.call(this);
	    }
	    inspector = new Inspector(options);
	    inspector.inspect(obj);
	    return inspector.getResult();
	  };

	  Inspector.shallowInspect = function(obj) {
	    if (obj == null) {
	      return "" + obj;
	    } else if (Inspector.customInspectable(obj)) {
	      return Inspector.inspect(obj);
	    } else if (isString(obj)) {
	      return escapeJavascriptString(obj);
	    } else if (isArray(obj)) {
	      return "<<Array length: " + obj.length + ">>";
	    } else if (isFunction(obj) && obj.name === "") {
	      return "<<function args: " + obj.length + ">>";
	    } else {
	      return "<<" + (typeof obj) + ": " + (obj.name || obj) + ">>";
	    }
	  };

	  Inspector.inspectLean = function(object, options) {
	    var fullInspect, match;
	    fullInspect = inspect(object, options);
	    if (!isFunction(object != null ? object.inspect : void 0) && (isPlainObject(object) || (isPlainArray(object) && (object.length > 1 || (options != null ? options.forArgs : void 0))))) {
	      match = fullInspect.match(/^\[(.+)\]$|^\{(.+)\}$/);
	      if (match) {
	        return match[1] || match[2] || match[3];
	      } else {
	        return fullInspect;
	      }
	    } else {
	      return fullInspect;
	    }
	  };

	  Inspector.prototype.put = function(s) {
	    if (this.done) {
	      return;
	    }
	    this.outArray.push(this.length + s.length > this.maxLength ? (this.done = true, "...") : (this.length += s.length, s));
	    return s;
	  };

	  Inspector.prototype.getResult = function() {
	    return this.outArray.join("");
	  };

	  Inspector.prototype.maxDepthOutput = function(obj) {
	    var keys, name;
	    switch (typeof obj) {
	      case "string":
	      case "number":
	      case "boolean":
	      case "undefined":
	        return this.inspectInternal(obj);
	      case "function":
	        return this.put(objectName(obj));
	      case "object":
	        return this.put(obj === null ? "null" : isArray(obj) ? "[" + obj.length + " elements]" : (keys = Object.keys(obj), name = objectName(obj), name === "Object" ? "{" + keys.length + " keys}" : keys.length > 0 ? "{" + name + " " + keys.length + " keys}" : name));
	    }
	  };

	  Inspector.prototype.inspectArray = function(array) {
	    var first, i, len, obj;
	    this.put("[");
	    first = true;
	    for (i = 0, len = array.length; i < len; i++) {
	      obj = array[i];
	      if (!first) {
	        this.put(", ");
	      }
	      this.inspect(obj);
	      first = false;
	    }
	    return this.put("]");
	  };

	  Inspector.prototype.inspectObject = function(obj) {
	    var attributes, first, i, k, keys, len, name, v;
	    attributes = [];
	    keys = Object.keys(obj);
	    name = objectName(obj);
	    if (isFunction(obj) && keys.length === 0) {
	      return this.put(name + "()");
	    } else if (isBrowserObject(obj)) {
	      return this.put("{" + name + "}");
	    } else {
	      this.put("{");
	      if (obj.constructor !== Object) {
	        this.put(name + " ");
	      }
	      first = true;
	      for (i = 0, len = keys.length; i < len; i++) {
	        k = keys[i];
	        if (!(k !== "__uniqueId")) {
	          continue;
	        }
	        if (!first) {
	          this.put(", ");
	        }
	        v = obj[k];
	        if (Inspector.unquotablePropertyRegex.test(k)) {
	          this.put(k);
	        } else {
	          this.inspect(k);
	        }
	        this.put(": ");
	        this.inspect(v);
	        first = false;
	      }
	      return this.put("}");
	    }
	  };

	  Inspector.prototype.inspectInternal = function(obj) {
	    if (obj == null) {
	      return this.put("" + obj);
	    } else if (isString(obj)) {
	      return this.put(escapeJavascriptString(obj));
	    } else if (isArray(obj)) {
	      return this.inspectArray(obj);
	    } else if (isClass(obj)) {
	      return this.put(objectName(obj));
	    } else if (this.allowCustomInspectors && Inspector.customInspectable(obj)) {
	      if (obj.inspect.length > 0) {
	        return obj.inspect(this);
	      } else {
	        return this.put(obj.inspect());
	      }
	    } else if (obj instanceof RegExp) {
	      return this.put("" + obj);
	    } else if (isObject(obj) || isFunction(obj)) {
	      return this.inspectObject(obj);
	    } else {
	      return this.put("" + obj);
	    }
	  };

	  Inspector.prototype.inspect = function(obj) {
	    var objDepth;
	    if (this.done) {
	      return;
	    }
	    if (objDepth = this.inspectingMap.get(obj)) {
	      this.put("<" + (Inspector.parentString(this.depth - objDepth)) + ">");
	      return null;
	    }
	    if (this.depth >= this.maxDepth) {
	      this.maxDepthOutput(obj);
	    } else {
	      this.depth++;
	      this.inspectingMap.set(obj, this.depth);
	      this.inspectInternal(obj);
	      this.inspectingMap["delete"](obj);
	      this.depth--;
	    }
	    return null;
	  };

	  return Inspector;

	})();


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	TODO: This is almost identical to ES6's Map: Switch to using a Polyfill like:
	  https://github.com/paulmillr/es6-shim

	Map is a Key-Value map which preserves order.

	Unlike Javascript objects, you can use any object or value as keys. This includes:

	  Strings
	  Numbers
	  null
	  undefined
	  Arrays
	  Objects

	Arrays and Objects are assigned a unique id using the Foundation.Unique library.
	"0", "", null, undefined and 0 are all different unique keys and can each have unique values.
	 */
	var Map, MinimalBaseObject, Node, Unique,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Unique = __webpack_require__(55);

	MinimalBaseObject = __webpack_require__(56);

	Node = (function() {
	  function Node(key, value, prev, next) {
	    this.key = key;
	    this.value = value;
	    this.prev = prev || null;
	    this.next = next || null;
	    if (prev) {
	      prev.next = this;
	    }
	    if (next) {
	      next.prev = this;
	    }
	  }

	  Node.prototype.remove = function() {
	    var n, p;
	    n = this.next;
	    p = this.prev;
	    if (p) {
	      p.next = n;
	      this.prev = null;
	    }
	    if (n) {
	      n.prev = p;
	      return this.next = null;
	    }
	  };

	  return Node;

	})();

	module.exports = Map = (function(superClass) {
	  extend(Map, superClass);

	  Map.inverseMap = function(array) {
	    var i, k, len, result, v;
	    result = new Map;
	    for (k = i = 0, len = array.length; i < len; k = ++i) {
	      v = array[k];
	      result.set(v, k);
	    }
	    return result;
	  };

	  function Map() {
	    this._length = 0;
	    this._map = {};
	    this._first = this._last = null;
	  }

	  Map.getter({
	    length: function() {
	      return this._length;
	    },
	    nodes: function() {
	      var n, result;
	      result = [];
	      n = this._first;
	      while (n) {
	        result.push(n);
	        n = n.next;
	      }
	      return result;
	    },
	    keys: function() {
	      var i, len, node, ref, results;
	      ref = this.nodes;
	      results = [];
	      for (i = 0, len = ref.length; i < len; i++) {
	        node = ref[i];
	        results.push(node.key);
	      }
	      return results;
	    },
	    values: function() {
	      var i, len, node, ref, results;
	      ref = this.nodes;
	      results = [];
	      for (i = 0, len = ref.length; i < len; i++) {
	        node = ref[i];
	        results.push(node.value);
	      }
	      return results;
	    }
	  });

	  Map.prototype.get = function(key) {
	    var node;
	    node = this._map[Unique.id(key)];
	    return node && node.value;
	  };

	  Map.prototype.set = function(key, value) {
	    var id;
	    id = Unique.id(key);
	    if (this._map[id]) {
	      this._map[id].value = value;
	    } else {
	      this._length++;
	      this._last = this._map[id] = new Node(key, value, this._last);
	      if (!this._first) {
	        this._first = this._last;
	      }
	    }
	    return value;
	  };

	  Map.prototype._remove = function(key) {
	    var id, n;
	    id = Unique.id(key);
	    if (n = this._map[id]) {
	      this._length--;
	      delete this._map[id];
	      if (this._first === n) {
	        this._first = n.next;
	      }
	      if (this._last === n) {
	        this._last = n.prev;
	      }
	      n.remove();
	      return n;
	    } else {
	      return void 0;
	    }
	  };

	  Map.prototype.remove = function(key) {
	    var n;
	    if (n = this._remove(key)) {
	      return n.value;
	    } else {
	      return void 0;
	    }
	  };

	  Map.prototype["delete"] = function(key) {
	    return !!this._remove(key);
	  };

	  Map.prototype.exists = function(key) {
	    return this._map[Unique.id(key)];
	  };

	  Map.prototype.forEach = function(f) {
	    var i, len, node, ref;
	    ref = this.nodes;
	    for (i = 0, len = ref.length; i < len; i++) {
	      node = ref[i];
	      f(node.value);
	    }
	    return this;
	  };

	  Map.prototype.findFirst = function(testF) {
	    var i, len, node, ref;
	    ref = this.nodes;
	    for (i = 0, len = ref.length; i < len; i++) {
	      node = ref[i];
	      if (testF(node.value)) {
	        return node.value;
	      }
	    }
	    return void 0;
	  };

	  Map.prototype.each = function(f) {
	    var i, len, node, ref;
	    ref = this.nodes;
	    for (i = 0, len = ref.length; i < len; i++) {
	      node = ref[i];
	      f(node.key, node.value);
	    }
	    return this;
	  };

	  Map.prototype.map = function(f) {
	    var i, len, node, ref, results;
	    ref = this.nodes;
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      node = ref[i];
	      results.push(f(node.key, node.value));
	    }
	    return results;
	  };

	  Map.prototype.inspect = function(inspector) {
	    var _inspect, first;
	    Neptune.Art.Foundation.log("inspect map");
	    if (!inspector) {
	      return Neptune.Art.Foundation.inspect(this);
	    }
	    _inspect = function(o) {
	      if (typeof o === "string" && o.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {
	        return inspector.put(o);
	      } else {
	        return inspector.inspect(o);
	      }
	    };
	    inspector.put("{Map ");
	    first = true;
	    this.map(function(k, v) {
	      if (!first) {
	        inspector.put(", ");
	      }
	      _inspect(k);
	      inspector.put(": ");
	      inspector.inspect(v);
	      return first = false;
	    });
	    return inspector.put("}");
	  };

	  Map.prototype.verifyNodes = function() {
	    var inspect, length, node, prev;
	    inspect = Neptune.Art.Foundation.inspect;
	    if ((this._first == null) && (this._last == null) && this._length === 0) {
	      return;
	    }
	    if (this._length === 0 && this._first) {
	      throw new Error("length == " + this.length + " but @_first is not null");
	    }
	    if (this._length === 0 && this._last) {
	      throw new Error("length == " + this.length + " but @_last is not null");
	    }
	    if (!this._first) {
	      throw new Error("length == " + this.length + " and @_first is null");
	    }
	    if (!this._last) {
	      throw new Error("length == " + this.length + " and @_last is null");
	    }
	    if (this._first.prev) {
	      throw new Error("@_first has prev");
	    }
	    if (this._last.next) {
	      throw new Error("@_last has next");
	    }
	    length = 0;
	    prev = null;
	    node = this._first;
	    while (node) {
	      length++;
	      if (node.prev !== prev) {
	        throw new Error("node.prev != prev. " + (inspect({
	          lenght: length,
	          nodePrev: node.prev,
	          prev: prev
	        }, 1)));
	      }
	      prev = node;
	      node = node.next;
	    }
	    if (this.length !== length) {
	      throw new Error("@length is " + this.length + ", but it should be " + length);
	    }
	  };

	  return Map;

	})(MinimalBaseObject);


/***/ },
/* 55 */
/***/ function(module, exports) {

	var Unique, nextId;

	nextId = 1;

	module.exports = Unique = (function() {
	  var nextUniqueObjectId, objectId;

	  function Unique() {}

	  Unique.nextUniqueObjectId = nextUniqueObjectId = function() {
	    return "object_" + nextId++;
	  };

	  Unique.objectId = objectId = function(o) {
	    if (o.hasOwnProperty("__uniqueId")) {
	      return o.__uniqueId || (o.__uniqueId = nextUniqueObjectId());
	    } else {
	      Object.defineProperty(o, "__uniqueId", {
	        enumerable: false,
	        value: nextUniqueObjectId()
	      });
	      return o.__uniqueId;
	    }
	  };

	  Unique.id = function(key) {
	    if (typeof key === "object" || typeof key === "function") {
	      if (key) {
	        if (typeof key.getUniqueId === "function") {
	          return key.getUniqueId();
	        } else {
	          return objectId(key);
	        }
	      } else {
	        return "null";
	      }
	    } else if (typeof key === "number") {
	      return "" + key;
	    } else if (typeof key === "string") {
	      return "string_" + key;
	    } else if (typeof key === "boolean") {
	      if (key) {
	        return "true";
	      } else {
	        return "false";
	      }
	    } else if (key === void 0) {
	      return "undefined";
	    } else {
	      return (typeof key) + "_" + key;
	    }
	  };

	  return Unique;

	})();


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var MinimalBaseObject, capitalize, isFunction, isPlainObject, isString, ref;

	capitalize = Neptune.NeptuneLib.capitalize;

	ref = __webpack_require__(34), isFunction = ref.isFunction, isString = ref.isString, isPlainObject = ref.isPlainObject;

	module.exports = MinimalBaseObject = (function() {
	  var addGetter, addGetters, addProperties, addSetter, addSetters, defProperties, defProperty, propGetterName, propInternalName, propListStringToArray, propSetterName;

	  function MinimalBaseObject() {}

	  MinimalBaseObject.propInternalName = propInternalName = function(prop) {
	    return "_" + prop;
	  };


	  /*
	  IN: arguments is a list of strings or objects
	    strings: are just the names of the properties
	    objects: map from prop names to getter/setter functions
	   */

	  MinimalBaseObject.getter = function() {
	    return defProperties(this.prototype, arguments, true, false);
	  };

	  MinimalBaseObject.setter = function() {
	    return defProperties(this.prototype, arguments, false, true);
	  };

	  MinimalBaseObject.addGetter = function(prop, getter) {
	    return this._addGetter(this.prototype, prop, getter);
	  };

	  MinimalBaseObject.addSetter = function(prop, setter) {
	    return this._addSetter(this.prototype, prop, setter);
	  };

	  MinimalBaseObject.addClassGetter = function(prop, getter) {
	    return this._addGetter(this, prop, getter);
	  };

	  MinimalBaseObject.addClassSetter = function(prop, setter) {
	    return this._addSetter(this, prop, setter);
	  };


	  /*
	  IN: arguments is a list of strings or objects
	    strings: are just the names of the properties
	    objects: map from prop names to initializers
	   */

	  MinimalBaseObject.property = function() {
	    return defProperties(this.prototype, arguments, true, true);
	  };

	  MinimalBaseObject.classGetter = function() {
	    return defProperties(this, arguments, true, false);
	  };

	  MinimalBaseObject.classSetter = function() {
	    return defProperties(this, arguments, false, true);
	  };

	  MinimalBaseObject.classProperty = function() {
	    return defProperties(this, arguments, true, true);
	  };

	  MinimalBaseObject._propGetterName = propGetterName = function(prop) {
	    return "get" + capitalize(prop);
	  };

	  MinimalBaseObject._propSetterName = propSetterName = function(prop) {
	    return "set" + capitalize(prop);
	  };

	  MinimalBaseObject._addGetter = addGetter = function(obj, prop, getter) {
	    obj[propGetterName(prop)] = getter;
	    if (!isFunction(getter)) {
	      getter = (function() {
	        return getter;
	      });
	    }
	    Object.defineProperty(obj, prop, {
	      get: getter,
	      configurable: true
	    });
	    return prop;
	  };

	  MinimalBaseObject._addSetter = addSetter = function(obj, prop, setter) {
	    obj[propSetterName(prop)] = setter;
	    Object.defineProperty(obj, prop, {
	      set: setter,
	      configurable: true
	    });
	    return prop;
	  };

	  MinimalBaseObject._addGetters = addGetters = function(obj, map) {
	    var getter, prop;
	    for (prop in map) {
	      getter = map[prop];
	      addGetter(obj, prop, getter);
	    }
	    return map;
	  };

	  MinimalBaseObject._addSetters = addSetters = function(obj, map) {
	    var prop, setter;
	    for (prop in map) {
	      setter = map[prop];
	      addSetter(obj, prop, setter);
	    }
	    return map;
	  };

	  MinimalBaseObject._addProperties = addProperties = function(obj, map) {
	    var initializer, prop;
	    for (prop in map) {
	      initializer = map[prop];
	      defProperty(obj, prop, true, true, initializer);
	    }
	    return map;
	  };

	  MinimalBaseObject._defProperty = defProperty = function(obj, prop, defineGetter, defineSetter, initializer) {
	    var propName;
	    propName = propInternalName(prop);
	    if (defineGetter) {
	      addGetter(obj, prop, obj[propGetterName(prop)] = isFunction(initializer) ? function() {
	        if (this[propName] != null) {
	          return this[propName];
	        } else {
	          return this[propName] = initializer();
	        }
	      } : initializer != null ? function() {
	        if (this[propName] != null) {
	          return this[propName];
	        } else {
	          return this[propName] = initializer;
	        }
	      } : function() {
	        return this[propName];
	      });
	    }
	    if (defineSetter) {
	      return addSetter(obj, prop, function(v) {
	        return this[propName] = v;
	      });
	    }
	  };

	  MinimalBaseObject._defProperties = defProperties = function(obj, props, defineGetter, defineSetter) {
	    var i, len, prop, propFromString, propMap, results;
	    results = [];
	    for (i = 0, len = props.length; i < len; i++) {
	      prop = props[i];
	      if (isPlainObject(propMap = prop)) {
	        if (defineGetter && defineSetter) {
	          results.push(addProperties(obj, propMap));
	        } else if (defineGetter) {
	          results.push(addGetters(obj, propMap));
	        } else {
	          results.push(addSetters(obj, propMap));
	        }
	      } else if (isString(prop)) {
	        results.push((function() {
	          var j, len1, ref1, results1;
	          ref1 = propListStringToArray(prop);
	          results1 = [];
	          for (j = 0, len1 = ref1.length; j < len1; j++) {
	            propFromString = ref1[j];
	            results1.push(defProperty(obj, propFromString, defineGetter, defineSetter, null));
	          }
	          return results1;
	        })());
	      } else {
	        throw new Error("invalid value. Expected string or plain-object:", prop);
	      }
	    }
	    return results;
	  };

	  MinimalBaseObject._propListStringToArray = propListStringToArray = function(propList) {
	    return propList.match(/[_a-z][_a-z0-9]*/gi);
	  };

	  return MinimalBaseObject;

	})();


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	var FormattedInspect, alignTabs, escapeJavascriptString, formattedInspectArray, formattedInspectObject, formattedInspectRecursive, formattedInspectString, indentLength, indentString, inspect, isFunction, isNumber, isPlainArray, isPlainObject, isString, max, newLineWithIndentString, pad, postWhitespaceFormatting, ref, ref1, stripTrailingWhitespace, toInspectedObjects;

	ref = __webpack_require__(34), isString = ref.isString, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray, isFunction = ref.isFunction, isNumber = ref.isNumber;

	max = Math.max;

	ref1 = __webpack_require__(47), pad = ref1.pad, stripTrailingWhitespace = ref1.stripTrailingWhitespace, escapeJavascriptString = ref1.escapeJavascriptString;

	inspect = __webpack_require__(53).inspect;

	toInspectedObjects = __webpack_require__(58).toInspectedObjects;

	indentString = '  ';

	indentLength = indentString.length;

	newLineWithIndentString = "\n" + indentString;

	formattedInspectObject = function(m, maxLineLength) {
	  var finalInspectedValues, forceMultilineOutput, index, inspected, inspectedLength, inspectedValues, k, key, keyCount, shouldBeOnOwnLine, v, value;
	  inspectedLength = 0;
	  forceMultilineOutput = false;
	  shouldBeOnOwnLine = false;
	  keyCount = 0;
	  inspectedValues = (function() {
	    var results;
	    results = [];
	    for (key in m) {
	      value = m[key];
	      keyCount++;
	      inspected = formattedInspectRecursive(value, maxLineLength - indentLength);
	      if (inspected.match(/\n/)) {
	        inspected = inspected.match(/^- /) ? "\n" + inspected : newLineWithIndentString + inspected.replace(/\n/g, newLineWithIndentString);
	        inspected += "\n";
	      } else if (inspected.length > maxLineLength - (key.length + 2)) {
	        inspected = "" + newLineWithIndentString + inspected + "\n";
	      }
	      if (!key.match(/^[-._a-zA-Z[_a-zA-Z0-9]*$/)) {
	        key = inspect(key);
	      }
	      inspectedLength += inspected.length + key.length + 2;
	      forceMultilineOutput || (forceMultilineOutput = shouldBeOnOwnLine);
	      shouldBeOnOwnLine = !inspected.match(/^([^,:]|\(.*\)|\{.*\}|\".*\"|\'.*\'|\[.*\])*$/);
	      results.push([key, inspected]);
	    }
	    return results;
	  })();
	  if (keyCount === 0) {
	    return "{}";
	  }
	  index = 0;
	  finalInspectedValues = (function() {
	    var j, len, ref2, results;
	    results = [];
	    for (j = 0, len = inspectedValues.length; j < len; j++) {
	      ref2 = inspectedValues[j], k = ref2[0], v = ref2[1];
	      results.push(k + ":\t" + v);
	    }
	    return results;
	  })();
	  return finalInspectedValues.join(!forceMultilineOutput && maxLineLength >= inspectedLength + (inspectedValues.length - 1) * 2 ? ",\t" : "\n");
	};

	formattedInspectArray = function(m, maxLineLength, implicitRepresentationOk) {
	  var _isPlainObject, containsConsecutiveArrays, containsConsecutiveObjects, i, indentedInspectedArray, inspected, inspectedEl, inspectedLength, inspectedValues, lastWasArray, lastWasObject, value;
	  inspectedLength = 0;
	  lastWasObject = false;
	  lastWasArray = false;
	  containsConsecutiveObjects = false;
	  containsConsecutiveArrays = false;
	  inspectedValues = (function() {
	    var j, len, results;
	    results = [];
	    for (j = 0, len = m.length; j < len; j++) {
	      value = m[j];
	      implicitRepresentationOk = true;
	      if (_isPlainObject = isPlainObject(value)) {
	        containsConsecutiveObjects || (containsConsecutiveObjects = lastWasObject);
	        lastWasObject = true;
	      } else {
	        lastWasObject = false;
	      }
	      if (isPlainArray(value)) {
	        implicitRepresentationOk = false;
	        containsConsecutiveArrays || (containsConsecutiveArrays = lastWasArray);
	        lastWasArray = true;
	      }
	      inspected = formattedInspectRecursive(value, maxLineLength - indentLength, implicitRepresentationOk);
	      if (inspected.match(/\n/)) {
	        inspected = inspected.replace(/\n/g, newLineWithIndentString) + "\n";
	      }
	      inspectedLength += inspected.length;
	      results.push(inspected);
	    }
	    return results;
	  })();
	  if (!containsConsecutiveArrays && !containsConsecutiveObjects && maxLineLength >= inspectedLength + (inspectedValues.length - 1) * 2) {
	    if (inspectedValues.length === 0) {
	      return "[]";
	    } else if (inspectedValues.length <= 1) {
	      return "- " + (inspectedValues.join(",\t"));
	    } else {
	      return inspectedValues.join(",\t");
	    }
	  } else {
	    indentedInspectedArray = (function() {
	      var j, len, results;
	      results = [];
	      for (i = j = 0, len = inspectedValues.length; j < len; i = ++j) {
	        inspectedEl = inspectedValues[i];
	        results.push("- " + inspectedEl);
	      }
	      return results;
	    })();
	    return "" + (indentedInspectedArray.join("\n"));
	  }
	};

	formattedInspectString = function(m) {
	  if (m.length > 10 && m.match(/\n/) && !m.match(/\ (\n|$)/)) {
	    return ['"""', m.replace(/"""/g, '""\\"'), '"""'].join('\n');
	  } else {
	    return escapeJavascriptString(m);
	  }
	};

	formattedInspectRecursive = function(m, maxLineLength, implicitRepresentationOk) {
	  if (isPlainObject(m)) {
	    return formattedInspectObject(m, maxLineLength);
	  } else if (isPlainArray(m)) {
	    return formattedInspectArray(m, maxLineLength, implicitRepresentationOk);
	  } else if (isString(m)) {
	    return formattedInspectString(m);
	  } else {
	    return inspect(m);
	  }
	};

	alignTabs = function(maxLineLength, linesString) {
	  var alignedLines, el, elements, expandAmount, i, j, l, len, len1, line, lines, maxColumnSizes, maxColumnWidth, numColumnsToPad, r, spaceAvailable, tabStops;
	  tabStops = 1;
	  lines = linesString.split("\n");
	  numColumnsToPad = null;
	  maxColumnSizes = [];
	  maxColumnWidth = maxLineLength / 2;
	  for (j = 0, len = lines.length; j < len; j++) {
	    line = lines[j];
	    if (!((elements = line.split("\t")).length > 1)) {
	      continue;
	    }
	    if (numColumnsToPad == null) {
	      numColumnsToPad = elements.length - 1;
	    } else if (numColumnsToPad !== elements.length - 1) {
	      numColumnsToPad = 1;
	    }
	    for (i = l = 0, len1 = elements.length; l < len1; i = ++l) {
	      el = elements[i];
	      if (!(i < elements.length - 1 && (i === 0 || el.length < maxColumnWidth))) {
	        continue;
	      }
	      if (maxColumnSizes.length === i) {
	        maxColumnSizes.push(0);
	      }
	      maxColumnSizes[i] = max(maxColumnSizes[i], el.length + 1);
	    }
	  }
	  alignedLines = (function() {
	    var len2, n, results;
	    results = [];
	    for (n = 0, len2 = lines.length; n < len2; n++) {
	      line = lines[n];
	      spaceAvailable = maxLineLength - line.length;
	      elements = line.split("\t");
	      r = (function() {
	        var len3, o, results1;
	        if (elements.length > 1) {
	          results1 = [];
	          for (i = o = 0, len3 = elements.length; o < len3; i = ++o) {
	            el = elements[i];
	            if (i === elements.length - 1) {
	              results1.push(el);
	            } else if ((maxColumnSizes[i] != null) && (expandAmount = maxColumnSizes[i] - el.length - 1) <= spaceAvailable) {
	              spaceAvailable -= expandAmount;
	              results1.push(pad(el, maxColumnSizes[i]));
	            } else {
	              spaceAvailable = 0;
	              results1.push(el + " ");
	            }
	          }
	          return results1;
	        } else {
	          return elements;
	        }
	      })();
	      results.push(r.join(""));
	    }
	    return results;
	  })();
	  return alignedLines.join("\n");
	};

	postWhitespaceFormatting = function(maxLineLength, string) {
	  var alignTabsInSameIndentGroup, indent, j, lastIndent, len, line, outLines, ref2, sameIndentGroup;
	  lastIndent = 0;
	  sameIndentGroup = [];
	  outLines = [];
	  alignTabsInSameIndentGroup = function() {
	    var str;
	    if (!(sameIndentGroup.length > 0)) {
	      return;
	    }
	    str = sameIndentGroup.join("\n");
	    sameIndentGroup = [];
	    return outLines.push(alignTabs(maxLineLength, str));
	  };
	  ref2 = string.split("\n");
	  for (j = 0, len = ref2.length; j < len; j++) {
	    line = ref2[j];
	    line = line.replace(/\s+$/g, '');
	    if (lastIndent !== (indent = line.match(/^ *-?/)[0].length)) {
	      alignTabsInSameIndentGroup();
	    }
	    sameIndentGroup.push(line);
	    lastIndent = indent;
	  }
	  alignTabsInSameIndentGroup();
	  return outLines.join('\n');
	};

	module.exports = FormattedInspect = (function() {
	  function FormattedInspect() {}

	  FormattedInspect.formattedInspect = function(m, options) {
	    var maxLineLength, out;
	    if (options == null) {
	      options = {};
	    }
	    maxLineLength = isNumber(options) ? options : options.maxLineLength || 80;
	    return out = postWhitespaceFormatting(maxLineLength, formattedInspectRecursive(toInspectedObjects(m), maxLineLength)).replace(/\n\n\n+/g, "\n\n").replace(/\n\n$/, "\n");
	  };

	  return FormattedInspect;

	})();


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var InspectedObjects, deepMap, escapeJavascriptString, inspectedObjectLiteral, isFunction, isPlainArray, isPlainObject, isPromise, isString, ref;

	ref = __webpack_require__(34), deepMap = ref.deepMap, isPlainArray = ref.isPlainArray, isPlainObject = ref.isPlainObject, isString = ref.isString, isFunction = ref.isFunction, isPromise = ref.isPromise;

	escapeJavascriptString = __webpack_require__(47).escapeJavascriptString;

	inspectedObjectLiteral = __webpack_require__(59).inspectedObjectLiteral;

	module.exports = InspectedObjects = (function() {
	  var toInspectedObjects;

	  function InspectedObjects() {}

	  InspectedObjects.toInspectedObjects = toInspectedObjects = function(m) {
	    var functionString, oldm, out, reducedFunctionString;
	    if (m == null) {
	      return m;
	    }
	    oldm = m;
	    if (m === global) {
	      return inspectedObjectLiteral("global");
	    } else if (out = typeof m.getInspectedObjects === "function" ? m.getInspectedObjects() : void 0) {
	      return out;
	    } else if (isPromise(m)) {
	      return inspectedObjectLiteral("Promise");
	    } else if (isPlainObject(m) || isPlainArray(m)) {
	      return deepMap(m, function(v) {
	        return toInspectedObjects(v);
	      });
	    } else if (m instanceof Error) {
	      return inspectedObjectLiteral(m.stack || m.toString(), true);
	    } else if (isFunction(m)) {
	      functionString = "" + m;
	      reducedFunctionString = functionString.replace(/\s+/g, ' ').replace(/^function (\([^)]*\))/, "$1 ->").replace(/^\(\)\s*/, '');
	      return inspectedObjectLiteral(reducedFunctionString.length < 80 ? reducedFunctionString : functionString.slice(0, 5 * 80));
	    } else {
	      return m;
	    }
	  };

	  return InspectedObjects;

	})();


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var InspectedObjectLiteral, compare;

	compare = __webpack_require__(39).compare;

	module.exports = InspectedObjectLiteral = (function() {
	  InspectedObjectLiteral.inspectedObjectLiteral = function(literal, isError) {
	    return new InspectedObjectLiteral(literal, isError);
	  };

	  function InspectedObjectLiteral(literal1, isError1) {
	    this.literal = literal1;
	    this.isError = isError1;
	  }

	  InspectedObjectLiteral.prototype.getInspectedObjects = function() {
	    return this;
	  };

	  InspectedObjectLiteral.prototype.inspect = function() {
	    return this.literal;
	  };

	  InspectedObjectLiteral.prototype.compare = function(b) {
	    return compare(this.literal, b.literal);
	  };

	  return InspectedObjectLiteral;

	})();


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var PlainObjects, deepMap, inspectedObjectLiteral, isFunction, isPlainArray, isPlainObject, ref;

	ref = __webpack_require__(34), deepMap = ref.deepMap, isPlainArray = ref.isPlainArray, isPlainObject = ref.isPlainObject, isFunction = ref.isFunction;

	inspectedObjectLiteral = __webpack_require__(59).inspectedObjectLiteral;

	module.exports = PlainObjects = (function() {
	  var toPlainObjects;

	  function PlainObjects() {}

	  PlainObjects.toPlainObjects = toPlainObjects = function(m) {
	    var functionString, oldm, out, reducedFunctionString;
	    if (m == null) {
	      return m;
	    }
	    oldm = m;
	    if (out = typeof m.getPlainObjects === "function" ? m.getPlainObjects() : void 0) {
	      return out;
	    } else if (isPlainObject(m) || isPlainArray(m)) {
	      return deepMap(m, function(v) {
	        return toPlainObjects(v);
	      });
	    } else if (isFunction(m)) {
	      functionString = "" + m;
	      reducedFunctionString = functionString.replace(/\s+/g, ' ').replace(/^function (\([^)]*\))/, "$1 ->").replace(/^\(\)\s*/, '');
	      return inspectedObjectLiteral(reducedFunctionString.length < 80 ? reducedFunctionString : functionString.slice(0, 5 * 80));
	    } else {
	      return m;
	    }
	  };

	  return PlainObjects;

	})();


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var Inspected, Inspector2, Map, MinimalBaseObject, escapeJavascriptString, isArray, isBrowserObject, isClass, isDate, isFunction, isHTMLImageElement, isObject, isPlainObject, isRegExp, isString, objectName, parentString, ref,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	MinimalBaseObject = __webpack_require__(56);

	Map = __webpack_require__(54);

	Inspected = __webpack_require__(62);

	escapeJavascriptString = __webpack_require__(47).escapeJavascriptString;

	ref = __webpack_require__(34), isString = ref.isString, isArray = ref.isArray, isFunction = ref.isFunction, isObject = ref.isObject, isPlainObject = ref.isPlainObject, isClass = ref.isClass, isDate = ref.isDate, isRegExp = ref.isRegExp, objectName = ref.objectName, isBrowserObject = ref.isBrowserObject;

	isHTMLImageElement = self.HTMLImageElement ? function(obj) {
	  return obj instanceof HTMLImageElement;
	} : function() {
	  return false;
	};

	parentString = (function(_this) {
	  return function(distance) {
	    switch (distance) {
	      case 0:
	        return "parent";
	      case 1:
	        return "grandparent";
	      case 2:
	        return "great grandparent";
	      default:
	        return "great^" + (distance - 1) + " grandparent";
	    }
	  };
	})(this);

	module.exports = Inspector2 = (function(superClass) {
	  extend(Inspector2, superClass);

	  function Inspector2(options) {
	    if (options == null) {
	      options = {};
	    }
	    this.inspectObject = bind(this.inspectObject, this);
	    this.inspectWithToImage = bind(this.inspectWithToImage, this);
	    this.inspectHTMLImageElement = bind(this.inspectHTMLImageElement, this);
	    this.inspectArray = bind(this.inspectArray, this);
	    this.withImages = options.withImages;
	    this.maxLength = options.maxLength || 1000;
	    this.allowCustomInspectors = !options.noCustomInspectors;
	    this.maxDepth = options.maxDepth != null ? options.maxDepth : 10;
	    this.outArray = [];
	    this.length = 0;
	    this.depth = 0;
	    this.inspectingMap = new Map;
	  }

	  Inspector2.prototype.inspectArray = function(array) {
	    var a;
	    return new Inspected.Array((function() {
	      var i, len, results;
	      results = [];
	      for (i = 0, len = array.length; i < len; i++) {
	        a = array[i];
	        results.push(this.inspectInternal(a));
	      }
	      return results;
	    }).call(this));
	  };

	  Inspector2.prototype.inspectHTMLImageElement = function(obj) {
	    var res;
	    res = new Inspected.Object({}, "HTMLImageElement", obj);
	    if (!(res.image = obj).complete) {
	      this.addPendingTask();
	      obj.onload = (function(_this) {
	        return function() {
	          return _this.completePendingTask();
	        };
	      })(this);
	    }
	    return res;
	  };

	  Inspector2.prototype.inspectWithToImage = function(obj) {
	    var name, res;
	    name = objectName(obj);
	    if (typeof obj.classPathName === "string") {
	      name = obj.classPathName;
	    }
	    if (name === "Object") {
	      name = null;
	    }
	    res = new Inspected.Object({}, name, obj);
	    this.addPendingTask();
	    obj.toImage().then((function(_this) {
	      return function(image) {
	        res.image = image;
	        return _this.completePendingTask();
	      };
	    })(this));
	    return res;
	  };

	  Inspector2.prototype.inspectObject = function(obj, recurse) {
	    var attributes, i, k, keys, len, name, res, result;
	    if (recurse == null) {
	      recurse = true;
	    }
	    attributes = [];
	    keys = Object.keys(obj);
	    name = objectName(obj);
	    if (isFunction(obj) && keys.length === 0) {
	      return new Inspected.Core(name + "()");
	    } else {
	      if (typeof obj.classPathName === "string") {
	        name = obj.classPathName;
	      }
	      if (name === "Object") {
	        name = null;
	      }
	      result = {};
	      if (recurse) {
	        for (i = 0, len = keys.length; i < len; i++) {
	          k = keys[i];
	          result[k] = this.inspectInternal(obj[k]);
	        }
	      }
	      res = new Inspected.Object(result, name, obj);
	      if (isFunction(obj.inspect)) {
	        res.inspected = obj.inspect();
	      }
	      return res;
	    }
	  };

	  Inspector2.prototype.addPendingTask = function() {
	    return this.pendingTasks++;
	  };

	  Inspector2.prototype.completePendingTask = function() {
	    this.pendingTasks--;
	    if (this.pendingTasks === 0) {
	      return this.completionCallBack();
	    }
	  };

	  Inspector2.prototype.inspectByType = function(obj) {
	    if (isFunction(obj != null ? obj.getInspectedObjects : void 0)) {
	      obj = obj.getInspectedObjects();
	    }
	    if (obj === null || obj === void 0 || obj === true || obj === false || typeof obj === "number") {
	      return new Inspected.Core(obj);
	    } else if (obj === self) {
	      return new Inspected.Core("self");
	    } else if (isRegExp(obj)) {
	      return new Inspected.Core(obj.toString());
	    } else if (isString(obj)) {
	      return new Inspected.String(obj);
	    } else if (isArray(obj)) {
	      return this.inspectArray(obj);
	    } else if (isClass(obj)) {
	      return new Inspected.Core(objectName(obj));
	    } else if (isHTMLImageElement(obj)) {
	      return this.inspectHTMLImageElement(obj);
	    } else if (isDate(obj)) {
	      return new Inspected.Core(obj.toString());
	    } else if (isBrowserObject(obj)) {
	      return new Inspected.Core(objectName(obj));
	    } else if (this.withImages && typeof obj.toImage === "function" && !isFunction(obj)) {
	      return this.inspectWithToImage(obj);
	    } else if (isPlainObject(obj) || isFunction(obj)) {
	      return this.inspectObject(obj);
	    } else if (isObject(obj)) {
	      return this.inspectObject(obj, false);
	    } else {
	      return new Inspected.Core(objectName(obj));
	    }
	  };

	  Inspector2.prototype.inspectInternal = function(obj) {
	    var objDepth, res;
	    if (objDepth = this.inspectingMap.get(obj)) {
	      return new Inspected.Core("<" + (parentString(this.depth - objDepth)) + ">");
	    } else if (this.depth >= this.maxDepth) {
	      return new Inspected.Core("<maxDepth reached: " + this.maxDepth + ">");
	    } else {
	      this.depth++;
	      this.inspectingMap.set(obj, this.depth);
	      res = this.inspectByType(obj);
	      this.inspectingMap["delete"](obj);
	      this.depth--;
	      return res;
	    }
	  };

	  Inspector2.prototype.inspect = function(obj, callBack) {
	    var res;
	    this.pendingTasks = 0;
	    if (this.withImages && typeof callBack !== "function") {
	      throw new Error("callBack required if withImages requested");
	    }
	    this.completionCallBack = (function(_this) {
	      return function() {
	        return callBack && callBack(res);
	      };
	    })(this);
	    res = this.inspectInternal(obj);
	    if (this.pendingTasks === 0) {
	      this.completionCallBack();
	    }
	    return res;
	  };

	  return Inspector2;

	})(MinimalBaseObject);


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(63).addModules({
	  Array: __webpack_require__(64),
	  Core: __webpack_require__(65),
	  Object: __webpack_require__(66),
	  String: __webpack_require__(67)
	});


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var Inspect, Inspected,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Inspect = __webpack_require__(51);

	module.exports = Inspect.Inspected || Inspect.addNamespace('Inspected', Inspected = (function(superClass) {
	  extend(Inspected, superClass);

	  function Inspected() {
	    return Inspected.__super__.constructor.apply(this, arguments);
	  }

	  return Inspected;

	})(Neptune.Base));


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var Array, MinimalBaseObject,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	MinimalBaseObject = __webpack_require__(56);

	module.exports = Array = (function(superClass) {
	  extend(Array, superClass);

	  function Array(inspectedArray) {
	    Array.__super__.constructor.apply(this, arguments);
	    this.array = inspectedArray;
	  }

	  Array.getter({
	    arrayOfStrings: function() {
	      var i, len, ref, results, v;
	      ref = this.array;
	      results = [];
	      for (i = 0, len = ref.length; i < len; i++) {
	        v = ref[i];
	        results.push(v.toString());
	      }
	      return results;
	    },
	    children: function() {
	      return this.array.slice();
	    }
	  });

	  Array.prototype.delimitedString = function(delimiter) {
	    if (delimiter == null) {
	      delimiter = ", ";
	    }
	    return this.arrayOfStrings.join(", ");
	  };

	  Array.prototype.toString = function() {
	    return "[" + (this.delimitedString()) + "]";
	  };

	  return Array;

	})(MinimalBaseObject);


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var Core, MinimalBaseObject,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	MinimalBaseObject = __webpack_require__(56);

	module.exports = Core = (function(superClass) {
	  extend(Core, superClass);

	  function Core(value) {
	    Core.__super__.constructor.apply(this, arguments);
	    this.value = value;
	    if (value && value.constructor.name === "HTMLImageElement") {
	      this.image = value;
	    }
	  }

	  Core.getter({
	    children: function() {
	      return null;
	    }
	  });

	  Core.prototype.toString = function() {
	    return "" + this.value;
	  };

	  return Core;

	})(MinimalBaseObject);


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	var MinimalBaseObject, Object,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	MinimalBaseObject = __webpack_require__(56);

	module.exports = Object = (function(superClass) {
	  extend(Object, superClass);

	  function Object(properties, instanceOf, originalObject) {
	    this.properties = properties;
	    this.instanceOf = instanceOf;
	    this.originalObject = originalObject;
	    Object.__super__.constructor.apply(this, arguments);
	    this.length = this.properties ? self.Object.keys(this.properties).length : 0;
	  }

	  Object.getter({
	    arrayOfStrings: function() {
	      var k, ref, results, v;
	      ref = this.properties;
	      results = [];
	      for (k in ref) {
	        v = ref[k];
	        results.push(k + ": " + v);
	      }
	      return results;
	    },
	    children: function() {
	      var k, ref, ret, v;
	      ret = {};
	      ref = this.properties;
	      for (k in ref) {
	        v = ref[k];
	        ret[k] = v;
	      }
	      return ret;
	    }
	  });

	  Object.prototype.delimitedString = function(delimiter) {
	    if (delimiter == null) {
	      delimiter = ", ";
	    }
	    return this.arrayOfStrings.join(", ");
	  };

	  Object.prototype.toString = function() {
	    if (this.inspected) {
	      return this.inspected;
	    } else if (this.instanceOf) {
	      return "{" + this.instanceOf + " " + (this.delimitedString()) + "}";
	    } else {
	      return "{" + (this.delimitedString()) + "}";
	    }
	  };

	  return Object;

	})(MinimalBaseObject);


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var MinimalBaseObject, String, escapeJavascriptString,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	MinimalBaseObject = __webpack_require__(56);

	escapeJavascriptString = __webpack_require__(47).escapeJavascriptString;

	module.exports = String = (function(superClass) {
	  extend(String, superClass);

	  function String(clonedString) {
	    String.__super__.constructor.apply(this, arguments);
	    this.string = clonedString;
	  }

	  String.prototype.toString = function() {
	    return escapeJavascriptString(this.string);
	  };

	  return String;

	})(MinimalBaseObject);


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	This current iteration of clone relies on some singleton variables shared across all invocations of clone.
	This is fine as long as javascript stays single-threaded.
	It also introduces a little bit of uglyness initializing clonedMap necessitating the "top" variable.

	FUTURE
	A potentially better solution would be to create a new closer each time clone is called at the top-most level,
	but when recursing, pass in a new function bound to that closure which is different from the global clone function.

	populateClone would need to take an additional argument - the clone function to use for recursive cloning.
	 */
	var Clone, Foundation, Map, Unique, byProperties, byStructure, clonedMap, inspect, topObject, uniquePropertyName;

	Foundation = __webpack_require__(30);

	Map = __webpack_require__(54);

	Unique = __webpack_require__(55);

	inspect = __webpack_require__(50).inspect;

	uniquePropertyName = Unique.PropertyName;

	clonedMap = null;

	byStructure = false;

	byProperties = false;

	topObject = null;

	module.exports = Clone = (function() {
	  var clone, cloneArray, cloneByProperties, cloneByStructure, cloneObject, emptyClone;

	  function Clone() {}

	  cloneArray = function(array) {
	    var clonedArray, i, index, len, value;
	    clonedArray = clonedMap.set(array, array.slice());
	    for (index = i = 0, len = clonedArray.length; i < len; index = ++i) {
	      value = clonedArray[index];
	      clonedArray[index] = clone(value);
	    }
	    return clonedArray;
	  };

	  cloneObject = function(obj) {
	    var clonedObject, k, v;
	    clonedObject = clonedMap.set(obj, emptyClone(obj));
	    if ((obj !== topObject || !byProperties) && obj.populateClone) {
	      obj.populateClone(clonedObject);
	    } else {
	      for (k in obj) {
	        v = obj[k];
	        clonedObject[k] = clone(v);
	      }
	    }
	    return clonedObject;
	  };

	  Clone.emptyClone = emptyClone = function(obj) {
	    if (obj.constructor === Array) {
	      return [];
	    } else {
	      return Object.create(Object.getPrototypeOf(obj));
	    }
	  };

	  Clone.clone = clone = function(obj, mode) {
	    var clonedObject, got;
	    switch (mode) {
	      case "byStructure":
	        byStructure = true;
	        break;
	      case "byProperties":
	        byProperties = true;
	    }
	    if (obj === null || obj === void 0 || typeof obj !== "object") {
	      return obj;
	    }
	    if (byStructure && (obj.constructor !== Array && obj.constructor !== Object)) {
	      return obj;
	    }
	    if (clonedMap) {
	      if (got = clonedMap.get(obj)) {
	        return got;
	      }
	    } else {
	      topObject = obj;
	      clonedMap = new Map;
	    }
	    clonedObject = obj.constructor === Array ? cloneArray(obj) : cloneObject(obj);
	    if (topObject === obj) {
	      byStructure = false;
	      byProperties = false;
	      topObject = null;
	      clonedMap = null;
	    }
	    return clonedObject;
	  };

	  Clone.cloneByProperties = cloneByProperties = function(obj) {
	    return clone(obj, "byProperties");
	  };

	  Clone.cloneByStructure = cloneByStructure = function(obj) {
	    return clone(obj, "byStructure");
	  };

	  return Clone;

	})();


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var Inspect, Log, callStack, isString, peek,
	  slice = [].slice;

	Inspect = __webpack_require__(51);

	callStack = __webpack_require__(70).callStack;

	isString = __webpack_require__(34).isString;

	peek = __webpack_require__(35).peek;

	module.exports = Log = (function() {
	  var noOptions;

	  function Log() {}

	  Log.contextString = function(stack, defaultContext) {
	    var caller, context;
	    if (stack && (caller = stack[1])) {
	      if (caller.original) {
	        return caller.original;
	      } else {
	        context = caller["function"] ? caller["class"] ? caller["class"] + "::" + caller["function"] + "()" : caller["function"] + "()" : defaultContext ? defaultContext + ":" : "";
	        if (caller.sourceFileName) {
	          return "at " + caller.sourceFileName + ("-" + caller.sourceLine + ": ") + context;
	        }
	      }
	    } else {
	      return "at " + (defaultContext || "(unknown context)");
	    }
	  };

	  Log.autoSizedIndepect = function(toInspect, maxLength, maxDepth) {
	    var depth, inspected;
	    if (maxLength == null) {
	      maxLength = 512;
	    }
	    if (maxDepth == null) {
	      maxDepth = 10;
	    }
	    inspected = null;
	    depth = maxDepth;
	    while ((inspected = Inspect.inspectLean(toInspect, {
	        maxDepth: depth,
	        maxLength: maxLength
	      })).match(/\.\.\.$/)) {
	      depth--;
	    }
	    return inspected;
	  };

	  Log.loggedParamsString = function(params) {
	    if (typeof params === "string") {
	      return params;
	    } else {
	      return Log.autoSizedIndepect(params);
	    }
	  };

	  Log.hideLogging = function() {
	    return Log.loggingHidden = true;
	  };

	  Log.showLogging = function() {
	    return Log.loggingHidden = false;
	  };

	  Log.rawLog = function() {
	    if (!Log.loggingHidden) {
	      return console.log.apply(console, arguments);
	    }
	  };

	  Log.rawErrorLog = function() {
	    if (!Log.loggingHidden) {
	      return console.error.apply(console, arguments);
	    }
	  };

	  noOptions = {};

	  Log.logCore = function(m, stack, options) {
	    var className, isError, logger;
	    if (options == null) {
	      options = noOptions;
	    }
	    className = options.className, isError = options.isError;
	    if (Log.alternativeLogger) {
	      Log.alternativeLogger.logCore(m, stack, options);
	    }
	    logger = isError ? Log.rawErrorLog : Log.rawLog;
	    if (Neptune.isNode) {
	      return logger(isString(m) ? m : Inspect.formattedInspect(m, process.stdout.columns));
	    } else {
	      return logger(m, "\n# Foundation.log called " + Log.contextString(stack, className));
	    }
	  };

	  Log.log = function() {
	    var args, m, stack;
	    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    m = args.length === 1 ? args[0] : args;
	    stack = callStack();
	    Log.logCore(m, stack);
	    return peek(args);
	  };


	  /*
	  
	  IN:
	    labelString, value
	    OR object with one or more properties (usually just one)
	      returns the last value of the objects last key-value pair
	  
	  EX:
	    log.withLabel foo: myObject
	     * out: myObject
	  
	    log.withLabel "foo", myObject
	     * out: myObject
	   */

	  Log.log.withLabel = function(a, b) {
	    var k, obj, ret, v;
	    if (isString(a)) {
	      obj = {};
	      obj[a] = b;
	      Log.log(obj);
	      return b;
	    } else {
	      ret = null;
	      for (k in a) {
	        v = a[k];
	        ret = v;
	      }
	      Log.log(obj);
	      return ret;
	    }
	  };

	  Log.log.labeled = Log.log.withLabel;

	  Log.log.error = function() {
	    var args, m, stack;
	    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    m = args.length === 1 ? args[0] : args;
	    stack = callStack();
	    Log.logCore(m, stack, {
	      isError: true
	    });
	    return peek(args);
	  };

	  Log.logL = function(obj) {
	    var k, ret, v;
	    console.warn("DEPRICATED: logL. USE log.labeled");
	    ret = null;
	    for (k in obj) {
	      v = obj[k];
	      ret = v;
	    }
	    Log.log(obj);
	    return ret;
	  };

	  return Log;

	})();


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	var CallStack, inspect, isString, parseUrl;

	isString = __webpack_require__(34).isString;

	parseUrl = __webpack_require__(43).parseUrl;

	inspect = __webpack_require__(50).inspect;

	module.exports = CallStack = (function() {
	  var CallStackLine;

	  function CallStack() {}

	  CallStack.errorToString = function(error) {
	    return (error != null ? error.error : void 0) || (error != null ? error.message : void 0) || (isString(error) && error) || Neptune.Art.Foundation.formattedInspect(error);
	  };

	  CallStack.CallStackLine = CallStackLine = (function() {
	    CallStackLine.getter = function(map) {
	      var getter, prop, results;
	      results = [];
	      for (prop in map) {
	        getter = map[prop];
	        results.push(Object.defineProperty(this.prototype, prop, {
	          get: getter,
	          configurable: true
	        }));
	      }
	      return results;
	    };

	    CallStackLine.setter = function(map) {
	      var prop, results, setter;
	      results = [];
	      for (prop in map) {
	        setter = map[prop];
	        results.push(Object.defineProperty(this.prototype, prop, {
	          set: setter,
	          configurable: true
	        }));
	      }
	      return results;
	    };

	    function CallStackLine(line) {
	      this.original = line;
	      this["function"] = null;
	      this.source = null;
	      this["class"] = null;
	      this.classPath = null;
	      this.sourceFileName = null;
	      this.sourcePath = null;
	      this.sourceHostWithPort = null;
	      this.sourceLine = 0;
	      this.sourceColumn = 0;
	      if (this.parseLineWithFunction(line)) {

	      } else {
	        this.parseLineWithoutFunction(line);
	      }
	      this.subParseFunction();
	      this.subParseSource();
	    }

	    CallStackLine.prototype.toString = function() {
	      return this.original;
	    };

	    CallStackLine.getter({
	      fileWithLocation: function() {
	        return this._fileWithLocation || (this._fileWithLocation = this.sourceFileName ? this.sourcePath + "/" + this.sourceFileName + ":" + this.sourceLine + ":" + this.sourceColumn : this.original);
	      }
	    });

	    CallStackLine.prototype.parseLineWithFunction = function(line) {
	      var r;
	      if (r = line.match(/\s*at\s((new\s)?[a-zA-Z0-9_.<>]+)\s\(([^)]*):([0-9]+):([0-9]+)\)/)) {
	        this["function"] = r[1];
	        this.source = r[3];
	        this.sourceLine = r[4] | 0;
	        return this.sourceColumn = r[5] | 0;
	      }
	    };

	    CallStackLine.prototype.parseLineWithoutFunction = function(line) {
	      var r;
	      if (r = line.match(/\s*at\s([^)]*):([0-9]+):([0-9]+)/)) {
	        this.source = r[1];
	        this.sourceLine = r[2] | 0;
	        return this.sourceColumn = r[3] | 0;
	      }
	    };

	    CallStackLine.prototype.subParseSource = function() {
	      var url;
	      if (this.source) {
	        url = parseUrl(this.source);
	        this.sourceFileName = url.fileName;
	        this.sourcePath = url.path;
	        return this.sourceHostWithPort = url.hostWithPort;
	      }
	    };

	    CallStackLine.prototype.subParseFunction = function() {
	      var f;
	      if (this["function"]) {
	        f = this["function"].split(".");
	        this["function"] = f[f.length - 1];
	        if (this["function"] === "<anonymous>") {
	          this["function"] = void 0;
	        }
	        this["class"] = f[f.length - 2];
	        return this.classPath = f.slice(0, f.length - 2);
	      }
	    };

	    return CallStackLine;

	  })();

	  CallStack.rawCallStack = (new Error).stack ? function(ignoreTop) {
	    if (ignoreTop == null) {
	      ignoreTop = 0;
	    }
	    return (new Error).stack.split(/\n  */).slice(ignoreTop + 2);
	  } : function(ignoreTop) {
	    var e;
	    if (ignoreTop == null) {
	      ignoreTop = 0;
	    }
	    try {
	      throw new Error;
	    } catch (error1) {
	      e = error1;
	      return e.stack.split(/\n  */).slice(ignoreTop + 2);
	    }
	  };

	  CallStack.callStack = function(ignoreTop) {
	    var i, len, line, ref, results;
	    if (ignoreTop == null) {
	      ignoreTop = 0;
	    }
	    ref = CallStack.rawCallStack(ignoreTop + 1);
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      line = ref[i];
	      results.push(new CallStackLine(line));
	    }
	    return results;
	  };

	  return CallStack;

	})();


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(72).includeInNamespace(__webpack_require__(73)).addModules({
	  BinaryString: __webpack_require__(76),
	  DataUri: __webpack_require__(84),
	  EncodedImage: __webpack_require__(85),
	  File: __webpack_require__(75),
	  Stream: __webpack_require__(83),
	  TypedarraySlicePolyfill: __webpack_require__(74),
	  Utf8: __webpack_require__(77),
	  WriteStream: __webpack_require__(86)
	});


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var Binary, Foundation,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(26);

	module.exports = Foundation.Binary || Foundation.addNamespace('Binary', Binary = (function(superClass) {
	  extend(Binary, superClass);

	  function Binary() {
	    return Binary.__super__.constructor.apply(this, arguments);
	  }

	  return Binary;

	})(Neptune.Base));


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(74);

	module.exports = [
	  __webpack_require__(75), {
	    stream: (__webpack_require__(83)).stream
	  }, [__webpack_require__(76), "binary binaryFromBlob"]
	];


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var base, base1, base10, base11, base2, base3, base4, base5, base6, base7, base8, base9, bound, genericSlice, ref, ref1;

	bound = __webpack_require__(29).bound;

	(base = Uint8Array.prototype).slice || (base.slice = genericSlice = function(start, end) {
	  var i, j, length, out, outIndex, ref, ref1;
	  if (end == null) {
	    end = this.length;
	  }
	  if (start < 0) {
	    start += this.length;
	  }
	  if (end < 0) {
	    end += this.length;
	  }
	  start = bound(0, start, this.length);
	  end = bound(0, end, this.length);
	  out = new Uint8Array(length = end - start);
	  outIndex = 0;
	  for (i = j = ref = start, ref1 = end; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
	    out[outIndex++] = this[i];
	  }
	  return out;
	});

	(base1 = Int8Array.prototype).slice || (base1.slice = genericSlice);

	(base2 = Uint8Array.prototype).slice || (base2.slice = genericSlice);

	(base3 = Int16Array.prototype).slice || (base3.slice = genericSlice);

	(base4 = Uint16Array.prototype).slice || (base4.slice = genericSlice);

	(base5 = Int32Array.prototype).slice || (base5.slice = genericSlice);

	(base6 = Uint32Array.prototype).slice || (base6.slice = genericSlice);

	(base7 = Float32Array.prototype).slice || (base7.slice = genericSlice);

	(base8 = Float64Array.prototype).slice || (base8.slice = genericSlice);

	if ((ref = self.Uint8ClampedArray) != null) {
	  (base9 = ref.prototype).slice || (base9.slice = genericSlice);
	}

	if ((ref1 = self.CanvasPixelArray) != null) {
	  (base10 = ref1.prototype).slice || (base10.slice = genericSlice);
	}

	(base11 = ArrayBuffer.prototype).slice || (base11.slice = function(start, end) {
	  return (new Uint8Array(this)).slice(start, end).buffer;
	});


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var BinaryString, File, Promise, StandardLib;

	StandardLib = __webpack_require__(29);

	Promise = StandardLib.Promise;

	BinaryString = __webpack_require__(76);

	module.exports = File = (function() {
	  var readAsArrayBuffer;

	  function File() {}

	  File._readWithPromise = function(readFunction) {
	    return function(file) {
	      return new Promise(function(resolve, reject) {
	        var fr;
	        fr = new FileReader;
	        fr[readFunction](file);
	        fr.onerror = reject;
	        return fr.onload = (function(_this) {
	          return function(event) {
	            return resolve(event.target.result);
	          };
	        })(this);
	      });
	    };
	  };

	  File.readAsArrayBuffer = readAsArrayBuffer = File._readWithPromise("readAsArrayBuffer");

	  File.readAsDataURL = File._readWithPromise("readAsDataURL");

	  File.readAsBinaryString = function(file) {
	    return readAsArrayBuffer(file).then(function(arrayBuffer) {
	      return new BinaryString(arrayBuffer);
	    });
	  };

	  return File;

	})();


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, Binary, BinaryString, ClassSystem, StandardLib, Utf8, compactFlatten, encodings, inspect, isFunction, isPlainArray, isString, log, min, pad, readFileAsArrayBuffer, readFileAsDataUrl,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Binary = __webpack_require__(72);

	Utf8 = __webpack_require__(77);

	StandardLib = __webpack_require__(29);

	ClassSystem = __webpack_require__(78);

	isString = StandardLib.isString, isFunction = StandardLib.isFunction, isPlainArray = StandardLib.isPlainArray, log = StandardLib.log, min = StandardLib.min, inspect = StandardLib.inspect, readFileAsDataUrl = StandardLib.readFileAsDataUrl, readFileAsArrayBuffer = StandardLib.readFileAsArrayBuffer, compactFlatten = StandardLib.compactFlatten, pad = StandardLib.pad;

	BaseObject = ClassSystem.BaseObject, inspect = ClassSystem.inspect;

	encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	module.exports = BinaryString = (function(superClass) {
	  var binary;

	  extend(BinaryString, superClass);

	  BinaryString.binary = binary = function(arg) {
	    if (arg instanceof BinaryString) {
	      return arg;
	    } else {
	      return new BinaryString(arg);
	    }
	  };

	  BinaryString.binaryFromBlob = function(blob) {
	    return readFileAsArrayBuffer(blob).then(function(ab) {
	      return binary(ab);
	    });
	  };

	  BinaryString.cloneUint8Array = function(srcU8A) {
	    var dstU8A;
	    dstU8A = new Uint8Array(new ArrayBuffer(src.length));
	    dstU8A.set(srcU8A);
	    return dstU8A;
	  };

	  function BinaryString(arg) {
	    this.bytes = (function() {
	      if (arg instanceof BinaryString) {
	        return BinaryString.cloneUint8Array(arg.bytes);
	      } else if (isFunction(arg != null ? arg.uint8Array : void 0)) {
	        return arg.uint8Array();
	      } else if (isPlainArray(arg)) {
	        return new Uint8Array(arg);
	      } else if (arg instanceof ArrayBuffer) {
	        return new Uint8Array(arg);
	      } else if (arg instanceof Uint8Array) {
	        return arg;
	      } else if (isString(arg)) {
	        return Utf8.toBuffer(arg);
	      } else if (isFunction(arg.toString)) {
	        return Utf8.toBuffer(arg.toString());
	      } else {
	        throw new Error("invalid Binary string constructor argument: " + (inspect(arg)));
	      }
	    })();
	    this.length = this.bytes.length;
	  }

	  BinaryString.prototype.slice = function(a, b) {
	    return new BinaryString(this.bytes.slice(a, b));
	  };

	  BinaryString.fromBase64 = function(base64encoding) {
	    var byteString, i, j, len, ref, uint8Array;
	    byteString = atob(base64encoding);
	    len = byteString.length;
	    uint8Array = new Uint8Array(new ArrayBuffer(len));
	    for (i = j = 0, ref = len; j < ref; i = j += 1) {
	      uint8Array[i] = byteString.charCodeAt(i);
	    }
	    return new BinaryString(uint8Array);
	  };

	  BinaryString.prototype.toDataUri = function() {
	    return readFileAsDataUrl(new Blob([this.bytes]));
	  };

	  BinaryString.fromDataUri = function(dataURI) {
	    var base64encoding, splitDataURI;
	    splitDataURI = dataURI.split(',');
	    base64encoding = splitDataURI[1];
	    return this.fromBase64(base64encoding);
	  };

	  BinaryString.prototype.toString = function() {
	    return Utf8.toString(this.bytes);
	  };

	  BinaryString.prototype.toArrayBuffer = function() {
	    return this.bytes.buffer;
	  };

	  BinaryString.prototype.toBlob = function() {
	    return new Blob([this.bytes]);
	  };

	  BinaryString.prototype.eq = function(b) {
	    return this.compare(b) === 0;
	  };

	  BinaryString.prototype.compare = function(b) {
	    var bytesA, bytesB, diff, i, j, ref;
	    bytesA = this.bytes;
	    bytesB = b.bytes;
	    for (i = j = 0, ref = min(this.length, b.length); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	      if (0 !== (diff = bytesA[i] - bytesB[i])) {
	        return diff;
	      }
	    }
	    return this.length - b.length;
	  };

	  BinaryString.prototype.inspect = function() {
	    return this.getInspectedString();
	  };

	  BinaryString.getter({
	    uint8Array: function() {
	      return this.bytes;
	    },
	    arrayBuffer: function() {
	      return this.bytes.buffer;
	    },
	    blob: function() {
	      return new Blob([this.bytes]);
	    },
	    plainArray: function() {
	      var b, j, len1, ref, results;
	      ref = this.bytes;
	      results = [];
	      for (j = 0, len1 = ref.length; j < len1; j++) {
	        b = ref[j];
	        results.push(b);
	      }
	      return results;
	    },
	    byteLength: function() {
	      return this.length;
	    },
	    inspectedString: function(stride, maxBytes) {
	      var characters, count, line, offset;
	      if (stride == null) {
	        stride = 8;
	      }
	      if (maxBytes == null) {
	        maxBytes = 64;
	      }
	      count = 0;
	      characters = [];
	      if (this.length < maxBytes) {
	        maxBytes = this.length;
	      }
	      line = new Array(stride);
	      return compactFlatten([
	        "BinaryString length: " + this.length + " bytes", maxBytes < this.length ? "First " + maxBytes + " bytes:" : void 0, (function() {
	          var j, ref, ref1, results;
	          results = [];
	          for (offset = j = 0, ref = maxBytes, ref1 = stride; ref1 > 0 ? j < ref : j > ref; offset = j += ref1) {
	            results.push(this._inspectLine(offset, stride, maxBytes));
	          }
	          return results;
	        }).call(this)
	      ]).join('\n');
	    }
	  });

	  BinaryString.prototype._inspectLine = function(offset, length, maxBytes) {
	    var b, characters, end, hexCharacters, i, y;
	    end = min(this.length, offset + length);
	    if (maxBytes >= 0) {
	      end = min(end, maxBytes);
	    }
	    characters = (function() {
	      var j, ref, ref1, results;
	      results = [];
	      for (i = j = ref = offset, ref1 = end; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
	        b = this.bytes[i];
	        if (b >= 31 && b <= 127) {
	          results.push(String.fromCharCode(b));
	        } else {
	          results.push('•');
	        }
	      }
	      return results;
	    }).call(this);
	    hexCharacters = (function() {
	      var j, ref, ref1, results;
	      results = [];
	      for (i = j = ref = offset, ref1 = end; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
	        b = this.bytes[i];
	        y = b.toString(16);
	        if (y.length < 2) {
	          y = "0" + y;
	        }
	        results.push(y);
	      }
	      return results;
	    }).call(this);
	    return (pad(hexCharacters.join(' '), length * 3)) + " '" + (characters.join('')) + "'";
	  };


	  /*
	  toBase64 performance
	  see: http://localhost:8080/webpack-dev-server/perf?grep=BinaryString
	  as-of 2016-02-14, the manual string manipulation version is surprisingly the best on average for FF, Chrome and Safari
	    For shorter lengths, toBase64Custom is by far the fastest, but
	    toBase64ToDataUri starts to be faster at longer lengths.
	   */

	  BinaryString.prototype.toBase64 = function() {
	    if (this.length > 16 * 1024) {
	      return this.toBase64ToDataUri();
	    } else {
	      return this.toBase64Custom();
	    }
	  };

	  BinaryString.prototype.toBase64ToDataUri = function() {
	    return this.toDataUri().then(function(dataUri) {
	      return dataUri.split(',')[1];
	    });
	  };

	  BinaryString.prototype.toBase64Custom = function() {
	    var a, b, base64, byteLength, byteRemainder, bytes, c, chunk, d, i, j, mainLength, ref;
	    bytes = this.bytes;
	    base64 = '';
	    byteLength = bytes.byteLength;
	    byteRemainder = byteLength % 3;
	    mainLength = byteLength - byteRemainder;
	    for (i = j = 0, ref = mainLength - 1; j <= ref; i = j += 3) {
	      chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
	      a = (chunk & 16515072) >> 18;
	      b = (chunk & 258048) >> 12;
	      c = (chunk & 4032) >> 6;
	      d = chunk & 63;
	      base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
	    }
	    return Promise.resolve((function() {
	      switch (byteRemainder) {
	        case 0:
	          return base64;
	        case 1:
	          chunk = bytes[mainLength];
	          a = (chunk & 252) >> 2;
	          b = (chunk & 3) << 4;
	          return base64 + encodings[a] + encodings[b] + '==';
	        case 2:
	          chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];
	          a = (chunk & 64512) >> 10;
	          b = (chunk & 1008) >> 4;
	          c = (chunk & 15) << 2;
	          return base64 + encodings[a] + encodings[b] + encodings[c] + '=';
	      }
	    })());
	  };

	  return BinaryString;

	})(BaseObject);


/***/ },
/* 77 */
/***/ function(module, exports) {

	var Utf8;

	module.exports = Utf8 = (function() {
	  function Utf8() {}

	  Utf8.toBuffer = function(string) {
	    return new Uint8Array(this.toArray(string));
	  };

	  Utf8.toArray = function(string) {
	    var char, i, out, uriEncoded;
	    uriEncoded = encodeURIComponent(string);
	    i = 0;
	    out = (function() {
	      var results;
	      results = [];
	      while (i < uriEncoded.length) {
	        char = uriEncoded.charCodeAt(i++);
	        if (char === 0x25) {
	          i += 2;
	          results.push(parseInt(uriEncoded.substr(i - 2, 2), 16));
	        } else {
	          results.push(char);
	        }
	      }
	      return results;
	    })();
	    return out;
	  };

	  Utf8.toString = function(a) {
	    var error, x, y;
	    if (a === void 0) {
	      return "<undefined>";
	    }
	    if (a === null) {
	      return "<null>";
	    }
	    try {
	      if (a instanceof ArrayBuffer) {
	        a = new Uint8Array(a);
	      }
	      return decodeURIComponent(((function() {
	        var j, len, results;
	        results = [];
	        for (j = 0, len = a.length; j < len; j++) {
	          x = a[j];
	          y = x.toString(16);
	          if (y.length < 2) {
	            y = "0" + y;
	          }
	          y = "%" + y;
	          results.push(y);
	        }
	        return results;
	      })()).join(''));
	    } catch (error1) {
	      error = error1;
	      console.warn(error.toString(), error);
	      return "<" + a.length + " binary bytes>";
	    }
	  };

	  return Utf8;

	})();


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(79).includeInNamespace(__webpack_require__(80)).addModules({
	  BaseObject: __webpack_require__(81),
	  WebpackHotLoader: __webpack_require__(82)
	});


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var ClassSystem, Foundation,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(26);

	module.exports = Foundation.ClassSystem || Foundation.addNamespace('ClassSystem', ClassSystem = (function(superClass) {
	  extend(ClassSystem, superClass);

	  function ClassSystem() {
	    return ClassSystem.__super__.constructor.apply(this, arguments);
	  }

	  return ClassSystem;

	})(Neptune.Base));


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [[__webpack_require__(81), "mixInto createAllClass createWithPostCreate createHotWithPostCreate"]];


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, Log, MinimalBaseObject, StandardLib, Unique, WebpackHotLoader, callStack, capitalize, clone, concatInto, decapitalize, extendClone, functionName, getModuleBeingDefined, inspectedObjectLiteral, isFunction, isPlainArray, isPlainObject, isString, log, mergeInto, nextUniqueObjectId, objectName,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  slice = [].slice,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	StandardLib = __webpack_require__(29);

	WebpackHotLoader = __webpack_require__(82);

	capitalize = StandardLib.capitalize, decapitalize = StandardLib.decapitalize, log = StandardLib.log, extendClone = StandardLib.extendClone, clone = StandardLib.clone, isFunction = StandardLib.isFunction, objectName = StandardLib.objectName, isPlainObject = StandardLib.isPlainObject, functionName = StandardLib.functionName, isString = StandardLib.isString, isPlainArray = StandardLib.isPlainArray, Unique = StandardLib.Unique, callStack = StandardLib.callStack, Log = StandardLib.Log, inspectedObjectLiteral = StandardLib.inspectedObjectLiteral, MinimalBaseObject = StandardLib.MinimalBaseObject, getModuleBeingDefined = StandardLib.getModuleBeingDefined, concatInto = StandardLib.concatInto, mergeInto = StandardLib.mergeInto, isString = StandardLib.isString;

	nextUniqueObjectId = Unique.nextUniqueObjectId;

	module.exports = BaseObject = (function(superClass) {
	  var arrayPropertyExtender, createWithPostCreate, excludedKeys, getOwnProperty, imprintObject, mixInto, objectPropertyExtender, warnedAboutIncludeOnce;

	  extend(BaseObject, superClass);

	  BaseObject.objectsCreated = 0;

	  BaseObject.objectsCreatedByType = {};

	  BaseObject.resetStats = function() {
	    BaseObject.objectsCreated = 0;
	    return BaseObject.objectsCreatedByType = {};
	  };

	  BaseObject._name = null;


	  /*
	  NOTE: only hasOwnProperties are considered! Inherited properties are not touched.
	  IN:
	    toObject:   object will be altered to be an "imprint" of fromObject
	    fromObject: object pattern used to imprint toObject
	    preserveState:
	      false:
	        toObject has every property updated to exactly match fromObject
	  
	        This includes:
	          1. delete properties in toObject that are not in fromObject
	          2. add every property in fromObject but not in toObject
	          3. overwriting every property in toObject also in fromObject
	  
	      true:
	        Attempts to preserve the state of toObject while updating its functionality.
	        This means properties which are functions in either object are updated.
	  
	        WARNING: This is a grey area for JavaScript. It is not entirely clear what is
	          state and what is 'functionality'. I, SBD, have made the following heuristic decisions:
	  
	        Imprint actions taken when preserving State:
	  
	        1. DO NOTHING to properties in toObject that are not in fromObject
	        2. add every property in fromObject but not in toObject
	        3. properties in toObject that are also in fromObject are updated
	          if one of the following are true:
	          - isFunction fromObject[propName]
	          - isFunction toObject[propName]
	          - !toObject.hasOwnProperty propName
	          - propName does NOT start with "_"
	   */

	  BaseObject.imprintObject = imprintObject = function(toObject, fromObject, preserveState) {
	    var fromValue, k, v;
	    if (preserveState == null) {
	      preserveState = false;
	    }
	    if (!preserveState) {
	      for (k in toObject) {
	        v = toObject[k];
	        if (!fromObject.hasOwnProperty(k)) {
	          delete toObject[k];
	        }
	      }
	    }
	    for (k in fromObject) {
	      fromValue = fromObject[k];
	      if (fromObject.hasOwnProperty(k)) {
	        if (!preserveState || isFunction(fromValue) || isFunction(toObject[k]) || !k.match(/^_/) || !toObject.hasOwnProperty(k)) {
	          toObject[k] = fromValue;
	        }
	      }
	    }
	    return fromObject;
	  };


	  /*
	  imprints both the class and its prototype.
	  
	  preserved in spite of imprintObject's rules:
	    @namespace
	    @::constructor
	   */

	  BaseObject.imprintFromClass = function(updatedKlass) {
	    var _name, namespace, namespacePath, oldConstructor, ref;
	    if (updatedKlass !== this) {
	      ref = this, namespace = ref.namespace, namespacePath = ref.namespacePath, _name = ref._name;
	      oldConstructor = this.prototype.constructor;
	      imprintObject(this, updatedKlass, true);
	      imprintObject(this.prototype, updatedKlass.prototype, false);
	      this.prototype.constructor = oldConstructor;
	      this.namespace = namespace;
	      this.namespacePath = namespacePath;
	      this._name = _name;
	    }
	    return this;
	  };


	  /*
	  IN:
	    _module should be the CommonJS 'module'
	    klass: class object which extends BaseObject
	  
	  liveClass:
	    On the first load, liveClass gets set.
	    Each subsequent hot-load UPDATES liveClass,
	    but liveClass always points to the initially created class object.
	  
	  OUT: the result of the call to liveClass.postCreate()
	  
	  postCreate is passed:
	    hotReloaded:            # true if this is anything but the initial load
	    classModuleState:
	      liveClass:            # the original liveClass
	      hotUpdatedFromClass:  # the most recently hot-loaded class
	      hotReloadVersion:     # number starting at 0 and incremented with each hot reload
	    _module:                # the CommonJs module
	  
	  EFFECTS:
	    The following two methods are invoked on liveClass:
	  
	      if hot-reloading
	        liveClass.imprintFromClass klass
	  
	       * always:
	      liveClass.postCreate hotReloaded, classModuleState, _module
	   */

	  BaseObject.createWithPostCreate = createWithPostCreate = function(a, b) {
	    var _module, klass;
	    klass = b ? (_module = a, b) : a;
	    _module || (_module = getModuleBeingDefined());
	    if (!(klass != null ? klass.postCreate : void 0)) {
	      return klass;
	    }
	    if (!(_module != null ? _module.hot : void 0)) {
	      return klass.postCreate({
	        hotReloadEnabled: false,
	        hotReloaded: false,
	        classModuleState: {},
	        module: _module
	      }) || klass;
	    }
	    return WebpackHotLoader.runHot(_module, function(moduleState) {
	      var classModuleState, hotReloaded, liveClass;
	      if (classModuleState = moduleState[klass.getName()]) {
	        liveClass = classModuleState.liveClass;
	        hotReloaded = true;
	        classModuleState.hotReloadVersion++;
	        classModuleState.hotUpdatedFromClass = klass;
	        liveClass.namespace._setChildNamespaceProps(liveClass.getName(), klass);
	        klass._name = liveClass._name;
	        liveClass.imprintFromClass(klass);
	        Log.log({
	          "Foundation.BaseObject: class hot-reload": {
	            "class": liveClass.getNamespacePath(),
	            version: classModuleState.hotReloadVersion
	          }
	        });
	      } else {
	        hotReloaded = false;
	        klass._hotClassModuleState = moduleState[klass.getName()] = classModuleState = {
	          liveClass: liveClass = klass,
	          hotUpdatedFromClass: null,
	          hotReloadVersion: 0
	        };
	      }
	      return liveClass.postCreate({
	        hotReloadEnabled: true,
	        hotReloaded: hotReloaded,
	        classModuleState: classModuleState,
	        module: _module
	      });
	    });
	  };

	  BaseObject.createHotWithPostCreate = function(a, b) {
	    log.error("createHotWithPostCreate is DEPRICATED");
	    return createWithPostCreate(a, b);
	  };


	  /*
	  called every load
	  IN: options:
	    NOTE: hot-loading inputs are only set if this class created as follows:
	      createHotWithPostCreate module, class Foo extends BaseObject
	  
	    hotReload: true/false
	      true if this class was hot-reloaded
	  
	    hotReloadEnabled: true/false
	  
	    classModuleState:
	      liveClass:            the first-loaded version of the class.
	                            This is the official version of the class at all times.
	                            The hot-reloaded version of the class is "imprinted" onto the liveClass
	                            but otherwise is not used (but can be accessed via classModuleState.hotUpdatedFromClass)
	      hotUpdatedFromClass:  The most recently loaded version of the class.
	      hotReloadVersion:     number, starting at 1, and counting up each load
	  
	      classModuleState is a plain-object specific to the class and its CommonJS module. If there is
	      more than one hot-loaded class in the same module, each will have its own classModuleState.
	  
	      SBD NOTE: Though we could allow clients to add fields to classModuleState, I think it works
	      just as well, and is cleaner, if any state is stored in the actual class objects and
	      persisted via postCreate.
	  
	    module: the CommonJs module object.
	  
	  {hotReloadEnabled, hotReloaded, classModuleState, module} = options
	   */

	  BaseObject.postCreate = function(options) {
	    if (this.getIsAbstractClass()) {
	      return this.postCreateAbstractClass(options);
	    } else {
	      return this.postCreateConcreteClass(options);
	    }
	  };

	  BaseObject.postCreateAbstractClass = function(options) {
	    return this;
	  };

	  BaseObject.postCreateConcreteClass = function(options) {
	    return this;
	  };

	  excludedKeys = ["__super__", "namespace", "namespacePath"].concat(Object.keys(Neptune.Base));

	  BaseObject.mixInto = mixInto = function() {
	    var i, intoClass, k, keys, klass, len, v;
	    intoClass = arguments[0], klass = arguments[1], keys = 3 <= arguments.length ? slice.call(arguments, 2) : [];
	    log.error("DEPRICATED: mixInto");
	    if (keys.length === 0) {
	      keys = Object.keys(klass);
	    }
	    for (i = 0, len = keys.length; i < len; i++) {
	      k = keys[i];
	      if (!(indexOf.call(excludedKeys, k) < 0)) {
	        continue;
	      }
	      v = klass[k];
	      if (intoClass[k]) {
	        log.error("Foundation.mixInto - mix " + (getClassName(klass)) + " into " + (getClassName(intoClass)) + ": " + k + " already exists.");
	      }
	      intoClass[k] = v;
	    }
	    return intoClass;
	  };

	  BaseObject.createAllClass = function() {
	    var All, arg, args, i, len, namespace;
	    namespace = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    log.error("DEPRICATED: createAllClass. Use Neptune-Namespace feature: create file in directory that is the same name as the directory.");
	    for (i = 0, len = args.length; i < len; i++) {
	      arg = args[i];
	      if (arg.prototype instanceof BaseObject) {
	        log.error("createAllClass arguments cannot be subclasses of BaseObject: " + (getClassName(namespace)) + ":" + (getClassName(arg)));
	      }
	      mixInto(namespace, arg);
	    }
	    return All = (function(superClass1) {
	      extend(All, superClass1);

	      function All() {
	        return All.__super__.constructor.apply(this, arguments);
	      }

	      return All;

	    })(namespace);
	  };

	  function BaseObject() {
	    this.__uniqueId = null;
	  }

	  BaseObject.implementsInterface = function(object, methods) {
	    var i, len, method;
	    for (i = 0, len = methods.length; i < len; i++) {
	      method = methods[i];
	      if (typeof object[method] !== "function") {
	        return false;
	      }
	    }
	    return true;
	  };


	  /*
	  mix-in class methods
	  Define getters/setters example:
	    class MyMixin
	      included: ->
	        @getter foo: -> @_foo
	        @setter foo: (v) -> @_foo = v
	  
	  NOTE! This will NOT include any properties you defined with getter or setter!
	  NOTE! This only copies over values if there aren't already values in the included-into class
	    This somewhat mirrors Ruby's include where the included-into-class's methods take precidence.
	    However, if you include two modules in a row, the first module gets priority here.
	    In ruby the second module gets priority (I believe).
	  
	  DEPRICATED!!!
	  Time to do it "right" - and it's just a simple pattern:
	    Justin Fagnani figured this out. Thanks!
	    Read More:
	      http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/
	  
	  To define a mixin:
	  
	    MyMixin = (superClass) ->
	      class MyMixin extends superClass
	        ... write your mixin as-if it were part of the normal inheritance hierachy
	  
	  To use a mixin:
	  
	    class MyClass extends MyMixin MySuperClass
	  
	  To use two mixins:
	  
	    class MyClass extends MyMixin1 MyMixin2 MySuperClass
	   */

	  warnedAboutIncludeOnce = false;

	  BaseObject.include = function(obj) {
	    var key, ref, value;
	    log.error("DEPRICATED: BaseObject.include. Use pattern.");
	    if (!warnedAboutIncludeOnce) {
	      warnedAboutIncludeOnce = true;
	      console.warn("Mixin pattern:\n\n  To define a mixin:\n\n    MyMixin = (superClass) ->\n      class MyMixin extends superClass\n        ... write your mixin as-if it were part of the normal inheritance hierachy\n\n  To use a mixin:\n\n    class MyClass extends MyMixin MySuperClass\n\n  To use two mixins:\n\n    class MyClass extends MyMixin1 MyMixin2 MySuperClass");
	    }
	    for (key in obj) {
	      value = obj[key];
	      if (key !== 'included') {
	        if (!this[key]) {
	          this[key] = value;
	        }
	      }
	    }
	    ref = obj.prototype;
	    for (key in ref) {
	      value = ref[key];
	      if (key) {
	        if (!this.prototype[key]) {
	          this.prototype[key] = value;
	        }
	      }
	    }
	    if (typeof obj.included === "function") {
	      obj.included(this);
	    }
	    return this;
	  };


	  /*
	  Allows you to define properties on the prototype that inherit their data from
	  their super-classes prototype.
	  
	  By default, uses extendClone to init. extendClone has these semantics:
	    Object properties actually create a parallel inheritance structure such that
	      later-changes on the super-object are reflected in the inheriting object.
	      They ARE updated with later parent-changes
	    Array properties inherit the values in the super-class array at declaration time,
	      They ARE NOT updated with any later parent-changes!
	      If we ever need that functionality, we'll need to make a special Object-type
	      that extendClone recognizes that handles the logic of "ExtendableArray".
	   */

	  BaseObject.getPrototypePropertyExtendedByInheritance = function(propertyName, defaultStructure, _clone) {
	    if (_clone == null) {
	      _clone = extendClone;
	    }
	    log.error("DEPRICATED: getPrototypePropertyExtendedByInheritance. use extendableProperty");
	    return getOwnProperty(this.prototype, propertyName, function(object) {
	      return _clone(object[propertyName] || defaultStructure);
	    });
	  };


	  /*
	  IN
	    object: any object
	    property: string, property name
	    init:
	      (object) -> returning initial value for object
	      OR
	        initial value is computed by:
	        clone object[property] || init
	  
	  EFFECT:
	    if object.hasOwnProperty property, return its current value
	    otherwise, initialize and return it with init()
	   */

	  BaseObject.getOwnProperty = getOwnProperty = function(object, property, init) {
	    if (object.hasOwnProperty(property)) {
	      return object[property];
	    } else {
	      return object[property] = isFunction(init) ? init(object) : clone(object[property] || init);
	    }
	  };


	  /*
	  objectPropertyExtender
	  
	  IN: @ is set to the property-value to extend
	  
	  API 1:
	    IN: map
	    EFFECT: mergeInto propValue, map
	  
	  API 2:
	    IN: key, value
	    EFFECT: propValue[key] = valuee
	  
	  OUT: ignore
	   */

	  BaseObject.objectPropertyExtender = objectPropertyExtender = function(mapOrKey, value) {
	    if (isString(mapOrKey)) {
	      return this[mapOrKey] = value;
	    } else if (isPlainObject(mapOrKey)) {
	      return mergeInto(this, mapOrKey);
	    } else {
	      throw new Error("first value argument must be a plain object or string");
	    }
	  };


	  /*
	  arrayPropertyExtender
	  
	  IN: @ is set to the property-value to extend
	  
	  API 1:
	    IN: array
	    EFFECT: concatInto propValue, array
	  
	  API 2:
	    IN: value
	    EFFECT: propValue.push value
	  
	  NOTE: if you want to concat an array-as-a-value to the end of propValue, do this:
	    arrayPropertyExtender.call propValue, [arrayAsValue]
	  
	  OUT: ignore
	   */

	  BaseObject.arrayPropertyExtender = arrayPropertyExtender = function(arrayOrValue) {
	    if (isPlainArray(arrayOrValue)) {
	      return concatInto(this, arrayOrValue);
	    } else {
	      return this.push(arrayOrValue);
	    }
	  };


	  /*
	  Extendable Properties
	  
	  EXAMPLE:
	    class Foo extends BaseObject
	      @extendableProperty foo: {}
	  
	  Extendable properties work like inheritance:
	  
	    When any subclass or instance extends an extendable property, they
	    inherit a clone of the property from up the inheritance tree, and then
	    add their own extensions without effecting the parent copy.
	  
	    With Object property types, this can just be a parallel prototype chain.
	    (It isn't currently: if you modify a parent after extending it to a child,
	    the child won't get updates.)
	  
	    BUT, you can also have array or other types of extend-properties, which
	    JavaScript doesn't have any built-in mechanisms for inheriting.
	  
	  BASIC API:
	  @extendableProperty: (map, propertyExtender = defaultPropertyExtender) -> ...
	  
	  IN: map
	  IN: propertyExtender = (args...) ->
	    IN: @ is propValue
	    IN: 1 or more args
	    EFFECT: modifies propValue (passed as @), extending it, based on args...
	  
	  EFFECT: for each {foo: defaultValue} in map, extendableProperty:
	    defines standard getters:
	      @class.getFoo()
	      @prototype.getFoo()
	      @prototype.foo # getter
	      WARNING:
	        !!! Don't modify the object returned by a getter !!!
	  
	        Getters only return the current, most-extended property value. It may not be extended to the
	        current subclass or instance! Instead, call @extendFoo() if you wish to manually modify
	        the extended property.
	  
	    defines extender functions:
	      @class.extendFoo value      # extends the property on the PROTOTYPE object
	      @prototype.extendFoo value  # extends the property on the INSTANCE object (which inherits from the prototype)
	  
	      EFFECT: extends the property if not already extended
	      OUT: extendedPropValue
	  
	      API 1: IN: 0 args
	      API 2: IN: 1 or more args
	        ADDITIONAL EFFECT: calls: propExtender extendedPropValue, args...
	  
	    NOTE: gthe prototype getters call the class getter for extension purposes.
	      The result is each instance won't get its own version of the property.
	      E.G. Interitance is done at the Class level, not the Instance level.
	   */

	  BaseObject.extendableProperty = function(map, propertyExtender) {
	    var defaultValue, prop, results;
	    results = [];
	    for (prop in map) {
	      defaultValue = map[prop];
	      if (!(isPlainArray(defaultValue) || isPlainObject(defaultValue))) {
	        throw new Error("only plain objects or plain arrays supported for defaultValue");
	      }
	      results.push((function(_this) {
	        return function(prop, defaultValue) {
	          var extenderName, getterName, internalName, propExtender, ucProp;
	          propExtender = propertyExtender || (function() {
	            if (isPlainObject(defaultValue)) {
	              return objectPropertyExtender;
	            } else if (isPlainArray(defaultValue)) {
	              return arrayPropertyExtender;
	            } else {
	              throw new Error("Unsupported property type for extendableProperty: " + (inspect(defaultValue)) + ". Please specify a custom propertyExtender function.");
	            }
	          })();
	          internalName = _this.propInternalName(prop);
	          ucProp = capitalize(prop);
	          getterName = "get" + ucProp;
	          extenderName = "extend" + ucProp;
	          _this[getterName] = function() {
	            return this.prototype[internalName] || defaultValue;
	          };
	          _this.addGetter(prop, function() {
	            return this[internalName] || defaultValue;
	          });
	          _this[extenderName] = function(value) {
	            var propValue;
	            propValue = getOwnProperty(this.prototype, internalName, defaultValue);
	            if (arguments.length > 0) {
	              propExtender.apply(propValue, arguments);
	            }
	            return propValue;
	          };
	          return _this.prototype[extenderName] = function(value) {
	            var propValue;
	            propValue = getOwnProperty(this, internalName, defaultValue);
	            if (arguments.length > 0) {
	              propExtender.apply(propValue, arguments);
	            }
	            return propValue;
	          };
	        };
	      })(this)(prop, defaultValue));
	    }
	    return results;
	  };

	  BaseObject.getNamespacePath = function() {
	    var ref;
	    if (!this.namespacePath) {
	      return this.namespacePath = (this.getName()) + " extends " + (this.__super__["class"].getNamespacePath());
	    } else if (((ref = this.__super__) != null ? ref["class"].namespacePath : void 0) === this.namespacePath) {
	      return this.namespacePath = (this.getName()) + " extends " + (this.__super__["class"].getNamespacePath());
	    } else {
	      return this.namespacePath;
	    }
	  };

	  BaseObject.getClassName = function(klass) {
	    if (klass == null) {
	      klass = this;
	    }
	    return (typeof klass.getName === "function" ? klass.getName() : void 0) || klass.name;
	  };


	  /*
	  inspect: ->
	  IN: ()
	  OUT: string
	  
	  Can override with same or alternate, recursion-block-supported signature:
	    IN: (inspector) ->
	    OUT: if inspector then null else string
	  
	    To handle the case where the inspector is not set, we
	    recommneded declaring your 'inspect' as follows:
	      inspect: (inspector) ->
	        return Foundation.inspect @ unless inspector
	         * ...
	         * custom code which writes all output to inspector.put
	         * and uses inspector.inspect for inspecting sub-objects
	         * ...
	        null
	  
	    EFFECT:
	      call inspector.put one or multiple times with strings to add to the inspected output
	      call inspector.inspect foo to sub-inspect other objects WITH RECURSION BLOCK
	  
	   * Example 1:
	  inspect: (inspector) ->
	    return Foundation.inspect @ unless inspector
	    inspector.put @getNamespacePath()
	  
	   * Example 2:
	  inspect: ->
	    @getNamespacePath()
	   */

	  BaseObject.inspect = function() {
	    return this.getNamespacePath();
	  };

	  BaseObject.prototype.inspect = function() {
	    return "<" + this["class"].namespacePath + ">";
	  };


	  /*
	  getInspectedObjects: -> plainObjects
	  
	  usually implemented this way:
	  @getter inspectedObjects: -> plainObjects or objects which implement "inspect"
	  
	  TODO: I think I want to refactor inspectedObjects to ONLY return near-JSON-compatible objects:
	    1. strings
	    2. maps
	    3. arrays
	  
	    Everything else should be rendered to a string. In general, strings should Eval to the object
	    they represent:
	  
	      toInspectedObject(null):                    'null' # null becomes a string
	      toInspectedObject(true):                    'true' # true becomes a string
	      toInspectedObject(false):                   'false' # false becomes a string
	      toInspectedObject(undefined):               'undefined' # undefined becomes a string
	      toInspectedObject('hi'):                    '"hi"' # ESCAPED
	      toInspectedObject((a) -> a):                'function(a){return a;}'
	      toInspectedObject(rgbColor())               "rgbColor('#000000')"
	  
	    NOTE: inspectedObjects differs from plainObjects. The latter should be 100% JSON,
	      and should return actual values where JSON allows, otherwise, return JSON data structures
	      that encode the object's information in a human-readable format, ideally one that can be
	      used as an input to the constructor of the object's class to recreate the original object.
	  
	      plainObjects:
	        null:         null
	        true:         true
	        false:        false
	        'str':        'str' # NOT escaped
	        undefined:    null
	        ((a) -> a):   'function(a){return a;}'
	        rgbColor():   r: 0, g: 0, b: 0, a: 0
	  
	  You can provide this function for fine-grained control of what Inspector2 outputs and hence
	  what DomConsole displays.
	  
	  If you would like for a string to appear without quotes, use:
	    {inspect: -> 'your string without quotes here'}
	   */

	  BaseObject.getter({
	    inspectObjects: function() {
	      console.warn("inspectObjects/getInspectObjects is DEPRICATED. Use: inspectedObjects/getInspectedObjects");
	      return this.getInspectedObjects();
	    },
	    inspectedObjects: function() {
	      return inspectedObjectLiteral("<" + (this["class"].getNamespacePath()) + ">");
	    }
	  });

	  BaseObject.classGetter({
	    inspectedObjects: function() {
	      return inspectedObjectLiteral(this.getNamespacePath());
	    }
	  });


	  /*
	  Define this class as an abstract class. Implicitly it means
	  any class it extends is also abstract, at least in this context.
	  
	  Definition: Abstract classes are not intended to every be instantiated.
	    i.e.: never do: new MyAbstractClass
	  
	  TODO: in Debug mode, in the constructor:
	    throw new Error "cannot instantiate abstract classes" if @class.getIsAbstractClass()
	   */

	  BaseObject.abstractClass = function() {
	    if (this.getIsSingletonClass()) {
	      throw new Error("abstract classes cannot also be singleton");
	    }
	    return this._firstAbstractAncestor = this;
	  };

	  BaseObject.classGetter({
	    isAbstractClass: function() {
	      return !(this.prototype instanceof this._firstAbstractAncestor);
	    },
	    abstractPrototype: function() {
	      return this._firstAbstractAncestor.prototype;
	    },
	    firstAbstractAncestor: function() {
	      return this._firstAbstractAncestor;
	    },
	    isSingletonClass: function() {
	      return !!this.getSingleton;
	    }
	  });

	  BaseObject.getAbstractClass = function() {
	    return this._firstAbstractAncestor;
	  };

	  BaseObject.abstractClass();

	  BaseObject.propertyIsAbstract = function(methodName) {
	    return this.getAbstractClass().prototype[methodName] === this.prototype[methodName];
	  };

	  BaseObject.propertyIsConcrete = function(methodName) {
	    return this.getAbstractClass().prototype[methodName] !== this.prototype[methodName];
	  };


	  /*
	  creates the classGetter "singleton" which returns a single instance of the current class.
	  
	  IN: args are passed to the singleton constructor
	  OUT: null
	  
	  The singleton instance is created on demand the first time it is accessed.
	   */

	  BaseObject.singletonClass = function() {
	    var args, map;
	    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    if (this.getIsAbstractClass()) {
	      throw new Error("singleton classes cannot be abstract");
	    }
	    map = {
	      singleton: function() {
	        var ref;
	        if (((ref = this._singleton) != null ? ref["class"] : void 0) === this) {
	          return this._singleton;
	        } else {
	          return this._singleton = (function(func, args, ctor) {
	            ctor.prototype = func.prototype;
	            var child = new ctor, result = func.apply(child, args);
	            return Object(result) === result ? result : child;
	          })(this, args, function(){});
	        }
	      }
	    };
	    map[decapitalize(functionName(this))] = function() {
	      return this.getSingleton();
	    };
	    this.classGetter(map);
	    return null;
	  };

	  BaseObject.getter({
	    className: function() {
	      return this["class"].getClassName();
	    },
	    "class": function() {
	      return this.constructor;
	    },
	    keys: function() {
	      return Object.keys(this);
	    },
	    namespacePath: function() {
	      return this["class"].getNamespacePath();
	    },
	    classPathNameAndId: function() {
	      return this.classPathName + ":" + this.objectId;
	    },
	    uniqueId: function() {
	      return this.__uniqueId || (this.__uniqueId = nextUniqueObjectId());
	    },
	    objectId: function() {
	      return this.__uniqueId || (this.__uniqueId = nextUniqueObjectId());
	    }
	  });

	  BaseObject.prototype.implementsInterface = function(methods) {
	    return Function.BaseObject.implementsInterface(this, methods);
	  };

	  BaseObject.prototype.tap = function(f) {
	    f(this);
	    return this;
	  };

	  BaseObject.rawLog = function() {
	    return Log.rawLog.apply(Log, arguments);
	  };

	  BaseObject.log = function() {
	    var a, stack, toLog;
	    stack = callStack();
	    toLog = (function() {
	      var i, len, results;
	      if (arguments.length > 1) {
	        results = [];
	        for (i = 0, len = arguments.length; i < len; i++) {
	          a = arguments[i];
	          results.push(a);
	        }
	        return results;
	      } else {
	        return arguments[0];
	      }
	    }).apply(this, arguments);
	    Log.logCore(toLog, stack, {
	      className: this.className
	    });
	    return arguments[arguments.length - 1];
	  };

	  BaseObject.prototype.log = BaseObject.log;

	  BaseObject.prototype.rawLog = BaseObject.rawLog;

	  return BaseObject;

	})(MinimalBaseObject);


/***/ },
/* 82 */
/***/ function(module, exports) {

	var WebpackHotLoader;

	module.exports = WebpackHotLoader = (function() {
	  function WebpackHotLoader() {}


	  /*
	  IN:
	    _module should be the CommonJS 'module'
	    modulePostLoadAction: (moduleState) -> ignored internally, returned from @runHot
	  
	  OUT: modulePostLoadAction moduleState
	  
	  EFFECT:
	    modulePostLoadAction is run every time the module is loaded.
	  
	    Initially, moduleState is {}.
	  
	    moduleState is the same object every load:
	      modulePostLoadAction can modify moduleState and it will persist through every reload.
	  
	    modulePostLoadAction is responsible for any and all
	    update actions required due to the module load.
	  
	  NOTE:
	    If _module is not hot, modulePostLoadAction will be invoked once with an empty {}.
	   */

	  WebpackHotLoader.runHot = function(_module, modulePostLoadAction) {
	    var base, moduleState;
	    if (!(_module != null ? _module.hot : void 0)) {
	      return modulePostLoadAction({});
	    }
	    moduleState = (((base = _module.hot).data || (base.data = {
	      moduleState: {}
	    }))).moduleState;
	    _module.hot.accept();
	    _module.hot.dispose(function(data) {
	      return data.moduleState = moduleState;
	    });
	    return modulePostLoadAction(moduleState);
	  };

	  return WebpackHotLoader;

	})();


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, Binary, ClassSystem, Stream, binary,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ClassSystem = __webpack_require__(78);

	Binary = __webpack_require__(72);

	BaseObject = ClassSystem.BaseObject;

	binary = __webpack_require__(76).binary;

	module.exports = Stream = (function(superClass) {
	  extend(Stream, superClass);

	  Stream.stream = function(arg) {
	    if (arg instanceof Stream) {
	      return arg;
	    } else if (arg instanceof ArrayBuffer) {
	      return Stream.fromArrayBuffer(arg);
	    } else if (arg instanceof Uint8Array) {
	      return new Stream(arg);
	    } else {
	      return new Stream(binary(arg).bytes);
	    }
	  };

	  Stream.fromArrayBuffer = function(arrayBuffer) {
	    return new Stream(new Uint8Array(arrayBuffer, 0, arrayBuffer.byteLength));
	  };

	  function Stream(byteView) {
	    this.byteView = byteView;
	    this.pos = 0;
	  }

	  Stream.prototype.readByte = function() {
	    return this.byteView[this.pos++];
	  };

	  Stream.prototype.readAsi = function() {
	    var ret, shift, val;
	    ret = 0;
	    shift = 0;
	    val = 128;
	    while (val >= 128) {
	      val = this.readByte();
	      ret += (val % 128) << shift;
	      shift += 7;
	    }
	    return ret;
	  };

	  Stream.prototype.uint8Array = function() {
	    return this.byteView;
	  };

	  Stream.prototype.read = function(length) {
	    var begin, end;
	    begin = this.pos;
	    this.pos += length;
	    end = this.pos;
	    return new Stream(this.byteView.subarray(begin, end));
	  };

	  Stream.prototype.inspect = function() {
	    return "{Stream pos=" + this.pos + " byteOffset=" + this.byteView.byteOffset + " length=" + this.byteView.length + "}";
	  };

	  Stream.prototype.readAsiString = function() {
	    return this.read(this.readAsi());
	  };

	  Stream.prototype.done = function() {
	    return this.pos >= this.byteView.length;
	  };

	  Stream.getter({
	    isDone: function() {
	      return this.pos >= this.byteView.length;
	    },
	    binaryString: function() {
	      return binary(this.byteView);
	    },
	    inspectedString: function() {
	      return this.binaryString.inspectedString;
	    }
	  });

	  Stream.prototype.toString = function() {
	    return this.binaryString.toString();
	  };

	  return Stream;

	})(BaseObject);


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var DataUri, Promise, StandardLib, binary, isString, readAsDataURL;

	StandardLib = __webpack_require__(29);

	binary = __webpack_require__(76).binary;

	readAsDataURL = __webpack_require__(75).readAsDataURL;

	Promise = StandardLib.Promise, isString = StandardLib.isString;

	module.exports = DataUri = (function() {
	  var isDataUri;

	  function DataUri() {}

	  DataUri.isDataUri = isDataUri = function(dataString) {
	    return isString(dataString) && dataString.slice(0, 5) === "data:";
	  };


	  /*
	  IN: data can be any of
	    File: HTML File object is read as ArrayBuffer
	    DataURI string: if it is already a data-uri string it is just returned as a successful promise
	    any type 'binary' accepts
	  
	  OUT:
	    promise.then (dataUri) ->
	    , (errorEventOrErrorObject) ->
	   */

	  DataUri.toDataUri = function(data) {
	    if (!data) {
	      throw new Error("data not set");
	    }
	    if (data instanceof self.File) {
	      return readAsDataURL(data);
	    }
	    if (isDataUri(data)) {
	      return Promise.resolve(data);
	    }
	    return binary(data).toBase64().then(function(base64) {
	      return "data:image/png;base64," + base64;
	    });
	  };

	  return DataUri;

	})();


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var EncodedImage, Promise, StandardLib, readFileAsDataUrl, toDataUri;

	StandardLib = __webpack_require__(29);

	toDataUri = __webpack_require__(84).toDataUri;

	Promise = StandardLib.Promise, readFileAsDataUrl = StandardLib.readFileAsDataUrl;

	module.exports = EncodedImage = (function() {
	  var get;

	  function EncodedImage() {}


	  /*
	  OUT:
	    promise.then (fullyLoadedHtmlImage) ->
	    , (htmlImageOnerrorEvent) ->
	   */

	  EncodedImage.get = get = function(url, options) {
	    return Promise.resolve().then(function() {
	      if (options) {
	        return Neptune.Art.Foundation.RestClient.getArrayBuffer(url, options).then(function(arrayBuffer) {
	          return readFileAsDataUrl(new Blob([arrayBuffer]));
	        }).then((function(_this) {
	          return function(dataUri) {
	            return url = dataUri;
	          };
	        })(this));
	      }
	    }).then(function() {
	      return new Promise(function(resolve, reject) {
	        var image;
	        image = new Image;
	        if (!url.match(/^(file|data)\:/i)) {
	          image.crossOrigin = "Anonymous";
	        }

	        /*
	        crossOrigin = "Anonymous" required to getImageData and avoid this error
	          "The canvas has been tainted by cross-origin data."
	        
	        NOTE:
	          file: urls break with crossOrigin in WkWebKit
	          data: urls break with crossOrigin in Safari
	         */
	        image.onload = function() {
	          return resolve(image);
	        };
	        image.onerror = reject;
	        return image.src = url;
	      });
	    });
	  };

	  EncodedImage.loadImage = function(url) {
	    console.warn(this.namespacePath + "#loadImage DEPRICATED. Use #get");
	    return get(url);
	  };

	  EncodedImage.toImage = function(encodedImageData) {
	    return toDataUri(encodedImageData).then((function(_this) {
	      return function(dataUri) {
	        return get(dataUri);
	      };
	    })(this));
	  };

	  return EncodedImage;

	})();


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, ClassSystem, Promise, StandardLib, WriteStream, binary, bound, bufferSize, log, readFileAsArrayBuffer,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	StandardLib = __webpack_require__(29);

	ClassSystem = __webpack_require__(78);

	binary = __webpack_require__(76).binary;

	Promise = StandardLib.Promise, readFileAsArrayBuffer = StandardLib.readFileAsArrayBuffer, bound = StandardLib.bound;

	BaseObject = ClassSystem.BaseObject, log = ClassSystem.log;

	bufferSize = 1024;

	module.exports = WriteStream = (function(superClass) {
	  extend(WriteStream, superClass);

	  function WriteStream() {
	    this._written = [];
	    this._writeBuffer = new Uint8Array(bufferSize);
	    this._pos = 0;
	    this._writtenLength = 0;
	  }

	  WriteStream.prototype.writeByte = function(byte) {
	    if (this._pos === bufferSize) {
	      this._commitHead();
	    }
	    return this._writeBuffer[this._pos++] = byte;
	  };

	  WriteStream.prototype.writeAsi = function(number) {
	    var nextByte, results;
	    if (!(number >= 0)) {
	      throw new Error("expected number >= 0");
	    }
	    results = [];
	    while (true) {
	      nextByte = number & 0x7F;
	      number >>= 7;
	      if (number > 0) {
	        results.push(this.writeByte(nextByte | 0x80));
	      } else {
	        this.writeByte(nextByte);
	        break;
	      }
	    }
	    return results;
	  };

	  WriteStream.prototype.write = function(string) {
	    var binaryString;
	    binaryString = binary(string);
	    if (this._pos + binaryString.length <= bufferSize) {
	      this._writeBuffer.set(binaryString.uint8Array, this._pos);
	      return this._pos += binaryString.length;
	    } else {
	      this._commitHead();
	      this._writtenLength += binaryString.length;
	      return this._written.push(binaryString.uint8Array);
	    }
	  };

	  WriteStream.prototype.writeAsiString = function(string) {
	    var binaryString;
	    binaryString = binary(string);
	    this.writeAsi(binaryString.length);
	    return this.write(binaryString);
	  };

	  WriteStream.getter({
	    arrayBufferPromise: function() {
	      return this._compact().then(function(uint8Array) {
	        return uint8Array.buffer;
	      });
	    },
	    binaryStringPromise: function() {
	      return this.arrayBufferPromise.then(function(ab) {
	        return binary(ab);
	      });
	    },
	    length: function() {
	      return this._pos + this._writtenLength;
	    }
	  });


	  /*
	  Using new Blob is much faster, thus we use Promises since it is async
	    http://jsperf.com/appending-arraybuffers
	  
	  OUT: promise.then (compactedUint8Array) ->
	  EFFECT:
	    head was committed
	    if @_written.length <= 1 then it isn't changed
	    else @_written = [compactedUint8Array]
	   */

	  WriteStream.prototype._compact = function() {
	    this._commitHead();
	    switch (this._written.length) {
	      case 0:
	        return new Promise(function(resolve) {
	          return resolve(new Uint8Array(0));
	        });
	      case 1:
	        return new Promise((function(_this) {
	          return function(resolve) {
	            return resolve(_this._written[0]);
	          };
	        })(this));
	      default:
	        return readFileAsArrayBuffer(new Blob(this._written)).then((function(_this) {
	          return function(ab) {
	            _this._written = [new Uint8Array(ab)];
	            return _this._written[0];
	          };
	        })(this));
	    }
	  };

	  WriteStream.prototype._commitHead = function() {
	    if (!(this._pos > 0)) {
	      return;
	    }
	    this._writtenLength += this._pos;
	    this._written.push(this._writeBuffer.slice(0, this._pos));
	    return this._pos = 0;
	  };

	  return WriteStream;

	})(BaseObject);


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(88).includeInNamespace(__webpack_require__(89)).addModules({
	  Analytics: __webpack_require__(95),
	  AsyncLocalStorage: __webpack_require__(96),
	  BatchLoader: __webpack_require__(98),
	  CommunicationStatus: __webpack_require__(99),
	  DateFormat: __webpack_require__(94),
	  Epoch: __webpack_require__(100),
	  GlobalCounts: __webpack_require__(92),
	  InstanceFunctionBindingMixin: __webpack_require__(101),
	  JsonStore: __webpack_require__(102),
	  ObjectTreeFactory: __webpack_require__(93),
	  ProgressAdapter: __webpack_require__(90),
	  RestClient: __webpack_require__(103),
	  SingleObjectTransaction: __webpack_require__(104),
	  Stat: __webpack_require__(105),
	  Transaction: __webpack_require__(106),
	  Validator: __webpack_require__(107),
	  WebWorker: __webpack_require__(91),
	  WorkerRpc: __webpack_require__(97)
	});


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var Foundation, Tools,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(26);

	module.exports = Foundation.Tools || Foundation.addNamespace('Tools', Tools = (function(superClass) {
	  extend(Tools, superClass);

	  function Tools() {
	    return Tools.__super__.constructor.apply(this, arguments);
	  }

	  return Tools;

	})(Neptune.Base));


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [[__webpack_require__(90), "executePromiseSequence"], __webpack_require__(91), __webpack_require__(92), __webpack_require__(93), __webpack_require__(94)];


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, ClassSystem, ProgressAdapter, StandardLib, isArray, isFunction, isNumber, log, max, min,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	StandardLib = __webpack_require__(29);

	ClassSystem = __webpack_require__(78);

	BaseObject = ClassSystem.BaseObject;

	isNumber = StandardLib.isNumber, isFunction = StandardLib.isFunction, isArray = StandardLib.isArray, log = StandardLib.log, max = StandardLib.max, min = StandardLib.min;

	module.exports = ProgressAdapter = (function(superClass) {
	  extend(ProgressAdapter, superClass);


	  /*
	  IN:
	    stepWeights can be a positive integer or an aray of positive, real numbers.
	  
	      integer N: specifies progress will be made in N even steps from 0 to 1
	  
	      array of numbers A: specifies progress will be made in A.length steps which
	        may not be even. Each step has its own "weight."
	  
	        Example: stepWeights = [850, 50, 100]
	        Will become:
	          steps:
	            0: 0.00 to 0.85
	            1: 0.85 to 0.90
	            2: 0.90 to 1.00
	  
	        Example: stepWeights = [1, 2, 1]
	        Will become:
	          steps:
	            0: 0.00 to 0.25
	            1: 0.25 to 0.75
	            2: 0.75 to 1.00
	  
	    progressCallback: progressCallback is a function which is invoked with a number
	      between 0 and 1. It is invoked immediatly with 0, then it is invoked by makeProgress()
	      and makeProgressCallback()(). It always increments or stays the same. It will
	      never go backwards.
	   */

	  function ProgressAdapter(stepWeights, progressCallback1) {
	    this.stepWeights = stepWeights;
	    this.progressCallback = progressCallback1;
	    if (!(isFunction(this.progressCallback) && (isArray(this.stepWeights) || isNumber(this.stepWeights)))) {
	      throw new Error("invalid params");
	    }
	    this._currentStep = 0;
	    this._generateSteps();
	    this._currentProgress = 0;
	    this._warningCount = 0;
	    this.setCurrentProgress(0);
	  }

	  ProgressAdapter.getter("steps currentStep currentProgress warningCount", {
	    currentProgressPercent: function() {
	      return (this._currentProgress * 100 | 0) + "%";
	    },
	    currentProgressBase: function() {
	      if (this._currentStep <= 0) {
	        return 0;
	      } else if (this._currentStep >= this._steps.length) {
	        return 1;
	      } else {
	        return this._steps[this._currentStep];
	      }
	    }
	  });

	  ProgressAdapter.setter({
	    currentProgress: function(p) {
	      return typeof this.progressCallback === "function" ? this.progressCallback(min(1, this._currentProgress = max(p, this._currentProgress))) : void 0;
	    }
	  });

	  ProgressAdapter.prototype.makeProgress = function() {
	    this._currentStep++;
	    if (this._currentStep > this._steps.length) {
	      this._warningCount++;
	      console.warn("ProgressAdapter: makeProgress/Callback called too many times!", {
	        currentStep: this._currentStep,
	        steps: this._steps,
	        stepWeights: this.stepWeights
	      });
	    }
	    return this.setCurrentProgress(this.currentProgressBase);
	  };

	  ProgressAdapter.prototype.makeProgressCallback = function() {
	    var rangeEnd, rangeStart;
	    this._finishLastProgress();
	    rangeStart = this.currentProgressBase;
	    this._currentStep++;
	    rangeEnd = this.currentProgressBase;
	    return (function(_this) {
	      return function(progress) {
	        return _this.setCurrentProgress(rangeStart + (rangeEnd - rangeStart) * progress);
	      };
	    })(this);
	  };

	  ProgressAdapter.prototype._finishLastProgress = function() {
	    var progress;
	    if (this._currentProgress < (progress = this.currentProgressBase)) {
	      return this.setCurrentProgress(progress);
	    }
	  };

	  ProgressAdapter.prototype._executePromiseSequence = function(sequence, lastResult, index, resolve) {
	    if (index >= sequence.length) {
	      this._finishLastProgress();
	      return resolve(lastResult);
	    }
	    return Promise.resolve(sequence[index](lastResult, this.makeProgressCallback())).then((function(_this) {
	      return function(nextResult) {
	        return _this._executePromiseSequence(sequence, nextResult, index + 1, resolve);
	      };
	    })(this));
	  };

	  ProgressAdapter.prototype.executePromiseSequence = function(sequence) {
	    return new Promise((function(_this) {
	      return function(resolve) {
	        return _this._executePromiseSequence(sequence, null, 0, resolve);
	      };
	    })(this));
	  };


	  /*
	  IN: (progressCallback, promiseSequence) ->
	     * stepWeights implicitly == promiseSequence.length
	  IN: (progressCallback, stepWeights, promiseSequence) ->
	   */

	  ProgressAdapter.executePromiseSequence = function(progressCallback, a, b) {
	    var pa, sequence, weights;
	    if (b) {
	      weights = a;
	      sequence = b;
	    } else {
	      sequence = a;
	      weights = sequence.length;
	    }
	    pa = new ProgressAdapter(weights, progressCallback);
	    return pa.executePromiseSequence(sequence);
	  };

	  ProgressAdapter.prototype._generateSteps = function() {
	    var i, j, len, numSteps, ref, s, step, total, w;
	    if (isNumber(numSteps = this.stepWeights)) {
	      return this._steps = (function() {
	        var j, ref, results;
	        results = [];
	        for (i = j = 0, ref = numSteps; j < ref; i = j += 1) {
	          results.push(i / numSteps);
	        }
	        return results;
	      })();
	    } else {
	      total = 0;
	      ref = this.stepWeights;
	      for (j = 0, len = ref.length; j < len; j++) {
	        w = ref[j];
	        total += w;
	      }
	      step = 0;
	      return this._steps = (function() {
	        var k, len1, ref1, results;
	        ref1 = this.stepWeights;
	        results = [];
	        for (k = 0, len1 = ref1.length; k < len1; k++) {
	          w = ref1[k];
	          s = step;
	          step += w / total;
	          results.push(s);
	        }
	        return results;
	      }).call(this);
	    }
	  };

	  return ProgressAdapter;

	})(BaseObject);


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var StandardLib, WebWorker, log;

	StandardLib = __webpack_require__(29);

	log = StandardLib.log;


	/*
	SRC:
	  http://jsfiddle.net/uqcFM/49/
	  http://stackoverflow.com/a/10372280/2121000
	 */

	module.exports = WebWorker = (function() {
	  var startWorkerFromJsString;

	  function WebWorker() {}

	  WebWorker.echoWebWorker = "self.onmessage=function(e){postMessage('Worker: '+e.data);}";

	  WebWorker.isBrowser = !!(self.window && self.navigator && self.document);

	  WebWorker.isWebWorker = !WebWorker.isBrowser && self.importScripts;

	  WebWorker.startWorkerFromJsString = startWorkerFromJsString = function(workerSource) {
	    return new Worker(URL.createObjectURL(new Blob([workerSource], {
	      type: 'application/javascript'
	    })));
	  };

	  WebWorker.startWorkerFromFunction = function(workerFunction) {
	    return startWorkerFromJsString("(" + workerFunction + ")();");
	  };

	  return WebWorker;

	})();


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	var GlobalCounts, StandardLib, currentSecond, isPlainObject, log;

	StandardLib = __webpack_require__(29);

	isPlainObject = StandardLib.isPlainObject, currentSecond = StandardLib.currentSecond, log = StandardLib.log;

	module.exports = GlobalCounts = (function() {
	  var globalTime;

	  function GlobalCounts() {}

	  GlobalCounts.globalCounts = {};

	  globalTime = null;

	  GlobalCounts.resetGlobalCounts = function() {
	    globalTime = currentSecond();
	    return GlobalCounts.globalCounts = {};
	  };

	  GlobalCounts.globalCount = function(name, amount) {
	    var k, last, results, v;
	    if (amount == null) {
	      amount = 1;
	    }
	    if (isPlainObject(amount)) {
	      if (last = GlobalCounts.globalCounts[name]) {
	        results = [];
	        for (k in amount) {
	          v = amount[k];
	          results.push(last[k] += v);
	        }
	        return results;
	      } else {
	        return GlobalCounts.globalCounts[name] = amount;
	      }
	    } else {
	      return GlobalCounts.globalCounts[name] = (GlobalCounts.globalCounts[name] || 0) + amount;
	    }
	  };

	  GlobalCounts.countStep = function() {
	    var nextTime;
	    nextTime = currentSecond();
	    if (nextTime - globalTime > .002) {
	      log.error("GlobalCounts gap");
	    }
	    globalTime = nextTime;
	    return GlobalCounts.globalCount("step");
	  };

	  return GlobalCounts;

	})();


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var ObjectTreeFactory, compactFlatten, fastBind, isFunction, mergeIntoBasic, ref, upperCamelCase;

	ref = __webpack_require__(12), compactFlatten = ref.compactFlatten, upperCamelCase = ref.upperCamelCase;

	mergeIntoBasic = function(into, source) {
	  var k, v;
	  for (k in source) {
	    v = source[k];
	    into[k] = v;
	  }
	  return into;
	};

	isFunction = __webpack_require__(34).isFunction;

	fastBind = __webpack_require__(41).fastBind;

	module.exports = ObjectTreeFactory = (function() {
	  var compactFlattenObjectTreeNodeNames, deepArgsProcessing, nodeNameRegexp, preprocessElementBasic;

	  function ObjectTreeFactory() {}

	  deepArgsProcessing = function(array, children) {
	    var el, i, len;
	    for (i = 0, len = array.length; i < len; i++) {
	      el = array[i];
	      if (el) {
	        if (el.constructor === Array) {
	          deepArgsProcessing(el, children);
	        } else {
	          children.push(el);
	        }
	      }
	    }
	    return null;
	  };


	  /*
	  IN:
	    options:
	      mergePropsInto: (props, ...) ->
	        function to merge arguments 1 on into props
	        default: mergeIntoBasic
	  
	      inspectedName: string
	        for introspection:
	          Factory.getName() == inspectedName
	  
	      class: a class
	        if specified, additioanl properties will be set on the Factory function:
	          Factory.class = class
	          Factory._name = class.getName() + "Factory"
	  
	          all concrete class-methods are made available in the Factory
	          (see BaseObject.abstractClass)
	  
	      bind: string or array of strings
	        NODE: class must be set
	        list of method-names to bind from class onto the factory
	  
	      preprocessElement: (element) -> element
	        can do custom preprocssing of each argument to the factory.
	  
	  
	        defualt: preprocessElementBasic (no-op)
	    nodeFactory: ->
	      IN:
	        props:    plain object mapping props to prop-values
	        children: flat, compacted array of children nodes
	      OUT:
	        node
	  
	  OUT: objectTreeFactory = ->
	    IN:
	      Arguments are compacted and flattened
	      The resulting list of arguments can be any combination of:
	        plainObjects for props (merged in the order they appear)
	        other objects which become the 'children'
	  
	    OUT:
	      object-tree-node generated by the nodeFactory
	   */

	  preprocessElementBasic = function(a) {
	    return a;
	  };

	  ObjectTreeFactory.createObjectTreeFactory = function(options, nodeFactory) {
	    var Factory, abstractClass, bindList, i, inspectedName, k, klass, len, mergePropsInto, preprocessElement, v;
	    if (!nodeFactory) {
	      nodeFactory = options;
	      options = {};
	    }
	    mergePropsInto = options.mergePropsInto, inspectedName = options.inspectedName, preprocessElement = options.preprocessElement;
	    mergePropsInto || (mergePropsInto = mergeIntoBasic);
	    preprocessElement || (preprocessElement = preprocessElementBasic);
	    Factory = function() {
	      var children, el, i, len, oneProps, props;
	      oneProps = null;
	      props = null;
	      children = [];
	      for (i = 0, len = arguments.length; i < len; i++) {
	        el = arguments[i];
	        if (el = preprocessElement(el)) {
	          switch (el.constructor) {
	            case Object:
	              if (oneProps) {
	                props = {};
	                mergePropsInto(props, oneProps);
	                oneProps = null;
	              }
	              if (props) {
	                mergePropsInto(props, el);
	              } else {
	                oneProps = el;
	              }
	              break;
	            case Array:
	              deepArgsProcessing(el, children);
	              break;
	            default:
	              children.push(el);
	          }
	        }
	      }
	      props || (props = oneProps || {});
	      return nodeFactory(props, children);
	    };
	    if (klass = options["class"]) {
	      Factory["class"] = klass;
	      abstractClass = klass.getAbstractClass();
	      bindList = compactFlatten([
	        (function() {
	          var results;
	          results = [];
	          for (k in klass) {
	            v = klass[k];
	            if (!abstractClass[k] && isFunction(v)) {
	              results.push(k);
	            }
	          }
	          return results;
	        })(), options.bind
	      ]);
	      inspectedName || (inspectedName = klass.getName() + "Factory");
	      for (i = 0, len = bindList.length; i < len; i++) {
	        k = bindList[i];
	        Factory[k] = fastBind(klass[k], klass);
	      }
	    }
	    if (inspectedName) {
	      Factory._name = inspectedName;
	    }
	    Factory.inspect = function() {
	      return "<" + (inspectedName || 'ObjectTreeFactory') + ">";
	    };
	    return Factory;
	  };


	  /*
	  IN:
	    list: a string or abitrary structure of arrays, nulls and strings
	      each string is split into tokens and each token is used as the nodeTypeName to create a Tree-factory
	    nodeFactory: (nodeTypeName, props, children) -> node
	      IN:
	        nodeTypeName: node-type name
	        props:    plain object mapping props to prop-values
	        children: flat, compacted array of children nodes
	      OUT:
	        node
	  OUT:
	    map from nodeNames (upperCamelCased) to the factories returned from createObjectTreeFactory
	  
	  TODO:
	    PERFORMANCE TEST:
	      createObjectTreeFactoriesFromFactories
	      vs
	      createObjectTreeFactoriesFromFactoryFactories
	  
	      The latter is probably faster. It is also more powerful and generally cleaner.
	   */

	  ObjectTreeFactory.createObjectTreeFactories = function(options, list, nodeFactory) {
	    var ref1;
	    if (!nodeFactory) {
	      ref1 = [options, list], list = ref1[0], nodeFactory = ref1[1];
	      options = {};
	    }
	    if (nodeFactory.length === 1) {
	      return ObjectTreeFactory._createObjectTreeFactoriesFromFactoryFactories(options, list, nodeFactory);
	    } else {
	      return ObjectTreeFactory._createObjectTreeFactoriesFromFactories(options, list, nodeFactory);
	    }
	  };

	  ObjectTreeFactory._createObjectTreeFactoriesFromFactories = function(options, list, nodeFactory) {
	    var fn, i, len, nodeTypeName, out, ref1, suffix;
	    suffix = options.suffix || '';
	    out = {};
	    ref1 = compactFlattenObjectTreeNodeNames(list);
	    fn = function(nodeTypeName) {
	      options.inspectedName = nodeTypeName;
	      return out[upperCamelCase(nodeTypeName) + suffix] = ObjectTreeFactory.createObjectTreeFactory(options, function(props, children) {
	        return nodeFactory(nodeTypeName, props, children);
	      });
	    };
	    for (i = 0, len = ref1.length; i < len; i++) {
	      nodeTypeName = ref1[i];
	      fn(nodeTypeName);
	    }
	    return out;
	  };

	  nodeNameRegexp = /[a-z0-9_]+/ig;

	  ObjectTreeFactory._compactFlattenObjectTreeNodeNames = compactFlattenObjectTreeNodeNames = function(list) {
	    var i, len, out, ref1, str;
	    if (typeof list === "string") {
	      return list.match(nodeNameRegexp);
	    }
	    out = [];
	    ref1 = compactFlatten(list);
	    for (i = 0, len = ref1.length; i < len; i++) {
	      str = ref1[i];
	      out = out.concat(str.match(nodeNameRegexp));
	    }
	    return out;
	  };

	  ObjectTreeFactory._createObjectTreeFactoriesFromFactoryFactories = function(options, list, nodeFactoryFactory) {
	    var i, len, name, nodeFactory, nodeTypeName, out, ref1, suffix;
	    suffix = options.suffix || '';
	    out = {};
	    ref1 = compactFlattenObjectTreeNodeNames(list);
	    for (i = 0, len = ref1.length; i < len; i++) {
	      nodeTypeName = ref1[i];
	      nodeFactory = nodeFactoryFactory(nodeTypeName);
	      name = upperCamelCase(nodeTypeName) + suffix;
	      options.inspectedName = name;
	      out[name] = ObjectTreeFactory.createObjectTreeFactory(options, nodeFactory);
	    }
	    return out;
	  };

	  return ObjectTreeFactory;

	})();


/***/ },
/* 94 */
/***/ function(module, exports) {

	/*
	 * http://blog.stevenlevithan.com/archives/date-time-format
	 * Date Format 1.2.3
	 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
	 * MIT license
	 *
	 * Includes enhancements by Scott Trenda <scott.trenda.net>
	 * and Kris Kowal <cixar.com/~kris.kowal/>
	 *
	 * Accepts a date, a mask, or a date and a mask.
	 * Returns a formatted version of the given date.
	 * The date defaults to the current date/time.
	 * The mask defaults to dateFormat.masks.default.
	 */

	var dateFormat = function () {
	  var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
	    timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
	    timezoneClip = /[^-+\dA-Z]/g,
	    pad = function (val, len) {
	      val = String(val);
	      len = len || 2;
	      while (val.length < len) val = "0" + val;
	      return val;
	    };

	  // Regexes and supporting functions are cached through closure
	  return function (date, mask, utc) {
	    var dF = dateFormat;

	    // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
	    if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
	      mask = date;
	      date = undefined;
	    }

	    // Passing date through Date applies Date.parse, if necessary
	    date = date ? new Date(date) : new Date;
	    if (isNaN(date)) throw SyntaxError("invalid date");

	    mask = String(dF.masks[mask] || mask || dF.masks["default"]);

	    // Allow setting the utc argument via the mask
	    if (mask.slice(0, 4) == "UTC:") {
	      mask = mask.slice(4);
	      utc = true;
	    }

	    var _ = utc ? "getUTC" : "get",
	      d = date[_ + "Date"](),
	      D = date[_ + "Day"](),
	      m = date[_ + "Month"](),
	      y = date[_ + "FullYear"](),
	      H = date[_ + "Hours"](),
	      M = date[_ + "Minutes"](),
	      s = date[_ + "Seconds"](),
	      L = date[_ + "Milliseconds"](),
	      o = utc ? 0 : date.getTimezoneOffset(),
	      flags = {
	        d:    d,
	        dd:   pad(d),
	        ddd:  dF.i18n.dayNames[D],
	        dddd: dF.i18n.dayNames[D + 7],
	        m:    m + 1,
	        mm:   pad(m + 1),
	        mmm:  dF.i18n.monthNames[m],
	        mmmm: dF.i18n.monthNames[m + 12],
	        yy:   String(y).slice(2),
	        yyyy: y,
	        h:    H % 12 || 12,
	        hh:   pad(H % 12 || 12),
	        H:    H,
	        HH:   pad(H),
	        M:    M,
	        MM:   pad(M),
	        s:    s,
	        ss:   pad(s),
	        l:    pad(L, 3),
	        L:    pad(L > 99 ? Math.round(L / 10) : L),
	        t:    H < 12 ? "a"  : "p",
	        tt:   H < 12 ? "am" : "pm",
	        T:    H < 12 ? "A"  : "P",
	        TT:   H < 12 ? "AM" : "PM",
	        Z:    utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
	        o:    (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
	        S:    ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
	      };

	    return mask.replace(token, function ($0) {
	      return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
	    });
	  };
	}();

	// Some common format strings
	dateFormat.masks = {
	  "default":      "ddd mmm dd yyyy HH:MM:ss",
	  shortDate:      "m/d/yy",
	  mediumDate:     "mmm d, yyyy",
	  longDate:       "mmmm d, yyyy",
	  fullDate:       "dddd, mmmm d, yyyy",
	  shortTime:      "h:MM TT",
	  mediumTime:     "h:MM:ss TT",
	  longTime:       "h:MM:ss TT Z",
	  isoDate:        "yyyy-mm-dd",
	  isoTime:        "HH:MM:ss",
	  isoDateTime:    "yyyy-mm-dd'T'HH:MM:ss",
	  isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
	};

	// Internationalization strings
	dateFormat.i18n = {
	  dayNames: [
	    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
	    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
	  ],
	  monthNames: [
	    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
	    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
	  ]
	};

	// For convenience...
	// Date.prototype.format = function (mask, utc) {
	//   return dateFormat(this, mask, utc);
	// };

	module.exports = {dateFormat: dateFormat};


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	var Analytics, BaseObject, ClassSystem, StandardLib, inspectLean,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	StandardLib = __webpack_require__(29);

	ClassSystem = __webpack_require__(78);

	BaseObject = ClassSystem.BaseObject;

	inspectLean = StandardLib.inspectLean;

	Analytics = (function(superClass) {
	  extend(Analytics, superClass);

	  function Analytics() {
	    return Analytics.__super__.constructor.apply(this, arguments);
	  }

	  Analytics.defaultCategory = "Foundation.Analytics";

	  Analytics.event = function(options) {
	    var action, category, label, noninteraction, value;
	    if (options == null) {
	      options = {};
	    }
	    category = options.category || this.defaultCategory;
	    action = options.action;
	    label = options.label;
	    value = options.value;
	    noninteraction = !!options.noninteraction;
	    if (self._gaq) {
	      self._gaq.push(['_trackEvent', category, action, label, value, noninteraction]);
	      return this.rawLog("ANALYTICS-EVENT: " + (inspectLean(options)));
	    } else {
	      return this.rawLog("(no)ANALYTICS-EVENT: " + (inspectLean(options)));
	    }
	  };

	  return Analytics;

	})(BaseObject);


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var Promise, defineModule, isWebWorker, log, objectKeyCount, ref, workerRpc;

	ref = __webpack_require__(29), defineModule = ref.defineModule, Promise = ref.Promise, log = ref.log, objectKeyCount = ref.objectKeyCount;

	isWebWorker = __webpack_require__(91).isWebWorker;

	workerRpc = __webpack_require__(97).workerRpc;


	/*
	AsyncLocalStorage defines a consistent API for localStorage across web-workers and the main thread.

	API:
	  AsyncLocalStorage.
	    getItem:    (path)        -> promise.then -> item at path
	    setItem:    (path, value) -> promise.then -> success
	    removeItem: (path)        -> promise.then -> success
	    clear:                    -> promise.then -> success
	 */

	defineModule(module, function() {
	  var AsyncLocalStorage, LocalStorageShimForNode, localStorage;
	  localStorage = global.localStorage;
	  localStorage || (localStorage = LocalStorageShimForNode = (function() {
	    function LocalStorageShimForNode() {}

	    LocalStorageShimForNode.store = {};

	    LocalStorageShimForNode.getItem = function(k) {
	      return LocalStorageShimForNode.store[k];
	    };

	    LocalStorageShimForNode.setItem = function(k, v) {
	      return LocalStorageShimForNode.store[k] = v;
	    };

	    LocalStorageShimForNode.removeItem = function(k) {
	      return delete LocalStorageShimForNode.store[k];
	    };

	    LocalStorageShimForNode.clear = function() {
	      return LocalStorageShimForNode.store = {};
	    };

	    LocalStorageShimForNode.key = function(i) {
	      return Object.keys(LocalStorageShimForNode.store)[i];
	    };

	    LocalStorageShimForNode.getLength = function() {
	      return objectKeyCount(LocalStorageShimForNode.store);
	    };

	    return LocalStorageShimForNode;

	  })());
	  if (isWebWorker) {
	    return workerRpc.bindWithPromises({
	      localStorage: ["getItem", "setItem", "removeItem", "clear", "key"]
	    });
	  } else {
	    workerRpc.register({
	      localStorage: localStorage
	    });
	    return AsyncLocalStorage = (function() {
	      function AsyncLocalStorage() {}

	      AsyncLocalStorage.getItem = function(path) {
	        return Promise.then(function() {
	          return localStorage.getItem(path);
	        });
	      };

	      AsyncLocalStorage.setItem = function(path, value) {
	        return Promise.then(function() {
	          return localStorage.setItem(path, value);
	        });
	      };

	      AsyncLocalStorage.removeItem = function(path) {
	        return Promise.then(function() {
	          return localStorage.removeItem(path);
	        });
	      };

	      AsyncLocalStorage.clear = function() {
	        return Promise.then(function() {
	          return localStorage.clear();
	        });
	      };

	      AsyncLocalStorage.key = function(index) {
	        return Promise.then(function() {
	          return localStorage.key(index);
	        });
	      };

	      AsyncLocalStorage.getLength = function() {
	        return Promise.then(function() {
	          return localStorage.length;
	        });
	      };

	      return AsyncLocalStorage;

	    })();
	  }
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, ClassSystem, Promise, StandardLib, WebWorker, WorkerRpc, debugPrefix, isFunction, isPlainArray, isString, isWebWorker, log, mergeInto,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  slice = [].slice;

	StandardLib = __webpack_require__(29);

	ClassSystem = __webpack_require__(78);

	WebWorker = __webpack_require__(91);

	Promise = StandardLib.Promise, log = StandardLib.log, isPlainArray = StandardLib.isPlainArray, isFunction = StandardLib.isFunction, isString = StandardLib.isString, mergeInto = StandardLib.mergeInto;

	BaseObject = ClassSystem.BaseObject;

	isWebWorker = WebWorker.isWebWorker;


	/*
	WorkerRPC has two modes: singleton and instanced.

	SINGLETON:
	  Including WorkerRPC automatically creates the singleton instance.
	  In a worker, the singleton automatically binds to the worker's self.onmessage and starts listenting.
	  In workers or the browser, any handler registered with the singleton will be available to respond
	  to any message received by the singleton OR ANY OTHER INSTANCE of WorkerRPC in that thread.
	  You can think of the singleton as the global registry for handlers.

	In practice:
	  In browser:
	     * to register all your handlers, call this one or more times:
	    WorkerRpc.register ...

	     * call for each each worker you want to listen for RPC calls from,
	     * and bind any remote procedures you want to be able to invoke on that specific worker-thread
	    aBoundWorker = new WorkerRpc worker,
	      bind: ...
	      bindWithPromises: ...

	     * to make remote-procedure-calls to the worker:
	     * NOTE: if registered with bindWithPromises, will return a promise for the RPC's result.
	    aBoundWorker.MyWorkerNamespace.myWorkerFunction ...

	  In worker:
	     * to register all your handlers, call this one or more times:
	    WorkerRpc.register ...

	     * bind any remote procedures you want to be able to invoke on the browser-thread
	    WorkerRpc.bind ...
	    WorkerRpc.bindWithPromises ...

	NOTES:
	  registered functions are invoked with @/this set to the namespace. That way you can invoke
	  callback functions you previously bound back to the specific worker that invoked the
	  function with: @MyWorkerNamespace.myWorkerFunction()

	Real world example:

	  Suppose you want to access the localStorage object on the browser thread from your worker.
	  The 6 lines of code below create the 'self.asyncLocalStorage' object which works just like
	  'localStorage' except it returns Art.Foundation.Promises for the function results.

	  browser: (before starting the worker)
	    {WorkerRpc} = Art.Foundation
	    WorkerRpc.register localStorage: localStorage
	    new WorkerRpc workerSourcePath

	  worker:
	    {workerRpc} = Art.Foundation.WorkerRpc
	    workerRpc.bindWithPromises localStorage: ["getItem", "setItem", "removeItem", "clear"]
	    self.asyncLocalStorage = workerRpc.localStorage

	  SBD: Isn't that nice! So streamlined!

	General examples:

	Usage with no return value expected:
	  browser thread:

	    new WorkerRpc (new Worker workerUrl),
	      register:
	        MyMainNamespace:
	          doWork: (a) -> ...

	  worker thread:

	    {MyMainNamespace} = new WorkerRpc self,
	      bind:
	        MyMainNamespace: ["doWork"]

	    MyMainNamespace.doWork myStructuredData

	Usage with promises:

	  browser thread:

	    new WorkerRpc (new Worker workerUrl),
	      register:
	        MyMainNamespace:
	          concatStrings: (a, b) ->
	            a + b
	             * equivelent to: Promise.resolve a + b
	             * if the result is not a Promse, Promise.resolve(result) is automatically applied

	  worker thread:

	    {MyMainNamespace} = new WorkerRpc self,
	      bindWithPromises:
	        MyMainNamespace: ["concatStrings"]

	    MyMainNamespace.concatStrings "hi ", "Shane"
	    .then (result) ->
	       * result == "hi Shane"

	Usage with arbitrary response messages:

	  Sometimes you want a handle to the workerRpc instance for the thread that just send
	  you the message inside your registered response functions. You can access that
	  via the global: WorkerRpc.lastMessageReceivedFrom.

	  browser thread:

	    new WorkerRpc (new Worker workerUrl),
	      register:
	        MyMainNamespace:
	          doWorkAndRespond: (key) ->
	            count == 0
	            invokeThreeTimes =>
	              count++
	              WorkerRpc.lastMessageReceivedFrom.MyWorkerNamespace.respond key, count

	  worker thread:

	    {MyMainNamespace} = new WorkerRpc self,
	      register:
	        MyWorkerNamespace:
	          respond: (key, count) -> console.log "MyWorkerNamespace#respond: #{key} #{count}"
	      bind:
	        MyMainNamespace: ["doWorkAndRespond"]

	    MyMainNamespace.doWorkAndRespond "myKey"

	Usage - add to global registery:

	  WorkerRpc.register
	    MyGlobalClass:
	      doSomethingNoMatterWhoCalls: ->
	        ...
	 */

	debugPrefix = isWebWorker ? "WorkerRpc(worker)" : "WorkerRpc(browser)";

	module.exports = WorkerRpc = (function(superClass) {
	  var workerRpcChannelIdString;

	  extend(WorkerRpc, superClass);

	  WorkerRpc.singletonClass();

	  WorkerRpc.workerRpcChannelIdString = workerRpcChannelIdString = "Art.Foundation.WorkerRpcChannel";

	  WorkerRpc.register = function(toRegister) {
	    return WorkerRpc.singleton.register(toRegister);
	  };

	  WorkerRpc.bind = function(toBind) {
	    return WorkerRpc.singleton._bind(toBind, false);
	  };

	  WorkerRpc.bindWithPromises = function(toBind) {
	    return WorkerRpc.singleton._bind(toBind, true);
	  };


	  /*
	  INPUT:
	    thread:
	      must implement onmessage= and postMessage or be null
	      In a webworker, this gets set to self if it is null.
	    options:
	      bind: map # invokes: @bind map
	      bindWithPromises: map # invokes: @bindWithPromises map
	   */

	  function WorkerRpc(thread, options) {
	    if (isString(thread)) {
	      log("WorkerRpc starting worker: " + thread);
	      thread = new Worker(thread);
	      log("WorkerRpc starting worker: " + thread + ", started?:", thread);
	    }
	    if (!(thread || self === self.window)) {
	      thread = self;
	    }
	    this._reset();
	    this._bindOnmessage(this._thread = thread);
	    if (options) {
	      this._applyOptions(options);
	    }
	  }

	  WorkerRpc.prototype.register = function(toRegister) {
	    var functionMap, namespaceName;
	    if (!toRegister) {
	      return;
	    }
	    for (namespaceName in toRegister) {
	      functionMap = toRegister[namespaceName];
	      if (this._registry.hasOwnProperty(namespaceName)) {
	        mergeInto(this._registry[namespaceName], functionMap);
	      } else {
	        this._registry[namespaceName] = functionMap;
	      }
	    }
	    return this._registry;
	  };


	  /*
	  Creates functions to make specific remote-procedure-calls.
	  
	  IN:
	    toBind: map to arrays of strings
	      Each key in the map specifies a namespace.
	      The array of strings specify the names of each RPC you want to be able to invoke.
	  
	  For a given namespaceName and functionName, this binds the function so you can
	  invoke it as follows:
	    @myNamespaceName.myFunctionName()
	  
	  The created functions are one-way. They return null as soon as the message has been sent
	  to the remote thread. If you want the results, see @bindWithPromises
	   */

	  WorkerRpc.prototype.bind = function(toBind) {
	    return this._bind(toBind, false);
	  };


	  /*
	  Same as @bind except each function created will return a promise which will return
	  the results return from the remote procedure call when they are ready.
	   */

	  WorkerRpc.prototype.bindWithPromises = function(toBind) {
	    return this._bind(toBind, true);
	  };

	  WorkerRpc.prototype._bind = function(toBind, withPromises) {
	    var functionName, functionNames, i, len, namespace, namespaceName, ref;
	    if (!isFunction((ref = this._thread) != null ? ref.postMessage : void 0)) {
	      throw new Error("@_thread.postMessage required for remote requests");
	    }
	    if (!toBind) {
	      return;
	    }
	    namespace = null;
	    for (namespaceName in toBind) {
	      functionNames = toBind[namespaceName];
	      if (!this.hasOwnProperty(namespaceName)) {
	        this[namespaceName] = {};
	      }
	      namespace = this[namespaceName];
	      for (i = 0, len = functionNames.length; i < len; i++) {
	        functionName = functionNames[i];
	        namespace[functionName] = withPromises ? this._newRemoteRequestFunctionWithPromise(namespaceName, functionName) : this._newRemoteRequestFunction(namespaceName, functionName);
	      }
	    }
	    return namespace;
	  };

	  WorkerRpc.prototype._reset = function() {
	    return this._registry = {
	      promiseCallback: {
	        success: (function(_this) {
	          return function(promiseId, result) {
	            return WorkerRpc._resolvePromise(promiseId, result);
	          };
	        })(this),
	        error: (function(_this) {
	          return function(promiseId, error) {
	            return WorkerRpc._rejectPromise(promiseId, error);
	          };
	        })(this)
	      }
	    };
	  };

	  WorkerRpc.prototype._applyOptions = function(arg) {
	    var bind, bindWithPromises, register;
	    register = arg.register, bind = arg.bind, bindWithPromises = arg.bindWithPromises;
	    this.register(register);
	    this.bind(bind);
	    this.bindWithPromises(bindWithPromises);
	    return this;
	  };

	  WorkerRpc.prototype._send = function(namespaceName, functionName, promiseId, args) {
	    return this._thread.postMessage([workerRpcChannelIdString, namespaceName, functionName, promiseId, args]);
	  };

	  WorkerRpc.prototype._newRemoteRequestFunctionWithPromise = function(namespaceName, functionName) {
	    return (function(_this) {
	      return function() {
	        var args;
	        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	        return WorkerRpc._bindPromise(function(promiseId) {
	          return _this._send(namespaceName, functionName, promiseId, args);
	        });
	      };
	    })(this);
	  };

	  WorkerRpc.prototype._newRemoteRequestFunction = function(namespaceName, functionName) {
	    return (function(_this) {
	      return function() {
	        var args;
	        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	        return _this._send(namespaceName, functionName, null, args);
	      };
	    })(this);
	  };

	  WorkerRpc.prototype._bindOnmessage = function(thread) {
	    var handler;
	    if (!thread) {
	      return;
	    }
	    handler = (function(_this) {
	      return function(arg) {
	        var args, data, functionName, namespaceName, promiseId, testWorkerRpcChannelIdString;
	        data = arg.data;
	        if (!isPlainArray(data)) {
	          return;
	        }
	        testWorkerRpcChannelIdString = data[0], namespaceName = data[1], functionName = data[2], promiseId = data[3], args = data[4];
	        if (testWorkerRpcChannelIdString !== workerRpcChannelIdString) {
	          return;
	        }
	        return _this._invokeLocalFunction(namespaceName, functionName, promiseId, args);
	      };
	    })(this);
	    if (thread.addEventListener) {
	      return thread.addEventListener('message', handler);
	    } else {
	      return thread.onmessage = handler;
	    }
	  };

	  WorkerRpc.prototype._invokeLocalFunction = function(namespaceName, functionName, promiseId, args) {
	    var localFunction, namespace, singleton;
	    if (!((namespace = this._registry[namespaceName]) && (localFunction = namespace[functionName]))) {
	      singleton = WorkerRpc.singleton;
	      if (this !== singleton && (namespace = singleton._registry[namespaceName])) {
	        localFunction = namespace[functionName];
	      }
	    }
	    if (!localFunction) {
	      console.warn(debugPrefix + "_onmessage: could not find: '" + namespaceName + "." + functionName + "'\n\nnamespaces: " + (Object.keys(this._registry).join(', ')) + "\nglobal namespaces: " + (singleton === this ? "(same)" : Object.keys(singleton._registry).join(', ')));
	    }
	    if (localFunction) {
	      WorkerRpc.lastMessageReceivedFrom = this;
	      return this._resolveOrRejectRemotePromise(promiseId, localFunction.apply(namespace, args));
	    }
	  };

	  WorkerRpc.prototype._resolveOrRejectRemotePromise = function(promiseId, result) {
	    if (promiseId == null) {
	      return;
	    }
	    return Promise.resolve(result).then((function(_this) {
	      return function(result) {
	        return _this._send("promiseCallback", "success", null, [promiseId, result], function(error) {
	          return _this._send("promiseCallback", "error", null, [promiseId, error]);
	        });
	      };
	    })(this));
	  };


	  /*
	  IN:   f: (promiseId) -> ignored
	  OUT:  promise
	  
	  Creates a new promise, addes it to @_promises with a unique id, and invokes f, passing in
	  the promise's id.
	   */

	  WorkerRpc._promises = {};

	  WorkerRpc._nextPromiseId = 0;

	  WorkerRpc._bindPromise = function(f) {
	    var promise, promiseId;
	    this._promises[promiseId = this._nextPromiseId++] = promise = new Promise;
	    f(promiseId);
	    return promise;
	  };

	  WorkerRpc._resolvePromise = function(promiseId, result) {
	    var ref;
	    if ((ref = this._promises[promiseId]) != null) {
	      ref.resolve(result);
	    }
	    return delete this._promises[promiseId];
	  };

	  WorkerRpc._rejectPromise = function(promiseId, error) {
	    var ref;
	    if ((ref = this._promises[promiseId]) != null) {
	      ref.reject(error);
	    }
	    return delete this._promises[promiseId];
	  };

	  return WorkerRpc;

	})(BaseObject);


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, BatchLoader, ClassSystem, StandardLib, inspect, log, nextTick, timeout,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	StandardLib = __webpack_require__(29);

	ClassSystem = __webpack_require__(78);

	BaseObject = ClassSystem.BaseObject;

	log = StandardLib.log, inspect = StandardLib.inspect, nextTick = StandardLib.nextTick, timeout = StandardLib.timeout;

	module.exports = BatchLoader = (function(superClass) {
	  extend(BatchLoader, superClass);

	  function BatchLoader(loadFunction) {
	    this.assets = {};
	    this.loadingAssets = {};
	    this.loadFunction = loadFunction;
	  }

	  BatchLoader.prototype.load = function(sources, onLoad) {
	    if (typeof sources === "string") {
	      sources = [sources];
	    }
	    return this.loadAssets(sources, onLoad);
	  };

	  BatchLoader.prototype.addAsset = function(source, asset) {
	    var base;
	    if (asset == null) {
	      throw new Error("not a valid asset: " + (inspect(asset)));
	    }
	    delete this.loadingAssets[source];
	    (base = this.assets)[source] || (base[source] = asset);
	    return this.notifyListeners();
	  };

	  BatchLoader.getter({
	    blankInfo: function() {
	      return {
	        loadedFromCache: 0,
	        loadedAsynchronously: 0,
	        alreadyLoadingAsynchronously: 0
	      };
	    }
	  });

	  BatchLoader.prototype.loadAssets = function(sources, onLoad) {
	    var info;
	    info = this.blankInfo;
	    sources.forEach((function(_this) {
	      return function(src) {
	        if (_this.assets[src] != null) {
	          return info.loadedFromCache++;
	        } else if (_this.loadingAssets[src]) {
	          info.loadedAsynchronously++;
	          return info.alreadyLoadingAsynchronously++;
	        } else {
	          info.loadedAsynchronously++;
	          _this.loadingAssets[src] = true;
	          return _this.loadFunction(src, function(src, asset) {
	            return _this.addAsset(src, asset);
	          });
	        }
	      };
	    })(this));
	    this.addLoaderListener(sources, onLoad, info);
	    return nextTick((function(_this) {
	      return function() {
	        return _this.notifyListeners();
	      };
	    })(this));
	  };

	  BatchLoader.prototype.addLoaderListener = function(sources, onLoad, info) {
	    this.loadingListeners || (this.loadingListeners = []);
	    return this.loadingListeners.push({
	      sources: sources,
	      onLoad: onLoad,
	      info: info
	    });
	  };

	  BatchLoader.prototype.notifyListeners = function() {
	    var allLoaded, i, j, len, len1, listener, oldloadingListeners, ref, source;
	    if (!this.loadingListeners) {
	      return;
	    }
	    oldloadingListeners = this.loadingListeners;
	    this.loadingListeners = [];
	    for (i = 0, len = oldloadingListeners.length; i < len; i++) {
	      listener = oldloadingListeners[i];
	      allLoaded = true;
	      ref = listener.sources;
	      for (j = 0, len1 = ref.length; j < len1; j++) {
	        source = ref[j];
	        if (!this.assets[source]) {
	          allLoaded = false;
	        }
	      }
	      if (allLoaded) {
	        listener.onLoad(this.assets, listener.sources, listener.info);
	      } else {
	        this.loadingListeners.push(listener);
	      }
	    }
	    return this.loadingListeners;
	  };

	  return BatchLoader;

	})(BaseObject);


/***/ },
/* 99 */
/***/ function(module, exports) {

	
	/*
	A core set of status-codes that code can reason about easily.

	Goal:

	  Minimal set of codes so APIs can reason about network requests in a
	  consistant way.

	Why not HTTP Status codes?

	  They cover so much, most of which automatic code cannot do anything about
	  other than report an error, possibly to be viewed by a human later.

	My strategy is to have a small, simple set of status codes for our programs to
	reason about, and, if necessary, allow the communication channel to return
	additional information in the form of a 'message' that humans can look at to
	get more information about any failures.

	Note, these status-codes are used at the core of other Art Libs:

	  ArtFlux
	  ArtEry

	Possible additional statuses to add:

	  (only add if we have a very good use-case that requires it)

	  temporaryFailure: code can retry in a bit and it might work then

	  redirect: request can only be fulfilled at the new location

	    Note, I don't think we should have different statuses for all the  various
	    redirect semantics. It's up to the API to determine if a redirect is
	    temporary or permanent. I could imagine an API which returns a
	    redirectAddress  string as well as a connonicalAddress.
	 */
	var CommunicationStatus;

	module.exports = CommunicationStatus = (function() {
	  function CommunicationStatus() {}


	  /*
	  status: success
	  
	  * An unqualified success.
	  * I guess it could be qualified, with additional information in another field,
	    but the 'expected' data should be present.
	   */

	  CommunicationStatus.success = "success";


	  /*
	  status: pending
	  
	  * The request is proceeding.
	  * No errors so far.
	   */

	  CommunicationStatus.pending = "pending";


	  /*
	  status: missing
	  
	  * The request was properly formatted.
	  * There were no network errors.
	  * There were no server errors.
	  * The only problem is the server could not find the requested resource.
	   */

	  CommunicationStatus.missing = "missing";


	  /*
	  status: failure
	  
	  * All network and server errors.
	  * Provide additional information in 'message' or 'error' parameter.
	   */

	  CommunicationStatus.failure = "failure";


	  /*
	  OUT: true if status is a valid status-string
	   */

	  CommunicationStatus.validStatus = function(status) {
	    return CommunicationStatus[status] === status;
	  };

	  return CommunicationStatus;

	})();


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, ClassSystem, Epoch, Foundation, Promise, StandardLib, evalAndThrowErrorsOutOfStack, inspect, requestAnimationFrame,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	Foundation = __webpack_require__(26);

	StandardLib = __webpack_require__(29);

	ClassSystem = __webpack_require__(78);

	BaseObject = ClassSystem.BaseObject;

	inspect = StandardLib.inspect, Promise = StandardLib.Promise, requestAnimationFrame = StandardLib.requestAnimationFrame, evalAndThrowErrorsOutOfStack = StandardLib.evalAndThrowErrorsOutOfStack;

	module.exports = Epoch = (function(superClass) {
	  extend(Epoch, superClass);

	  function Epoch(options) {
	    if (options == null) {
	      options = {};
	    }
	    Epoch.__super__.constructor.apply(this, arguments);
	    this._emptyQueueAfterProcessing = !!options.emptyQueueAfterProcessing;
	    this._queuedItems = [];
	    this._nextReadyQueue = [];
	    this._epochQueued = false;
	    this._processingEpoch = false;
	    this._epochCount = 0;
	    this._frameSecond = 0;
	  }

	  Epoch.getter("processingEpoch epochQueued epochCount emptyQueueAfterProcessing frameSecond", {
	    epochLength: function() {
	      return this._queuedItems.length;
	    }
	  });

	  Epoch.prototype.updateGlobalCounts = function() {
	    Foundation.globalCount(this["class"].name + "_queuedItems", this._queuedItems.length);
	    return Foundation.globalCount(this["class"].name + "_nextReadyQueue", this._nextReadyQueue.length);
	  };


	  /*
	  This guarantess there will be a next "ready" event.
	  If there were no setStates this epoch, then there won't be a next "ready" - unless you use this method.
	  
	  IN:
	    f: an optional function to invoke on-next-ready
	      mostly this is provided as a shortcut:
	        @onNextReady =>
	      is directly equivelent to:
	        @onNextReady().then =>
	  
	  OUT: promise.then (result of calling f() or null if no f) ->
	   */

	  Epoch.prototype.onNextReady = function(f, forceNextEpoch, passThroughArgument) {
	    if (forceNextEpoch == null) {
	      forceNextEpoch = true;
	    }
	    if (forceNextEpoch && !this._processingEpoch) {
	      this.queueNextEpoch();
	    }
	    return new Promise((function(_this) {
	      return function(resolve) {
	        return _this._nextReadyQueue.push(function() {
	          return resolve(f ? f(passThroughArgument) : passThroughArgument);
	        });
	      };
	    })(this));
	  };

	  Epoch.prototype._ready = function() {
	    var f, i, len, nrq, results;
	    if (!((nrq = this._nextReadyQueue).length > 0)) {
	      return;
	    }
	    this._nextReadyQueue = [];
	    results = [];
	    for (i = 0, len = nrq.length; i < len; i++) {
	      f = nrq[i];
	      results.push(evalAndThrowErrorsOutOfStack((function(_this) {
	        return function() {
	          return f();
	        };
	      })(this)));
	    }
	    return results;
	  };

	  Epoch.prototype.queueItem = function(item) {
	    if (item) {
	      this._queuedItems.push(item);
	      this.queueNextEpoch();
	    }
	    return item;
	  };

	  Epoch.prototype.isItemQueued = function(item) {
	    return indexOf.call(this._queuedItems, item) >= 0;
	  };

	  Epoch.prototype.queueNextEpoch = function() {
	    if (!this._epochQueued) {
	      this._epochQueued = true;
	      return requestAnimationFrame((function(_this) {
	        return function(frameTimeMs) {
	          _this._frameSecond = frameTimeMs / 1000;
	          _this._epochQueued = false;
	          return _this.processEpoch();
	        };
	      })(this));
	    }
	  };

	  Epoch.prototype.flushEpochNow = function() {
	    return this.processEpoch();
	  };

	  Epoch.prototype.processEpoch = function() {
	    var items;
	    this._processingEpoch = true;
	    items = this._queuedItems;
	    if (this._emptyQueueAfterProcessing) {
	      this.processEpochItemsWithErrorHandling(items);
	      this._queuedItems = [];
	    } else {
	      this._queuedItems = [];
	      this.processEpochItemsWithErrorHandling(items);
	    }
	    this._processingEpoch = false;
	    this._epochCount++;
	    return this._ready();
	  };

	  Epoch.prototype.processEpochItemsWithErrorHandling = function(items) {
	    return evalAndThrowErrorsOutOfStack((function(_this) {
	      return function() {
	        return _this.processEpochItems(items);
	      };
	    })(this));
	  };

	  Epoch.prototype.processEpochItems = function(items) {
	    var i, item, len, results;
	    results = [];
	    for (i = 0, len = items.length; i < len; i++) {
	      item = items[i];
	      results.push(item());
	    }
	    return results;
	  };

	  return Epoch;

	})(BaseObject);


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var defineModule, fastBind, isFunction, log, ref,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	ref = __webpack_require__(29), defineModule = ref.defineModule, isFunction = ref.isFunction, fastBind = ref.fastBind, log = ref.log;

	defineModule(module, function() {
	  return function(superClass) {
	    var InstanceFunctionBindingMixin;
	    return InstanceFunctionBindingMixin = (function(superClass1) {
	      extend(InstanceFunctionBindingMixin, superClass1);

	      function InstanceFunctionBindingMixin() {
	        return InstanceFunctionBindingMixin.__super__.constructor.apply(this, arguments);
	      }

	      InstanceFunctionBindingMixin.getFunctionsToBindList = function() {
	        if (this.hasOwnProperty("_functionsToBindList")) {
	          return this._functionsToBindList;
	        } else {
	          return this._functionsToBindList = this.getFunctionsToBindList();
	        }
	      };

	      InstanceFunctionBindingMixin.getFunctionsToBindList = function() {
	        var k, ref1, results, v;
	        ref1 = this.prototype;
	        results = [];
	        for (k in ref1) {
	          v = ref1[k];
	          if (k !== "constructor" && isFunction(v) && this.propertyIsConcrete(k) && (!this.nonBindingFunctions || indexOf.call(this.nonBindingFunctions, k) < 0)) {
	            results.push(k);
	          }
	        }
	        return results;
	      };

	      InstanceFunctionBindingMixin.prototype.getBoundFunctionList = function() {
	        return this._boundFunctionList;
	      };

	      InstanceFunctionBindingMixin.prototype.bindFunctionsToInstance = function() {
	        var functionsToBindList, i, j, k, len, len1, prototype, ref1;
	        functionsToBindList = this["class"].getFunctionsToBindList();
	        if (this._boundFunctionList) {
	          ref1 = this._boundFunctionList;
	          for (i = 0, len = ref1.length; i < len; i++) {
	            k = ref1[i];
	            if (indexOf.call(functionsToBindList, k) < 0) {
	              delete this[k];
	            }
	          }
	        }
	        prototype = this["class"].prototype;
	        for (j = 0, len1 = functionsToBindList.length; j < len1; j++) {
	          k = functionsToBindList[j];
	          this[k] = fastBind(prototype[k], this);
	        }
	        return this._boundFunctionList = functionsToBindList;
	      };

	      return InstanceFunctionBindingMixin;

	    })(superClass);
	  };
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var AsyncLocalStorage, BaseObject, ClassSystem, JsonStore, Promise, isNumber, log, ref,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(29), log = ref.log, Promise = ref.Promise, isNumber = ref.isNumber;

	ClassSystem = __webpack_require__(78);

	AsyncLocalStorage = __webpack_require__(96);

	BaseObject = ClassSystem.BaseObject;

	module.exports = JsonStore = (function(superClass) {
	  extend(JsonStore, superClass);

	  function JsonStore(store) {
	    if (store == null) {
	      store = AsyncLocalStorage;
	    }
	    this.store = store;
	  }

	  JsonStore.prototype.setItem = function(k, v) {
	    return Promise.then((function(_this) {
	      return function() {
	        return _this.store.setItem(k, JSON.stringify(v));
	      };
	    })(this));
	  };

	  JsonStore.prototype.getItem = function(k) {
	    return Promise.resolve(this.store.getItem(k)).then((function(_this) {
	      return function(v) {
	        return JSON.parse(v);
	      };
	    })(this));
	  };

	  JsonStore.prototype.removeItem = function(k) {
	    return Promise.then((function(_this) {
	      return function() {
	        return _this.store.removeItem(k);
	      };
	    })(this));
	  };

	  JsonStore.prototype.clear = function() {
	    return Promise.then((function(_this) {
	      return function() {
	        return _this.store.clear();
	      };
	    })(this));
	  };

	  JsonStore.prototype.key = function(i) {
	    return Promise.then((function(_this) {
	      return function() {
	        return _this.store.key(i);
	      };
	    })(this));
	  };

	  JsonStore.prototype.getLength = function() {
	    return Promise.then((function(_this) {
	      return function() {
	        if (isNumber(_this.store.length)) {
	          return _this.store.length;
	        } else {
	          return _this.store.getLength();
	        }
	      };
	    })(this));
	  };

	  return JsonStore;

	})(BaseObject);


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var Promise, RestClient, StandardLib, isNumber, log, merge, present, timeout;

	StandardLib = __webpack_require__(29);

	present = StandardLib.present, Promise = StandardLib.Promise, merge = StandardLib.merge, isNumber = StandardLib.isNumber, timeout = StandardLib.timeout, log = StandardLib.log;

	module.exports = RestClient = (function() {
	  function RestClient() {}

	  RestClient.legalVerbs = {
	    get: "GET",
	    GET: "GET",
	    put: "PUT",
	    PUT: "PUT",
	    post: "POST",
	    POST: "POST",
	    "delete": "DELETE",
	    DELETE: "DELETE"
	  };


	  /*
	  get/put/post/delete
	  
	  IN:
	    url: valid url string
	  
	    data: (only on PUT/POST requests)
	      data to send
	      NOTE: must be null if using formData
	  
	    options:
	  
	      formData: plain object of key-value pairs to submit as form-data
	        You can even use this for "get" requests.
	        NOTE: "data" must be null if using "formData"
	  
	      headers: plain object of additional HTTP headers to set
	  
	      onProgress: (restRequestStatus) -> null
	        called each time progress is made
	        NOTE: restRequestStatus.progress contains a 0-to-1 number that indicates how much progress has been made.
	          progress indicates DOWNLOAD progress for GET requests and UPLOAD progress for all others.
	  
	      responseType: "arraybuffer", "blob", "document", "json", or "text"
	        default: "text"
	        NOTE: "json" is handled manually since IE11 and iOS7 don't support the "json" option.
	        https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType
	  
	  OUT: Promise:
	    resolved: (responseData) ->
	    rejected: (restRequestStatus) ->
	  
	  responseData:
	    a String, or the type specified by the responseType option
	  
	  restRequestStatus:
	    event:    # the HTML event object
	    request:  # the XMLHttpRequest
	    options:  # the restRequest options: verb, url, data, headers, onProgress, responseType, formData
	    status:   # the HTML status code, if the request completed
	    response: # responseData
	    error:    # Error object or string-explaination of why the request was rejected
	    progress:
	      a value between 0 and 1
	      If the progress is indeterminant, this is 0
	      If this isn't an onProgress event, this is the amount of progress
	      that was made up to the point of the event.
	   */

	  RestClient.get = function(url, options) {
	    return RestClient.restRequest(merge(options, {
	      verb: "GET",
	      url: url
	    }));
	  };

	  RestClient.put = function(url, data, options) {
	    return RestClient.restRequest(merge(options, {
	      verb: "PUT",
	      url: url,
	      data: data
	    }));
	  };

	  RestClient.post = function(url, data, options) {
	    return RestClient.restRequest(merge(options, {
	      verb: "POST",
	      url: url,
	      data: data
	    }));
	  };

	  RestClient["delete"] = function(url, options) {
	    return RestClient.restRequest(merge(options, {
	      verb: "DELETE",
	      url: url
	    }));
	  };

	  RestClient.getArrayBuffer = function(url, options) {
	    return this.get(url, merge(options, {
	      responseType: "arraybuffer"
	    }));
	  };


	  /*
	  get/put/post/deleteJson
	  
	  same as get/put/post/delete above
	  
	  except:
	    sent data should be plain objects which are JSON.stringified
	    response data is automatically JSON.parsed
	  
	    additional options are set:
	      responseType: "json"
	      headers:      Accept: 'application/json'
	   */

	  RestClient.getJson = function(url, options) {
	    return RestClient.restJsonRequest(merge(options, {
	      verb: "get",
	      url: url
	    }));
	  };

	  RestClient.deleteJson = function(url, options) {
	    return RestClient.restJsonRequest(merge(options, {
	      verb: "delete",
	      url: url
	    }));
	  };

	  RestClient.putJson = function(url, data, options) {
	    return RestClient.restJsonRequest(merge(options, {
	      verb: "put",
	      url: url,
	      data: data
	    }));
	  };

	  RestClient.postJson = function(url, data, options) {
	    return RestClient.restJsonRequest(merge(options, {
	      verb: "post",
	      url: url,
	      data: data
	    }));
	  };


	  /*
	  IN:
	    options:
	      verb: "GET", "PUT", "POST"
	      method: alias for verb
	  
	      data: data to restRequest - passed to xmlHttpRequest.restRequest
	  
	      plus all the options for get/put/post listed above
	      showProgressAfter: milliseconds (default: 100)
	        only show progress after # milliseconds
	  
	      onProgress: (requestStatus) ->
	        see "All callbacks" below for details about inputs.
	        Note that onProgress is triggered a little differently than
	        the normal XMLHttpRequest progress events:
	          - it will only be called after showProgressAfter ms
	          - it is guaranteed to be called after showProgressAfter ms if the request hasn't completed
	          - if the request completes before showProgressAfter ms, it will never be called
	  
	  OUT: see get/put/post above
	  
	  All callbacks look like this: (requestStatus) ->
	    requestStatus:
	      request:  XMLHttpRequest
	      progress: number # between 0 and 1
	      options:  options # passed-in options object
	      event:    the most recent event
	      response: # the processed response data, if ready
	      error:    # if any
	      status:   number # HTTP status code, if the request is complete
	  
	  EFFECT:
	   */

	  RestClient.restRequest = function(options) {
	    var data, formData, headers, k, method, onProgress, responseType, showProgressAfter, specifiedVerb, url, v, verb;
	    verb = options.verb, method = options.method, url = options.url, data = options.data, headers = options.headers, onProgress = options.onProgress, responseType = options.responseType, formData = options.formData, showProgressAfter = options.showProgressAfter;
	    if (!isNumber(showProgressAfter)) {
	      showProgressAfter = 100;
	    }
	    verb || (verb = method);
	    if (!(verb = RestClient.legalVerbs[specifiedVerb = verb])) {
	      throw new Error("invalid verb: " + specifiedVerb);
	    }
	    if (formData) {
	      if (data) {
	        throw new Error("can't specify both 'data' and 'formData'");
	      }
	      data = new FormData;
	      for (k in formData) {
	        v = formData[k];
	        data.append(k, v);
	      }
	    } else {
	      data = (data != null ? typeof data.toArrayBuffer === "function" ? data.toArrayBuffer() : void 0 : void 0) || data;
	    }
	    return new Promise(function(resolve, reject) {
	      var getResponse, initialProgressCalled, lastProgressEvent, progressCallbackInternal, request, requestResolved, rescuedGetResponse, restRequestStatus;
	      restRequestStatus = {
	        request: request = new XMLHttpRequest,
	        progress: 0,
	        options: options
	      };
	      rescuedGetResponse = function() {
	        try {
	          return getResponse();
	        } catch (error1) {
	          return request.response;
	        }
	      };
	      getResponse = function() {
	        var response;
	        response = request.response;
	        if (response && responseType === "json") {
	          return JSON.parse(response);
	        } else {
	          return response;
	        }
	      };
	      request.open(verb, url, true);
	      if (present(responseType) && responseType !== "json") {
	        request.responseType = responseType;
	      }
	      if (headers) {
	        for (k in headers) {
	          v = headers[k];
	          request.setRequestHeader(k, v);
	        }
	      }
	      requestResolved = false;
	      request.addEventListener("error", function(event) {
	        requestResolved = true;
	        return reject(merge(restRequestStatus, {
	          event: event,
	          response: rescuedGetResponse(),
	          error: "XMLHttpRequest triggered 'error' event"
	        }));
	      });
	      request.addEventListener("load", function(event) {
	        var error, status;
	        requestResolved = true;
	        status = request.status;
	        if ((status / 100 | 0) === 2) {
	          try {
	            return resolve(getResponse());
	          } catch (error1) {
	            error = error1;
	            return reject(merge(restRequestStatus, {
	              event: event,
	              status: status,
	              response: rescuedGetResponse(),
	              error: error
	            }));
	          }
	        } else {
	          return reject(merge(restRequestStatus, {
	            event: event,
	            status: status,
	            response: rescuedGetResponse(),
	            error: "response status was " + status
	          }));
	        }
	      });
	      if (onProgress) {
	        initialProgressCalled = showProgressAfter <= 0;
	        lastProgressEvent = null;
	        timeout(showProgressAfter, function() {
	          initialProgressCalled = true;
	          return progressCallbackInternal(lastProgressEvent || {});
	        });
	        progressCallbackInternal = function(event) {
	          var loaded, ref, total;
	          ref = lastProgressEvent = event, total = ref.total, loaded = ref.loaded;
	          if (initialProgressCalled && !requestResolved) {
	            return typeof onProgress === "function" ? onProgress(restRequestStatus = merge(restRequestStatus, {
	              event: event,
	              progress: total > 0 ? loaded / total : 0
	            })) : void 0;
	          }
	        };
	        if (verb === "GET") {
	          request.addEventListener("progress", progressCallbackInternal);
	        } else {
	          request.upload.addEventListener("progress", progressCallbackInternal);
	        }
	      }
	      return request.send(data);
	    });
	  };

	  RestClient.restJsonRequest = function(options) {
	    return this.restRequest(merge(options, {
	      responseType: "json",
	      headers: merge({
	        Accept: 'application/json'
	      }, options != null ? options.headers : void 0),
	      data: (options != null ? options.data : void 0) && JSON.stringify(options.data)
	    }));
	  };

	  return RestClient;

	})();


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, ClassSystem, Map, SingleObjectTransaction, StandardLib, cloneByStructure, eq, inspect, removeFirstMatch, rubyTrue,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	StandardLib = __webpack_require__(29);

	ClassSystem = __webpack_require__(78);

	Map = StandardLib.Map, cloneByStructure = StandardLib.cloneByStructure, removeFirstMatch = StandardLib.removeFirstMatch, eq = StandardLib.eq, inspect = StandardLib.inspect, rubyTrue = StandardLib.rubyTrue;

	BaseObject = ClassSystem.BaseObject;

	module.exports = SingleObjectTransaction = (function(superClass) {
	  var setValues;

	  extend(SingleObjectTransaction, superClass);

	  function SingleObjectTransaction(a) {
	    var options;
	    SingleObjectTransaction.__super__.constructor.apply(this, arguments);
	    this.object = (function() {
	      if (a.constructor === Array) {
	        if (a.length !== 2) {
	          throw new Error("new SingleObjectTransaction: expected length-2 array like: [obj, optionsMap]");
	        }
	        this.options = a[1];
	        return a[0];
	      } else {
	        this.options = {};
	        return a;
	      }
	    }).call(this);
	    if (this.object == null) {
	      throw new Error("object must not be null or undefined");
	    }
	    this.props = [];
	    this.from = {};
	    options = this.options;
	    if (options.properties) {
	      this.addProperties(options.properties);
	    }
	    if (options.property) {
	      this.addProp(options.property);
	    }
	    if (options.from) {
	      this.addFromValues(options.from);
	    }
	    if (options.to) {
	      this.addToValues(options.to);
	    }
	  }

	  SingleObjectTransaction.prototype.toString = function() {
	    return (inspect(this.object, 0)) + " from:" + (inspect(this.from, 1)) + " to:" + (inspect(this.to, 1));
	  };

	  SingleObjectTransaction.prototype.inspect = function(inspector) {
	    var i, k, len, ref, results;
	    if (!inspector) {
	      return ClassSystem.Inspect.inspect(this);
	    }
	    inspector.put(this.object.classPathName + ":");
	    ref = this.props;
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      k = ref[i];
	      inspector.put("\n    " + k + ": ");
	      if (rubyTrue(this.from && this.from[k])) {
	        inspector.inspect(this.from[k], 1);
	      }
	      inspector.put(" ... ");
	      if (rubyTrue(this.to && this.to[k])) {
	        results.push(inspector.inspect(this.to[k], 1));
	      } else {
	        results.push(void 0);
	      }
	    }
	    return results;
	  };

	  SingleObjectTransaction.getter({
	    properties: function() {
	      return this.props;
	    },
	    hasToValues: function() {
	      return !!this.to;
	    },
	    valuesChanged: function() {
	      var fromValue, k, ref, toValue;
	      ref = this.from;
	      for (k in ref) {
	        fromValue = ref[k];
	        toValue = this.to[k];
	        if (!eq(fromValue, toValue)) {
	          return true;
	        }
	      }
	      return false;
	    }
	  });

	  SingleObjectTransaction.prototype.addFromValues = function(from) {
	    var base, k, v;
	    for (k in from) {
	      v = from[k];
	      this.addProp(k);
	      this.from[k] = v;
	    }
	    return typeof (base = this.object).preprocessProperties === "function" ? base.preprocessProperties(this.from) : void 0;
	  };

	  SingleObjectTransaction.prototype.addToValues = function(to) {
	    var base, k, v;
	    this.to || (this.to = {});
	    for (k in to) {
	      v = to[k];
	      this.addProp(k);
	      this.to[k] = v;
	    }
	    return typeof (base = this.object).preprocessProperties === "function" ? base.preprocessProperties(this.to) : void 0;
	  };

	  SingleObjectTransaction.prototype.addProperties = function(props) {
	    var i, len, prop, results, results1, v;
	    if (props.constructor === Array) {
	      results = [];
	      for (i = 0, len = props.length; i < len; i++) {
	        prop = props[i];
	        results.push(this.addProp(prop));
	      }
	      return results;
	    } else {
	      results1 = [];
	      for (prop in props) {
	        v = props[prop];
	        results1.push(this.addProp(prop));
	      }
	      return results1;
	    }
	  };

	  SingleObjectTransaction.prototype.addProp = function(propName) {
	    if (indexOf.call(this.props, propName) < 0) {
	      return this.props.push(propName);
	    }
	  };

	  SingleObjectTransaction.prototype.deleteProp = function(propName) {
	    removeFirstMatch(this.props, propName);
	    delete this.from[propName];
	    return delete this.to[propName];
	  };

	  SingleObjectTransaction.prototype.saveValues = function(saveTo) {
	    var getterName, i, len, metaProperties, prop, ref, ref1, value;
	    this.clearOptimizations();
	    metaProperties = this.object.metaProperties;
	    ref = this.props;
	    for (i = 0, len = ref.length; i < len; i++) {
	      prop = ref[i];
	      if (!saveTo.hasOwnProperty(prop)) {
	        value = saveTo[prop] = cloneByStructure((getterName = metaProperties != null ? (ref1 = metaProperties[prop]) != null ? ref1.getterName : void 0 : void 0) ? this.object[getterName]() : this.object[prop]);
	      }
	    }
	    return null;
	  };

	  SingleObjectTransaction.prototype.saveFromValues = function() {
	    return this.saveValues(this.from || (this.from = {}));
	  };

	  SingleObjectTransaction.prototype.saveToValues = function() {
	    return this.saveValues(this.to || (this.to = {}));
	  };

	  SingleObjectTransaction._setValues = setValues = function(o, values, f) {
	    var metaProperties, prop, ref, setterName, v;
	    metaProperties = o.metaProperties;
	    for (prop in values) {
	      v = values[prop];
	      if (f) {
	        v = f(prop, v);
	      }
	      if (setterName = metaProperties != null ? (ref = metaProperties[prop]) != null ? ref.setterName : void 0 : void 0) {
	        o[setterName](v);
	      } else {
	        o[prop] = v;
	      }
	    }
	    return null;
	  };

	  SingleObjectTransaction.prototype.rollBack = function() {
	    return setValues(this.object, this.from);
	  };

	  SingleObjectTransaction.prototype.rollForward = function() {
	    return setValues(this.object, this.to);
	  };

	  SingleObjectTransaction.prototype.clearOptimizations = function() {
	    return this.numberDeltas = this.interpolateToObjects = null;
	  };

	  SingleObjectTransaction.prototype.optimizeInterpolation = function() {
	    var field, from, ref, results, to;
	    this.numberDeltas = {};
	    this.interpolateToObjects = {};
	    this.nonInterpolatingFields = {
	      to: {},
	      from: {}
	    };
	    ref = this.from;
	    results = [];
	    for (field in ref) {
	      from = ref[field];
	      to = this.to[field];
	      if (typeof from === "number") {
	        results.push(this.numberDeltas[field] = to - from);
	      } else if (typeof (from != null ? from.interpolate : void 0) === "function") {
	        results.push(this.interpolateToObjects[field] = to);
	      } else {
	        this.nonInterpolatingFields.from[field] = from;
	        results.push(this.nonInterpolatingFields.to[field] = to);
	      }
	    }
	    return results;
	  };

	  SingleObjectTransaction.prototype.interpolateNumberFields = function(p) {
	    return setValues(this.object, this.numberDeltas, (function(_this) {
	      return function(field, delta) {
	        return _this.from[field] + delta * p;
	      };
	    })(this));
	  };

	  SingleObjectTransaction.prototype.interpolateObjectFields = function(p) {
	    var e;
	    try {
	      return setValues(this.object, this.interpolateToObjects, (function(_this) {
	        return function(field, toObject) {
	          return _this.from[field].interpolate(toObject, p);
	        };
	      })(this));
	    } catch (error) {
	      e = error;
	      this.log("Art.Foundation.Transaction#interpolateObjectFields(p=" + p + "): error " + e + " deltas: " + (inspect(this.interpolateToObjects)) + " from:   " + (inspect(this.from)) + " to:     " + (inspect(this.to)));
	      throw e;
	    }
	  };

	  SingleObjectTransaction.prototype.setNonInterpolatingFields = function(p) {
	    return setValues(this.object, this.nonInterpolatingFields[p >= 1 ? "to" : "from"]);
	  };

	  SingleObjectTransaction.prototype.interpolate = function(p) {
	    if (!this.numberDeltas) {
	      this.optimizeInterpolation();
	    }
	    this.interpolateNumberFields(p);
	    this.interpolateObjectFields(p);
	    return this.setNonInterpolatingFields(p);
	  };

	  SingleObjectTransaction.getter({
	    noChanges: function() {
	      return this.props.length === 0;
	    }
	  });

	  SingleObjectTransaction.prototype.optimizeProperties = function() {
	    var i, len, prop, ref, results;
	    this.clearOptimizations();
	    ref = this.props;
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      prop = ref[i];
	      if (!this.from.hasOwnProperty(prop) || !this.to.hasOwnProperty(prop) || eq(this.from[prop], this.to[prop])) {
	        results.push(this.deleteProp(prop));
	      } else {
	        results.push(void 0);
	      }
	    }
	    return results;
	  };

	  return SingleObjectTransaction;

	})(BaseObject);


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, ClassSystem, StandardLib, Stat, inspect, max, min, round,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	StandardLib = __webpack_require__(29);

	ClassSystem = __webpack_require__(78);

	BaseObject = ClassSystem.BaseObject;

	min = StandardLib.min, max = StandardLib.max, round = StandardLib.round, inspect = StandardLib.inspect;

	module.exports = Stat = (function(superClass) {
	  extend(Stat, superClass);

	  function Stat() {
	    this.reset();
	  }

	  Stat.prototype.reset = function() {
	    this.values = [];
	    this.sum = 0;
	    return this.max = this.min = null;
	  };

	  Stat.getter({
	    length: function() {
	      return this.values.length;
	    },
	    average: function() {
	      return this.sum / this.values.length;
	    },
	    median: function() {
	      return this.values.slice().sort()[this.length / 2 | 0];
	    }
	  });

	  Stat.prototype.percential = function(zeroToOneHundred) {
	    var i, sorted;
	    i = ((this.length - 1) * zeroToOneHundred / 100) | 0;
	    sorted = this.values.slice().sort(function(v1, v2) {
	      return v2 - v1;
	    });
	    return sorted[i];
	  };

	  Stat.prototype.histogram = function(divisions, min, max) {
	    var bin, delta, hist, j, k, len, mul, ref, ref1, v;
	    if (min == null) {
	      min = this.min;
	    }
	    if (max == null) {
	      max = this.max;
	    }
	    delta = max - min;
	    mul = divisions / delta;
	    hist = {};
	    for (v = j = 0, ref = divisions; j < ref; v = j += 1) {
	      hist[min + v / mul] = 0;
	    }
	    ref1 = this.values;
	    for (k = 0, len = ref1.length; k < len; k++) {
	      v = ref1[k];
	      bin = (v - min) * mul | 0;
	      if (bin < 0) {
	        bin = 0;
	      }
	      if (bin >= divisions) {
	        bin = divisions - 1;
	      }
	      hist[min + bin / mul]++;
	    }
	    return hist;
	  };

	  Stat.prototype.toString = function() {
	    return inspect({
	      length: this.length,
	      average: this.average,
	      median: this.median,
	      min: this.min,
	      max: this.max
	    });
	  };

	  Stat.prototype.toInfoMap = function() {
	    return {
	      length: this.length,
	      average: this.average,
	      median: this.median,
	      min: this.min,
	      max: this.max,
	      p90: this.percential(90),
	      p95: this.percential(95),
	      p99: this.percential(99)
	    };
	  };

	  Stat.prototype.toIntInfoMap = function() {
	    return {
	      length: this.length,
	      average: round(this.average),
	      median: round(this.median),
	      min: round(this.min),
	      max: round(this.max),
	      p90: round(this.percential(90)),
	      p95: round(this.percential(95)),
	      p99: round(this.percential(99))
	    };
	  };

	  Stat.prototype.toIntString = function() {
	    return inspect(this.toIntInfoMap());
	  };

	  Stat.prototype.add = function(v) {
	    this.values.push(v);
	    this.sum += v;
	    if (this.values.length === 1) {
	      return this.max = this.min = v;
	    } else {
	      this.max = max(this.max, v);
	      return this.min = min(this.min, v);
	    }
	  };

	  return Stat;

	})(BaseObject);


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	Transaction provides a manual, yet easy way to log the before and after values
	of fields over many objects.

	It is "manual" in that you must:

	  Pre-specify all objects you wish to track.
	  Specify the properties you wish to track for all objects and/or uniquely for each object.
	  Pass in the "from" values or call saveFromValues
	  Pass in the "to" values or call saveToValues

	Once you have capture the "from" and "to" values of the transaction, you can:

	  rollBack and set all properties to their "from" values
	  rollForward and set all properties to their "to" values
	  interpolate(p) and set all properties to their linearly interpolated value
	    between their saved "from" (p=0) and "to" (p=1) values.
	    If you use interpolate:
	      to/from values should be pair-wise the same type
	      only to/from values of the following types will be interpolated:
	        numbers
	        objects implementing: a.add(b), a.sub(b) and a.mul(number)
	      Non-interpolatable types are handled as follows:
	        switch p
	          when 0 then set to "from" values
	          when 1 then set to "to" values
	          else left unchanged

	Example initializers:

	   * example-a: track obj's "foo" and "bar" properties
	  new Transaction obj, properties: ["foo", "bar"]

	   * same as example-a, but also initialize obj's from-values as obj.foo=1 and obj.bar=2
	  new Transaction obj, from: foo:1, bar:2

	   * same as example-a, but also initialize obj's to-values as obj.foo=1 and obj.bar=2
	  new Transaction obj, to: foo:1, bar:2

	   * track obj1 and obj2's "foo" and "bar" properties
	  new Transaction [obj1, obj2], properties: ["foo", "bar"]

	   * track:
	   *   obj1's foo, bar, noo and mar properties, with both from and to values initialized
	   *   obj2's goo, har, noo and mar properties, with both from and to values initialized
	  new Transaction [
	      [obj1,
	        from: foo:1, bar:2
	        to:   foo:2, bar:3
	      ],
	      [obj2,
	        from: goo:1, har:2
	        to:   goo:2, har:3
	      ]
	    ],
	    from: noo:4, mar:5
	    to:   noo:4, mar:5
	 */
	var BaseObject, ClassSystem, Map, SingleObjectTransaction, StandardLib, Transaction, cloneByStructure, eq, inspect, rubyTrue,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	StandardLib = __webpack_require__(29);

	ClassSystem = __webpack_require__(78);

	SingleObjectTransaction = __webpack_require__(104);

	rubyTrue = StandardLib.rubyTrue, eq = StandardLib.eq, inspect = StandardLib.inspect, Map = StandardLib.Map, cloneByStructure = StandardLib.cloneByStructure;

	BaseObject = ClassSystem.BaseObject;

	module.exports = Transaction = (function(superClass) {
	  extend(Transaction, superClass);

	  Transaction.SingleObjectTransaction = SingleObjectTransaction;

	  function Transaction(objects, options) {
	    if (options == null) {
	      options = {};
	    }
	    Transaction.__super__.constructor.apply(this, arguments);
	    this._objects = new Map;
	    if (objects.constructor === Array) {
	      this.addObjects(objects);
	    } else {
	      this.addObject(objects);
	    }
	    if (options.properties) {
	      this.addProperties(options.properties);
	    }
	    if (options.property) {
	      this.addProperties([options.property]);
	    }
	    if (options.from) {
	      this.addFromValues(options.from);
	    }
	    if (options.to) {
	      this.addToValues(options.to);
	    }
	    this.saveFromValues();
	  }

	  Transaction.prototype.inspect = function(inspector) {
	    if (!inspector) {
	      return ClassSystem.Inspect.inspect(this);
	    }
	    inspector.put(this.classPathName + ":");
	    return this.inspectParts(inspector);
	  };

	  Transaction.prototype.inspectParts = function(inspector) {
	    return this._objects.each((function(_this) {
	      return function(k, v) {
	        inspector.put("\n  ");
	        return inspector.inspect(v);
	      };
	    })(this));
	  };

	  Transaction.getter({
	    objects: function() {
	      return this._objects.keys;
	    }
	  });

	  Transaction.prototype.properties = function(obj) {
	    return this._objects.get(obj).properties;
	  };

	  Transaction.prototype.from = function(obj) {
	    return this._objects.get(obj).from;
	  };

	  Transaction.prototype.to = function(obj) {
	    return this._objects.get(obj).to;
	  };

	  Transaction.prototype.rollBack = function() {
	    return this._objects.forEach((function(_this) {
	      return function(oi) {
	        return oi.rollBack();
	      };
	    })(this));
	  };

	  Transaction.prototype.rollForward = function() {
	    return this._objects.forEach((function(_this) {
	      return function(oi) {
	        return oi.rollForward();
	      };
	    })(this));
	  };

	  Transaction.prototype.interpolate = function(p) {
	    return this._objects.forEach((function(_this) {
	      return function(oi) {
	        return oi.interpolate(p);
	      };
	    })(this));
	  };

	  Transaction.prototype.optimize = function() {
	    this.optimizeProperties();
	    return this.optimizeObjects();
	  };

	  Transaction.getter({
	    hasToValues: function() {
	      var result;
	      result = false;
	      this._objects.forEach((function(_this) {
	        return function(oi) {
	          if (oi.hasToValues) {
	            return result = true;
	          }
	        };
	      })(this));
	      return result;
	    },
	    valuesChanged: function() {
	      var result;
	      result = false;
	      this._objects.forEach((function(_this) {
	        return function(object) {
	          if (object.valuesChanged) {
	            return result = true;
	          }
	        };
	      })(this));
	      return result;
	    }
	  });

	  Transaction.prototype.toString = function() {
	    return (this.className + "\n  ") + (this._objects.map(function(obj, single) {
	      return single.toString();
	    })).join("  \n");
	  };

	  Transaction.prototype.addFromValues = function(from) {
	    return this._objects.forEach((function(_this) {
	      return function(oi) {
	        return oi.addFromValues(from);
	      };
	    })(this));
	  };

	  Transaction.prototype.addToValues = function(to) {
	    return this._objects.forEach((function(_this) {
	      return function(oi) {
	        return oi.addToValues(to);
	      };
	    })(this));
	  };

	  Transaction.prototype.addProperties = function(properties) {
	    return this._objects.forEach((function(_this) {
	      return function(oi) {
	        return oi.addProperties(properties);
	      };
	    })(this));
	  };

	  Transaction.prototype.addObject = function(obj) {
	    var oi;
	    oi = new SingleObjectTransaction(obj);
	    return this._objects.set(oi.object, oi);
	  };

	  Transaction.prototype.addObjects = function(objects) {
	    var i, len, obj, results;
	    results = [];
	    for (i = 0, len = objects.length; i < len; i++) {
	      obj = objects[i];
	      results.push(this.addObject(obj));
	    }
	    return results;
	  };

	  Transaction.prototype.saveFromValues = function() {
	    return this._objects.forEach((function(_this) {
	      return function(oi) {
	        return oi.saveFromValues();
	      };
	    })(this));
	  };

	  Transaction.prototype.saveToValues = function() {
	    return this._objects.forEach((function(_this) {
	      return function(oi) {
	        return oi.saveToValues();
	      };
	    })(this));
	  };

	  Transaction.prototype.optimizeProperties = function() {
	    return this._objects.forEach((function(_this) {
	      return function(oi) {
	        return oi.optimizeProperties();
	      };
	    })(this));
	  };

	  Transaction.prototype.optimizeObjects = function() {
	    var objs;
	    objs = this._objects;
	    this._objects = new Map;
	    return objs.forEach((function(_this) {
	      return function(oi) {
	        if (!oi.noChanges) {
	          return _this._objects.set(oi.object, oi);
	        }
	      };
	    })(this));
	  };

	  return Transaction;

	})(BaseObject);


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, Promise, StandardLib, Validator, emailRegexp, formattedInspect, isBoolean, isFunction, isHexColor, isId, isNumber, isPlainArray, isPlainObject, isString, log, merge, mergeIntoUnless, present, select, shallowClone, validStatus, w,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	StandardLib = __webpack_require__(29);

	merge = StandardLib.merge, log = StandardLib.log, BaseObject = StandardLib.BaseObject, shallowClone = StandardLib.shallowClone, isNumber = StandardLib.isNumber, isString = StandardLib.isString, isPlainObject = StandardLib.isPlainObject, isPlainArray = StandardLib.isPlainArray, Promise = StandardLib.Promise, isBoolean = StandardLib.isBoolean, formattedInspect = StandardLib.formattedInspect, present = StandardLib.present, select = StandardLib.select, emailRegexp = StandardLib.emailRegexp, mergeIntoUnless = StandardLib.mergeIntoUnless, w = StandardLib.w, isFunction = StandardLib.isFunction;

	validStatus = __webpack_require__(99).validStatus;


	/*
	NOTES:

	  validators are evaluated before preprocessors

	  preprocessors should NOT throw validation-related errors

	  TODO?: We could add postValidators to allow you to validate AFTER the preprocessor...

	USAGE:
	  new Validator validatorFieldsProps, options

	    IN:
	      validatorFieldsProps:
	        plain object with zero or more field-validations defined:
	          fieldName: fieldProps
	      options:
	        exclusive: true/false
	          if true, only fields listed in validatorFieldsProps are allowed.

	    fieldProps:
	      string or plainObject
	      string: selects fieldProps from one of the standard @fieldTypes (see below)
	      plainObject: (all fields are optional)

	        validate: (v) -> true/false
	          whenever this field is included in an update OR create operation,
	            validate() must return true
	          NOTE: is evaluated BEFORE preprocess

	        preprocess: (v1) -> v2
	          whenever this field is included in an update OR create operation,
	            after validation succeeds,
	            value = preprocess value

	        required: true/false/string
	          if true/string
	            when creating records, this field must be included
	          if string
	            fieldProps = merge fieldProps, fieldTypes[string]

	        present: true/false
	          if true
	            when creating records, this field must be include and 'present' (see Art.Foundation.present)

	        fieldType: string
	          fieldProps = merge fieldTypes[string], fieldProps

	        dataType: string
	          sepecify which of the standard Json data-types this field contains
	          This is not used by Validator itself, but is available for clients to reflect on field-types.
	          Must be one of the values in: @dataTypes

	        instanceof: class
	          in addition to passing validate(), if present, the value must also be an instance of the
	          specified class

	EXAMPLES:
	  new
	 */

	BaseObject = __webpack_require__(78).BaseObject;

	isId = function(v) {
	  return isString(v) && v.match(/^[-_a-z0-9]+$/i);
	};

	isHexColor = function(v) {
	  return isString(v) && v.match(/^#([a-f0-9]{3})|([a-f0-9]{6})/i);
	};

	module.exports = Validator = (function(superClass) {
	  var arrayDataType, booleanDataType, dataTypes, fieldTypes, k, normalizeDepricatedProps, normalizeFieldProps, normalizeFieldTypeProp, normalizeInstanceOfProp, normalizePlainObjectProps, numberDataType, objectDataType, preCreate, preCreateSync, stringDataType, v;

	  extend(Validator, superClass);


	  /*
	  @dataTypes only includes the Standard Json types:
	    except 'null':
	      no field has the type of 'null'
	      instead, it has some other type and can be 'null' unless it is 'required'
	   */

	  Validator.dataTypes = dataTypes = {
	    boolean: {
	      validate: function(a) {
	        return isBoolean(a);
	      }
	    },
	    number: {
	      validate: function(a) {
	        return isNumber(a);
	      }
	    },
	    string: {
	      validate: function(a) {
	        return isString(a);
	      }
	    },
	    object: {
	      validate: function(a) {
	        return isPlainObject(a);
	      }
	    },
	    array: {
	      validate: function(a) {
	        return isPlainArray(a);
	      }
	    },
	    "function": {
	      validate: function(a) {
	        return isFunction(a);
	      }
	    }
	  };

	  booleanDataType = "boolean";

	  numberDataType = "number";

	  stringDataType = "string";

	  objectDataType = "object";

	  arrayDataType = "array";


	  /*
	  standard FieldType props:
	    validate: (v) -> true/false
	    preprocess: (v1) -> v2
	    required: true/false
	    dataType: one of @dataTypes, default: 'string'
	  
	  You can add your own, too, but they are ignored by this class.
	   */

	  Validator.fieldTypes = fieldTypes = {
	    boolean: {
	      dataType: booleanDataType
	    },
	    number: {
	      dataType: numberDataType
	    },
	    string: {},
	    object: {
	      dataType: objectDataType
	    },
	    array: {
	      dataType: arrayDataType
	    },
	    count: {
	      dataType: numberDataType
	    },
	    id: {
	      required: true,
	      validate: function(v) {
	        return isId(v);
	      }
	    },
	    date: {
	      validate: function(v) {
	        return isString(v) || (v instanceof Date);
	      },
	      preprocess: function(v) {
	        if (isString(v)) {
	          return new Date(v);
	        } else {
	          return v;
	        }
	      }
	    },
	    timestamp: {
	      dataType: numberDataType,
	      validate: function(v) {
	        return isNumber(v) || (v instanceof Date);
	      },
	      preprocess: function(v) {
	        if (v instanceof Date) {
	          return v - 0;
	        } else {
	          return v;
	        }
	      }
	    },
	    color: {
	      validate: function(v) {
	        return isHexColor(v);
	      }
	    },
	    email: {
	      validate: function(v) {
	        return isString(v) && v.trim().match(emailRegexp);
	      },
	      preprocess: function(v) {
	        return v.trim().toLowerCase();
	      }
	    },
	    url: {
	      validate: function(v) {
	        return isString(v) && v.match(urlRegexp);
	      },
	      preprocess: function(v) {
	        return normalizeUrl(v);
	      }
	    },
	    communicationStatus: {
	      validate: function(v) {
	        return validStatus(v);
	      }
	    },
	    trimmedString: {
	      validate: function(v) {
	        return isString(v);
	      },
	      preprocess: function(v) {
	        return v.trim();
	      }
	    },
	    "function": {
	      dataType: "function"
	    }
	  };

	  for (k in fieldTypes) {
	    v = fieldTypes[k];
	    v.dataType || (v.dataType = stringDataType);
	    v.validate || (v.validate = dataTypes[v.dataType].validate);
	  }

	  normalizeInstanceOfProp = function(ft) {
	    var _instanceof, validate;
	    if (_instanceof = ft["instanceof"]) {
	      validate = ft.validate;
	      return merge(ft, {
	        validate: function(v) {
	          return (v instanceof _instanceof) && (!validate || validate(v));
	        }
	      });
	    } else {
	      return ft;
	    }
	  };

	  normalizePlainObjectProps = function(ft) {
	    var out, subObject;
	    out = null;
	    for (k in ft) {
	      v = ft[k];
	      if (isPlainObject(subObject = v)) {
	        if (!out) {
	          out = shallowClone(ft);
	        }
	        out[k] = true;
	        mergeIntoUnless(out, normalizePlainObjectProps(subObject));
	      }
	    }
	    return out || ft;
	  };

	  normalizeDepricatedProps = function(ft) {
	    if (ft.requiredPresent) {
	      throw new Error("DEPRICATED: requiredPresent. Use: present: true");
	    }
	    if (isString(ft.required)) {
	      throw new Error("DEPRICATED: required can no longer specifiy the field-type. Use: required: fieldType: myFieldTypeString OR 'required myFieldTypeString'");
	    }
	    if (isString(ft.present)) {
	      throw new Error("DEPRICATED: present can no longer specifiy the field-type. Use: present: fieldType: myFieldTypeString OR 'present myFieldTypeString'");
	    }
	    return ft;
	  };

	  normalizeFieldTypeProp = function(ft) {
	    if (ft.fieldType) {
	      return merge(normalizeFieldProps(ft.fieldType), ft);
	    } else {
	      return ft;
	    }
	  };

	  Validator.normalizeFieldProps = normalizeFieldProps = function(ft) {
	    var array, processed, string, strings, subFt;
	    ft = (function() {
	      var i, len, ref;
	      if (isPlainObject(ft)) {
	        return normalizeFieldTypeProp(normalizeInstanceOfProp(normalizeDepricatedProps(normalizePlainObjectProps(ft))));
	      } else if (isPlainArray(array = ft)) {
	        processed = (function() {
	          var i, len, results;
	          results = [];
	          for (i = 0, len = array.length; i < len; i++) {
	            ft = array[i];
	            results.push(normalizeFieldProps(ft));
	          }
	          return results;
	        })();
	        return merge.apply(null, processed);
	      } else if (isString(strings = ft)) {
	        ft = {};
	        ref = w(strings);
	        for (i = 0, len = ref.length; i < len; i++) {
	          string = ref[i];
	          if (subFt = fieldTypes[string]) {
	            mergeIntoUnless(ft, subFt);
	          } else {
	            ft[string] = true;
	          }
	        }
	        return ft;
	      } else {
	        throw new Error("fieldType must be a string or plainObject: " + (formattedInspect(ft)));
	      }
	    })();
	    return merge(fieldTypes[ft.fieldType], ft);
	  };

	  function Validator(fieldDeclarationMap, options) {
	    this._fieldProps = {};
	    this._requiredFieldsMap = {};
	    this.addFields(fieldDeclarationMap);
	    if (options) {
	      this.exclusive = options.exclusive, this.context = options.context;
	    }
	  }

	  Validator.property("exclusive");

	  Validator.prototype.addFields = function(fieldDeclarationMap) {
	    var field, fieldOptions;
	    for (field in fieldDeclarationMap) {
	      fieldOptions = fieldDeclarationMap[field];
	      fieldOptions = this._addField(field, fieldOptions);
	      if (fieldOptions.required) {
	        this._requiredFieldsMap[field] = void 0;
	      }
	    }
	    return null;
	  };


	  /*
	  IN:
	    fields: object with fields to validate OR Promise returning said object
	  
	  OUT:
	    promise.then (validatedPreprocessedFields) ->
	    .catch (validationFailureInfoObject) ->
	   */

	  Validator.prototype.preCreate = preCreate = function(fields, options) {
	    return Promise.resolve(fields).then((function(_this) {
	      return function(fields) {
	        return _this.preCreateSync(fields, options);
	      };
	    })(this));
	  };

	  Validator.prototype.validate = preCreate;


	  /*
	  IN:
	    fields: object with fields to validate OR Promise returning said object
	  
	  OUT:
	    promise.then (validatedPreprocessedFields) ->
	    .catch (validationFailureInfoObject) ->
	   */

	  Validator.prototype.preUpdate = function(fields, options) {
	    return Promise.resolve(fields).then((function(_this) {
	      return function(fields) {
	        return _this.preUpdateSync(fields, options);
	      };
	    })(this));
	  };

	  Validator.prototype.preCreateSync = preCreateSync = function(fields, options) {
	    var info, presentFieldsValid, requiredFieldsPresent, status;
	    requiredFieldsPresent = this.requiredFieldsPresent(fields);
	    presentFieldsValid = this.presentFieldsValid(fields);
	    if (requiredFieldsPresent && presentFieldsValid) {
	      return this.preprocessFields(fields);
	    } else {
	      status = !presentFieldsValid ? !requiredFieldsPresent ? "invalid and missing" : "invalid" : "missing";
	      info = {
	        validationFailure: ((options != null ? options.context : void 0) || this.context || "Validator") + ": create: field(s) are " + status
	      };
	      if (!presentFieldsValid) {
	        info.invalidFields = this.invalidFields(fields);
	      }
	      if (!requiredFieldsPresent) {
	        info.missingFields = this.missingFields(fields);
	      }
	      throw info;
	    }
	  };

	  Validator.prototype.validateSync = preCreateSync;

	  Validator.prototype.preUpdateSync = function(fields, options) {
	    if (this.presentFieldsValid(fields)) {
	      return this.preprocessFields(fields);
	    } else {
	      throw {
	        validationFailure: ((options != null ? options.context : void 0) || this.context || "Validator") + ": update: field(s) are invalid",
	        invalidFields: this.invalidFields(fields)
	      };
	    }
	  };

	  Validator.prototype.presentFieldValid = function(fields, fieldName) {
	    var fieldProps, validate, value;
	    if (fieldProps = this._fieldProps[fieldName]) {
	      validate = fieldProps.validate;
	      return !validate || ((value = fields[fieldName]) == null) || value === null || value === void 0 || validate(value);
	    } else {
	      return !this.exclusive;
	    }
	  };

	  Validator.prototype.requiredFieldPresent = function(fields, fieldName) {
	    var fieldProps;
	    if (!(fieldProps = this._fieldProps[fieldName])) {
	      return true;
	    }
	    if (fieldProps.required && (fields[fieldName] == null)) {
	      return false;
	    }
	    if (fieldProps.present && !present(fields[fieldName])) {
	      return false;
	    }
	    return true;
	  };

	  Validator.prototype.presentFieldsValid = function(fields) {
	    var __, fieldName;
	    for (fieldName in fields) {
	      __ = fields[fieldName];
	      if (!this.presentFieldValid(fields, fieldName)) {
	        return false;
	      }
	    }
	    return true;
	  };

	  Validator.prototype.requiredFieldsPresent = function(fields) {
	    var __, fieldName, ref;
	    ref = this._fieldProps;
	    for (fieldName in ref) {
	      __ = ref[fieldName];
	      if (!this.requiredFieldPresent(fields, fieldName)) {
	        return false;
	      }
	    }
	    return true;
	  };

	  Validator.prototype.preprocessFields = function(fields) {
	    var fieldName, oldV, preprocess, processedFields, ref, value;
	    processedFields = null;
	    ref = this._fieldProps;
	    for (fieldName in ref) {
	      preprocess = ref[fieldName].preprocess;
	      if (preprocess && ((value = fields[fieldName]) != null)) {
	        if ((v = preprocess(oldV = fields[fieldName])) !== oldV) {
	          processedFields || (processedFields = shallowClone(fields));
	          processedFields[fieldName] = v;
	        }
	      }
	    }
	    return processedFields || fields;
	  };

	  Validator.prototype.invalidFields = function(fields) {
	    return select(fields, (function(_this) {
	      return function(key, value) {
	        return !_this.presentFieldValid(fields, key);
	      };
	    })(this));
	  };

	  Validator.prototype.missingFields = function(fields) {
	    fields = merge(this._requiredFieldsMap, fields);
	    return select(fields, (function(_this) {
	      return function(key, value) {
	        return !_this.requiredFieldPresent(fields, key);
	      };
	    })(this));
	  };

	  Validator.prototype._addField = function(field, options) {
	    return this._fieldProps[field] = normalizeFieldProps(options);
	  };

	  return Validator;

	})(BaseObject);


/***/ },
/* 108 */
/***/ function(module, exports) {

	module.exports = {
		"author": "Shane Brinkman-Davis Delamore, Imikimi LLC",
		"dependencies": {
			"atob": "^2.0.3",
			"chai": "^3.5.0",
			"coffee-loader": "^0.7.2",
			"coffee-script": "^1.11.1",
			"commander": "^2.9.0",
			"css-loader": "^0.23.1",
			"json-loader": "^0.5.4",
			"mocha": "^2.5.3",
			"neptune-namespaces": "^1.5.0",
			"promise-polyfill": "^6.0.2",
			"script-loader": "^0.7.0",
			"sourcemapped-stacktrace": "^1.1.3",
			"style-loader": "^0.13.1",
			"webpack": "^1.13.2",
			"webpack-dev-server": "^1.16.2"
		},
		"description": "Foundation classes for the Art framework. Javascript extensions.",
		"license": "ISC",
		"name": "art-foundation",
		"scripts": {
			"dev": "neptune-namespaces --std; webpack-dev-server -d --progress",
			"hot": "neptune-namespaces --std; webpack-dev-server --hot --inline --progress",
			"nn": "neptune-namespaces --std",
			"nodeTest": "neptune-namespaces --std;mocha -u tdd --compilers coffee:coffee-script/register",
			"test": "neptune-namespaces --std; webpack-dev-server -d --progress"
		},
		"version": "1.23.0"
	};

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(110).includeInNamespace(__webpack_require__(111)).addModules({
	  Cookie: __webpack_require__(112),
	  DomElementFactories: __webpack_require__(113),
	  Dom: __webpack_require__(114),
	  File: __webpack_require__(115)
	});


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	var Browser, Foundation,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(26);

	module.exports = Foundation.Browser || Foundation.addNamespace('Browser', Browser = (function(superClass) {
	  extend(Browser, superClass);

	  function Browser() {
	    return Browser.__super__.constructor.apply(this, arguments);
	  }

	  return Browser;

	})(Neptune.Base));


/***/ },
/* 111 */
/***/ function(module, exports) {

	var Browser;

	module.exports = Browser = (function() {
	  var browserIsMobile, isMobileBrowserRegExp1, isMobileBrowserRegExp2;

	  function Browser() {}

	  isMobileBrowserRegExp1 = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i;

	  isMobileBrowserRegExp2 = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|agent wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|agent|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)agent|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[agent-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(agent|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-agent|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i;

	  browserIsMobile = null;

	  Browser.isMobileBrowser = function() {
	    var agent, check;
	    if (browserIsMobile != null) {
	      return browserIsMobile;
	    }
	    check = false;
	    agent = navigator.userAgent || navigator.vendor || window.opera;
	    return browserIsMobile = !!(isMobileBrowserRegExp1.test(agent) || isMobileBrowserRegExp2.test(agent.substr(0, 4)));
	  };

	  return Browser;

	})();


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, ClassSystem, Cookie, StandardLib, getCookie, isPlainArray, isPlainObject, isString, log, setCookie,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	StandardLib = __webpack_require__(29);

	ClassSystem = __webpack_require__(78);

	log = StandardLib.log, isString = StandardLib.isString, isPlainArray = StandardLib.isPlainArray, isPlainObject = StandardLib.isPlainObject;

	BaseObject = ClassSystem.BaseObject;

	setCookie = function(cookieName, cookieValue, arg) {
	  var cookieString, d, expires, path;
	  expires = arg.expires, path = arg.path;
	  if (!isString(cookieValue)) {
	    if (!(isPlainArray(cookieValue) || isPlainObject(cookieValue))) {
	      throw new Error("cookieValue must be a string, array or object");
	    }
	    cookieValue = JSON.stringify(cookieValue);
	  }
	  cookieString = cookieName + "=" + cookieValue;
	  if (expires) {
	    d = new Date();
	    d.setTime(d.getTime() + expires * 24 * 60 * 60 * 1000);
	    cookieString += "; expires=" + (d.toUTCString());
	  }
	  if (path) {
	    cookieString += "; path=" + path;
	  }
	  return document.cookie = cookieString;
	};

	getCookie = function(cookieName) {
	  var c, ca, i, len, name, value;
	  name = cookieName + "=";
	  ca = document.cookie.split(';');
	  for (i = 0, len = ca.length; i < len; i++) {
	    c = ca[i];
	    while (' ' === c.charAt(0)) {
	      c = c.substring(1);
	    }
	    if (0 === c.indexOf(name)) {
	      value = c.substring(name.length, c.length);
	      if (value.match(/^[{[]/)) {
	        value = JSON.parse(value);
	      }
	      return value;
	    }
	  }
	  return "";
	};

	module.exports = Cookie = (function(superClass) {
	  extend(Cookie, superClass);

	  function Cookie() {
	    return Cookie.__super__.constructor.apply(this, arguments);
	  }

	  Cookie.set = function(name, value, options) {
	    return setCookie(name, value, options);
	  };

	  Cookie.get = function(name) {
	    return getCookie(name);
	  };

	  Cookie.remove = function(name, options) {
	    return setCookie(name, {
	      path: options.path,
	      expires: -1
	    });
	  };

	  return Cookie;

	})(BaseObject);


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	var DomElementFactories, supportLibs,
	  slice = [].slice;

	supportLibs = [Neptune.NeptuneLib, __webpack_require__(42), __webpack_require__(93)];


	/*
	DomElementFactories allows for Art.React-style creation of DOM elements.

	 * HOW TO LOAD:
	 * -- IF: you are already using Art.Foundation
	Foundation = require 'art-foundation'
	{DomElementFactories} = Foundation.Browser

	 * -- IF: You have the Art.Foundation NPM but only want DomElementFactories:
	DomElementFactories = require 'art-foundation/dom_element_factories'

	 * -- IF: You just have dom_element_factories.js
	 * first, load it prior via a <script> tag, then:
	 * window.DomElementFactories will be set.

	Usage:

	{Div, Span, B, Em} = DomElementFactories

	mySharedTextStyle =
	  style:
	    fontSize: "16pt"
	    color: "#444"
	    fontFamily: "Times"

	Div
	  class: "foo"
	  id:    "123"

	Span
	  class: "dude"
	  "This is some really"
	  B "bold"
	  "text."
	  "Also, here is some"
	  Em "emphasized"
	  "text."

	Span mySharedTextStyle,
	  internalHTML: "Or you can do <b>this</b> and <em>this</em>."

	Div mySharedTextStyle,
	  style:
	    bottom:          0
	    height:          "50px"
	    left:            "100px"
	    right:           "100px"
	    position:        "fixed"
	    backgroundColor: "white"
	    textAlign:       "center"
	  "Styles are easy, too."

	VERSION HISTORY:
	  1.1.1 - added H2-H6
	  1.1.0 - new-lines in text-children become <BR> tags
	  1.0.0 - initial
	 */

	module.exports = DomElementFactories = (function() {
	  var isPlainObject, isString, j, k, len, mergeInto, ref, supportLib, v;

	  function DomElementFactories() {}

	  DomElementFactories.version = "1.1.1";

	  DomElementFactories.src = "https://github.com/Imikimi-LLC/art-foundation";

	  for (j = 0, len = supportLibs.length; j < len; j++) {
	    supportLib = supportLibs[j];
	    for (k in supportLib) {
	      v = supportLib[k];
	      DomElementFactories[k] = v;
	    }
	  }

	  DomElementFactories.isString = isString = function(obj) {
	    return typeof obj === "string";
	  };

	  DomElementFactories.isPlainObject = isPlainObject = function(obj) {
	    return obj.constructor === Object;
	  };

	  DomElementFactories.mergeInto = mergeInto = function(into, source) {
	    if (into == null) {
	      into = {};
	    }
	    for (k in source) {
	      v = source[k];
	      into[k] = v;
	    }
	    return into;
	  };

	  DomElementFactories.setDomElementProp = function(element, prop, value, oldValue) {
	    var clearStyle, setStyle, style;
	    switch (prop) {
	      case "class":
	        return element.className = value || "";
	      case "id":
	        return element.id = value || "";
	      case "innerHTML":
	        return element.innerHTML = value || "";
	      case "on":
	        if (!isPlainObject(value)) {
	          throw new Error("object expected for 'on' property");
	        }
	        setStyle = function(eventType, newEventListener) {
	          return element.addEventListener(eventType, newEventListener);
	        };
	        clearStyle = function(eventType, oldEventListener) {
	          return element.removeEventListner(eventType, oldEventListener);
	        };
	        return DomElementFactories.objectDiff(value, oldValue, setStyle, clearStyle, setStyle);
	      case "style":
	        if (!isPlainObject(value)) {
	          throw new Error("object expected for 'style' property");
	        }
	        style = element.style;
	        setStyle = function(k, v) {
	          return style[k] = v;
	        };
	        clearStyle = function(k) {
	          return style[k] = "";
	        };
	        return DomElementFactories.objectDiff(value, oldValue, setStyle, clearStyle, setStyle);
	      default:
	        return element.setAttribute(prop, value);
	    }
	  };

	  DomElementFactories.setDomElementProps = function(element, props) {
	    var results;
	    results = [];
	    for (k in props) {
	      v = props[k];
	      results.push(this.setDomElementProp(element, k, v));
	    }
	    return results;
	  };

	  DomElementFactories.setDomElementChildren = function(element, children) {
	    var child, i, l, len1, message, ref, ref1, ref2, results, text;
	    results = [];
	    for (l = 0, len1 = children.length; l < len1; l++) {
	      child = children[l];
	      if (isString(child)) {
	        results.push((function() {
	          var len2, m, ref, results1;
	          ref = child.split("\n");
	          results1 = [];
	          for (i = m = 0, len2 = ref.length; m < len2; i = ++m) {
	            text = ref[i];
	            if (i > 0) {
	              element.appendChild(document.createElement("br"));
	            }
	            results1.push(element.appendChild(document.createTextNode(text)));
	          }
	          return results1;
	        })());
	      } else {
	        if (!(child instanceof Node)) {
	          message = "DomElementFactory:" + nodeName + ": Child is not a string or instance of Node. Child: " + child;
	          (typeof Neptune !== "undefined" && Neptune !== null ? (ref = Neptune.Art) != null ? (ref1 = ref.Foundation) != null ? (ref2 = ref1.log) != null ? typeof ref2.error === "function" ? ref2.error(message, child) : void 0 : void 0 : void 0 : void 0 : void 0) || console.log(message, child);
	          throw new Error(message);
	        }
	        results.push(element.appendChild(child));
	      }
	    }
	    return results;
	  };


	  /*
	  IN: any combination of arrays and strings
	  OUT: All element-names found in all strings are used to generate dom-element-factory-functions
	    for elements with those names.
	    The output is a plain Object where they keys are the upperCamelCase version of the element-names
	    passed in. The values are the element-factories.
	   */

	  DomElementFactories.createDomElementFactories = function() {
	    var list;
	    list = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    return DomElementFactories.createObjectTreeFactories({
	      mergePropsInto: function(into, source) {
	        var results;
	        results = [];
	        for (k in source) {
	          v = source[k];
	          results.push(into[k] = k === "style" ? mergeInto(into[k], v) : v);
	        }
	        return results;
	      }
	    }, list, function(nodeName, props, children) {
	      var element;
	      element = document.createElement(nodeName);
	      DomElementFactories.setDomElementProps(element, props);
	      DomElementFactories.setDomElementChildren(element, children);
	      return element;
	    });
	  };

	  DomElementFactories.allDomElementNames = "A Abbr Acronym Address Applet Area Article Aside Audio B Base BaseFont Bdi Bdo Big BlockQuote Body Br Button Canvas Caption Center Cite Code Col ColGroup DataList Dd Del Details Dfn Dialog Dir Div Dl Dt Em Embed FieldSet FigCaption Figure Font Footer Form Frame FrameSet H1 H2 H3 H4 H5 H6 Head Header Hr Html I IFrame Img Input Ins Kbd KeyGen Label Legend Li Link Main Map Mark Menu MenuItem Meta Meter Nav NoFrames NoScript Object Ol OptGroup Option Output P Param Pre Progress Q Rp Rt Ruby S Samp Script Section Select Small Source Span Strike Strong Style Sub Summary Sup Table TBody Td TextArea TFoot Th THead Time Title Tr Track Tt U Ul Var Video Wbr";

	  ref = DomElementFactories.createDomElementFactories(DomElementFactories.allDomElementNames);
	  for (k in ref) {
	    v = ref[k];
	    DomElementFactories[k] = v;
	  }

	  return DomElementFactories;

	})();


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	var Dom, DomElementFactories, isString;

	DomElementFactories = __webpack_require__(113);

	isString = __webpack_require__(29).isString;

	module.exports = Dom = (function() {
	  function Dom() {}

	  Dom.createElementFromHtml = function(html) {
	    var div;
	    div = document.createElement('div');
	    div.innerHTML = html;
	    return div.firstChild;
	  };

	  Dom.createDomElementFactories = DomElementFactories.createDomElementFactories;

	  Dom.getDevicePixelRatio = function() {
	    return ((self.devicePixelRatio != null) && self.devicePixelRatio) || 1;
	  };

	  Dom.zIndex = function(target, setZIndex) {
	    var element, value;
	    if (!(target instanceof HTMLElement)) {
	      target = document.getElementById(target);
	    }
	    if (setZIndex !== void 0) {
	      return target.style.zIndex = setZIndex;
	    }
	    element = target;
	    while (element && element !== document) {
	      switch (element.style.position) {
	        case "absolute":
	        case "relative":
	        case "fixed":
	          value = parseInt(element.style.zIndex);
	          if (value < 0 || value > 0) {
	            return value;
	          }
	      }
	      element = element.parentElement;
	    }
	    return 0;
	  };

	  Dom.domElementOffset = function(element) {
	    var body, box, clientLeft, clientTop, documentElement, left, scrollLeft, scrollTop, top;
	    box = element.getBoundingClientRect();
	    body = document.body, documentElement = document.documentElement;
	    scrollTop = window.pageYOffset || documentElement.scrollTop || body.scrollTop;
	    scrollLeft = window.pageXOffset || documentElement.scrollLeft || body.scrollLeft;
	    clientTop = documentElement.clientTop || body.clientTop || 0;
	    clientLeft = documentElement.clientLeft || body.clientLeft || 0;
	    top = box.top + scrollTop - clientTop;
	    left = box.left + scrollLeft - clientLeft;
	    return {
	      top: Math.round(top),
	      left: Math.round(left)
	    };
	  };

	  return Dom;

	})();


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var File, Promise, StandardLib, createElementFromHtml;

	StandardLib = __webpack_require__(29);

	createElementFromHtml = __webpack_require__(114).createElementFromHtml;

	Promise = StandardLib.Promise;

	module.exports = File = (function() {
	  function File() {}

	  File.request = function(options) {
	    if (options == null) {
	      options = {};
	    }
	    return new Promise(function(resolve, reject) {
	      var accept, body, fileInput, multiple, onChange, ref;
	      accept = options.accept, multiple = options.multiple, onChange = options.onChange;
	      if ((ref = this.hiddenDivForFileInput) != null) {
	        ref.parentNode.removeChild(this.hiddenDivForFileInput);
	      }
	      this.hiddenDivForFileInput = createElementFromHtml("<div style='height: 0px;width: 0px; overflow:hidden; position:absolute;'/>");
	      body = document.body;
	      fileInput = createElementFromHtml("<input type='file' " + (accept ? 'accept=' + accept : void 0) + " " + (multiple ? 'multiple=true' : void 0) + "/>");
	      this.hiddenDivForFileInput.appendChild(fileInput);
	      body.appendChild(this.hiddenDivForFileInput);
	      fileInput.onchange = function(e) {
	        var file, fileList, fileSizes, fileTypes;
	        fileList = (function() {
	          var i, len, ref1, results;
	          ref1 = fileInput.files;
	          results = [];
	          for (i = 0, len = ref1.length; i < len; i++) {
	            file = ref1[i];
	            results.push(file);
	          }
	          return results;
	        })();
	        fileTypes = (function() {
	          var i, len, results;
	          results = [];
	          for (i = 0, len = fileList.length; i < len; i++) {
	            file = fileList[i];
	            results.push(file.type);
	          }
	          return results;
	        })();
	        fileSizes = (function() {
	          var i, len, results;
	          results = [];
	          for (i = 0, len = fileList.length; i < len; i++) {
	            file = fileList[i];
	            results.push(file.size);
	          }
	          return results;
	        })();
	        if (fileList.length > 0 && fileList[0]) {
	          onChange && onChange(fileList);
	          return resolve(fileList);
	        } else {
	          return reject("no files returned");
	        }
	      };
	      return fileInput.click();
	    });
	  };

	  return File;

	})();


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(117);


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(118).includeInNamespace(__webpack_require__(120)).addModules({
	  ArtEryBaseObject: __webpack_require__(136),
	  Config: __webpack_require__(138),
	  Filter: __webpack_require__(139),
	  Pipeline: __webpack_require__(143),
	  PipelineRegistry: __webpack_require__(121),
	  Request: __webpack_require__(140),
	  RequestResponseBase: __webpack_require__(141),
	  Response: __webpack_require__(142),
	  Session: __webpack_require__(122)
	});


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Ery,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Art = __webpack_require__(119);

	module.exports = Art.Ery || Art.addNamespace('Ery', Ery = (function(superClass) {
	  extend(Ery, superClass);

	  function Ery() {
	    return Ery.__super__.constructor.apply(this, arguments);
	  }

	  return Ery;

	})(Neptune.Base));


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Neptune,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Neptune = __webpack_require__(8);

	module.exports = Neptune.Art || Neptune.addNamespace('Art', Art = (function(superClass) {
	  extend(Art, superClass);

	  function Art() {
	    return Art.__super__.constructor.apply(this, arguments);
	  }

	  return Art;

	})(Neptune.Base));


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	var _package;

	module.exports = [
	  {
	    pipelines: (__webpack_require__(121)).pipelines,
	    session: (__webpack_require__(122)).singleton,
	    "package": _package = __webpack_require__(137),
	    version: _package.version
	  }, __webpack_require__(138)
	];


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, PipelineRegistry, decapitalize, defineModule, inspect, isClass, log, ref,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(24), defineModule = ref.defineModule, log = ref.log, BaseObject = ref.BaseObject, decapitalize = ref.decapitalize, isClass = ref.isClass, inspect = ref.inspect;

	defineModule(module, PipelineRegistry = (function(superClass) {
	  var pipelines;

	  extend(PipelineRegistry, superClass);

	  function PipelineRegistry() {
	    return PipelineRegistry.__super__.constructor.apply(this, arguments);
	  }

	  PipelineRegistry.pipelines = pipelines = {};

	  PipelineRegistry.register = function(PipelineClass) {
	    var _aliases, alias, singleton;
	    singleton = PipelineClass.singleton, _aliases = PipelineClass._aliases;
	    _aliases && (function() {
	      var i, len, results;
	      results = [];
	      for (i = 0, len = _aliases.length; i < len; i++) {
	        alias = _aliases[i];
	        results.push(pipelines[alias] = singleton);
	      }
	      return results;
	    })();
	    return pipelines[singleton.name] = singleton;
	  };

	  PipelineRegistry._reset = function() {
	    var i, k, len, ref1, results;
	    ref1 = Object.keys(pipelines);
	    results = [];
	    for (i = 0, len = ref1.length; i < len; i++) {
	      k = ref1[i];
	      results.push(delete pipelines[k]);
	    }
	    return results;
	  };

	  return PipelineRegistry;

	})(BaseObject));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, EventedMixin, Foundation, JsonStore, Session, Validator, inspect, isObject, isString, log, merge, plainObjectsDeepEq,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(24);

	EventedMixin = __webpack_require__(123).EventedMixin;

	BaseObject = Foundation.BaseObject, merge = Foundation.merge, inspect = Foundation.inspect, isString = Foundation.isString, isObject = Foundation.isObject, log = Foundation.log, Validator = Foundation.Validator, plainObjectsDeepEq = Foundation.plainObjectsDeepEq, JsonStore = Foundation.JsonStore;

	module.exports = Session = (function(superClass) {
	  var jsonStore, jsonStoreKey;

	  extend(Session, superClass);

	  jsonStore = new JsonStore;

	  jsonStoreKey = "Art.Ery.Session.data";


	  /*
	  A global singleton Session is provided and used by default.
	  Or multiple instances can be created and passed to the
	  constructor of each Pipeline for per-pipeline custom sessions.
	   */

	  Session.singletonClass();

	  Session.property("data signature");

	  function Session(_data) {
	    this._data = _data != null ? _data : {};
	    Session.__super__.constructor.apply(this, arguments);
	    this._signature = "";
	  }

	  Session.prototype.loadSession = function() {
	    return this._sessionLoadPromise = jsonStore.getItem(jsonStoreKey).then((function(_this) {
	      return function(data) {
	        log({
	          jsonStoreItem: {
	            key: jsonStoreKey,
	            data: data
	          }
	        });
	        if (data) {
	          return _this.data = data;
	        }
	      };
	    })(this));
	  };

	  Session.getter("sessionLoadPromise", {
	    inspectedObjects: function() {
	      return this._data;
	    }
	  });

	  Session.setter({
	    data: function(v) {
	      if (!plainObjectsDeepEq(v, this._data)) {
	        this.queueEvent("change", {
	          data: v
	        });
	      }
	      return jsonStore.setItem(jsonStoreKey, this._data = v);
	    }
	  });

	  Session.prototype.reset = function() {
	    return this.data = {};
	  };

	  return Session;

	})(EventedMixin(__webpack_require__(136)));


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(124);


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(125).includeInNamespace(__webpack_require__(127)).addModules({
	  Event: __webpack_require__(129),
	  EventedBaseMixin: __webpack_require__(130),
	  EventedMixin: __webpack_require__(132),
	  EventedObject: __webpack_require__(134),
	  EventedObjectBase: __webpack_require__(135),
	  EventEpoch: __webpack_require__(131),
	  EventManager: __webpack_require__(133)
	});


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Events,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Art = __webpack_require__(126);

	module.exports = Art.Events || Art.addNamespace('Events', Events = (function(superClass) {
	  extend(Events, superClass);

	  function Events() {
	    return Events.__super__.constructor.apply(this, arguments);
	  }

	  return Events;

	})(Neptune.Base));


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Neptune,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Neptune = __webpack_require__(8);

	module.exports = Neptune.Art || Neptune.addNamespace('Art', Art = (function(superClass) {
	  extend(Art, superClass);

	  function Art() {
	    return Art.__super__.constructor.apply(this, arguments);
	  }

	  return Art;

	})(Neptune.Base));


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var _package;

	module.exports = [
	  {
	    "package": _package = __webpack_require__(128),
	    version: _package.version
	  }
	];


/***/ },
/* 128 */
/***/ function(module, exports) {

	module.exports = {
		"author": "Shane Brinkman-Davis Delamore, Imikimi LLC",
		"dependencies": {
			"art-foundation": "git://github.com/imikimi/art-foundation.git",
			"chai": "^3.5.0",
			"coffee-loader": "^0.7.2",
			"coffee-script": "^1.11.1",
			"css-loader": "^0.23.1",
			"json-loader": "^0.5.4",
			"mocha": "^2.5.3",
			"neptune-namespaces": "^1.4.0",
			"script-loader": "^0.7.0",
			"sourcemapped-stacktrace": "^1.1.3",
			"style-loader": "^0.13.1",
			"webpack": "^1.13.2",
			"webpack-dev-server": "^1.16.2"
		},
		"license": "ISC",
		"name": "art-events",
		"scripts": {
			"dev": "neptune-namespaces --std; webpack-dev-server -d --progress",
			"hot": "neptune-namespaces --std; webpack-dev-server --hot --inline --progress",
			"nn": "neptune-namespaces --std",
			"nodeTest": "neptune-namespaces --std;mocha -u tdd --compilers coffee:coffee-script/register",
			"test": "neptune-namespaces --std; webpack-dev-server -d --progress"
		},
		"version": "1.1.1"
	};

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, Event, Foundation, currentSecond, emptyProps,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(24);

	currentSecond = Foundation.currentSecond, BaseObject = Foundation.BaseObject;

	emptyProps = {};

	module.exports = Event = (function(superClass) {
	  extend(Event, superClass);

	  function Event(type, props, timeStamp) {
	    this.type = type;
	    this.props = props != null ? props : emptyProps;
	    this.timeStamp = timeStamp != null ? timeStamp : currentSecond();
	  }

	  return Event;

	})(BaseObject);


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var Event, EventEpoch, Foundation, defineModule, eventEpoch, inspect, isFunction, isPlainObject, log,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(24);

	EventEpoch = __webpack_require__(131);

	Event = __webpack_require__(129);

	defineModule = Foundation.defineModule, isFunction = Foundation.isFunction, log = Foundation.log, isPlainObject = Foundation.isPlainObject, inspect = Foundation.inspect;

	eventEpoch = EventEpoch.eventEpoch;


	/*
	to be used as a mixin via BaseObject's @include method

	If this class is included directly, you must also implement the methods
	  listed in "TO IMPLEMENT" below.
	 */

	defineModule(module, function() {
	  return function(superClass) {
	    var EventedBaseMixin;
	    return EventedBaseMixin = (function(superClass1) {
	      var typeFromEventOrType;

	      extend(EventedBaseMixin, superClass1);

	      function EventedBaseMixin() {
	        return EventedBaseMixin.__super__.constructor.apply(this, arguments);
	      }

	      EventedBaseMixin.typeFromEventOrType = typeFromEventOrType = function(eventOrType) {
	        return eventOrType && (eventOrType.type || eventOrType);
	      };


	      /*
	      Purpose:
	        handle event immediately
	        do some preprocessing on the event
	      
	      Inputs: see #event()'s inputs
	      
	      Output: true if the event was actually handled
	      
	      IMPORTANT: This should only be called during an eventEpoch.
	        This means:
	          Usually, just don't call this directly. Use @queueEvent.
	          If you need to call this directly, only do it from within an event handler.
	        Examples reasons to call directly:
	          - to do custom event routing
	          - send a new event triggered from the first
	       */

	      EventedBaseMixin.prototype.handleEvent = function(eventOrType, eventPropertiesOrCreator) {
	        var e, event, eventType;
	        eventType = typeFromEventOrType(eventOrType);
	        if (!(eventType && this._hasEventHandler(eventType))) {
	          return false;
	        }
	        event = eventOrType instanceof Event ? eventOrType : isFunction(eventPropertiesOrCreator) ? isPlainObject(e = eventPropertiesOrCreator()) ? new Event(eventType, e) : e : new Event(eventType, eventPropertiesOrCreator);
	        if (!event) {
	          return false;
	        }
	        event.target = this;
	        try {
	          this._sendToEventHandler(event);
	        } catch (error1) {
	          e = error1;
	          this._handleErrorInHandler(event, "unknown", e);
	        }
	        event.target = null;
	        return true;
	      };


	      /*
	      Inputs:
	        eventOrType can be:
	         * an instanceof Event or
	         * a string representing the "type" of the event
	            (a new Event will be created)
	      
	        eventPropertiesOrCreator can be:
	         * null: only if eventOrType is an instanceof Event
	         * Object: properties passed into: new Event eventOrType, eventPropertiesOrCreator
	         * Function: returns null (indicating a noop) or a new instanceof Event
	      
	      Output:
	        true:   The event was queued.
	        false:  There is no handler for the event. The event was ignored (discarded).
	       */

	      EventedBaseMixin.prototype.queueEvent = function(eventOrType, eventPropertiesOrCreator) {
	        var eventType;
	        eventType = typeFromEventOrType(eventOrType);
	        if (eventType && this._hasEventHandler(eventType)) {
	          eventEpoch.queue((function(_this) {
	            return function() {
	              return _this.handleEvent(eventOrType, eventPropertiesOrCreator);
	            };
	          })(this));
	          return true;
	        } else {
	          return false;
	        }
	      };


	      /*
	      inputs: eventType is a string
	      outputs: true if there is a handler for the specified type
	       */

	      EventedBaseMixin.prototype._hasEventHandler = function(eventType) {
	        throw new Error("must implement");
	      };


	      /*
	      inputs: an Event object with event.target set to @
	      output: ignored
	      
	      - Called exclusively from handleEvent. Don't call manually.
	      - This is where the event handler is actually called.
	      - Only called during an eventEpoch.
	      - Only called if @_hasEventHandler returned true for event.type
	       */

	      EventedBaseMixin.prototype._sendToEventHandler = function(event) {
	        throw new Error("must implement");
	      };

	      EventedBaseMixin.prototype._handleErrorInHandler = function(event, handler, error) {
	        console.log("EventedObjectBase: exception in handler. Error:", error);
	        console.log("Event: " + (inspect(event, 1)));
	        console.log("Handler:", handler);
	        console.log("Stack:", error.stack);
	        return Foundation.throwErrorOutOfStack(error);
	      };

	      return EventedBaseMixin;

	    })(superClass);
	  };
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var Epoch, EventEpoch, Foundation, defineModule, log,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(24);

	defineModule = Foundation.defineModule, log = Foundation.log, Epoch = Foundation.Epoch;

	defineModule(module, EventEpoch = (function(superClass) {
	  extend(EventEpoch, superClass);

	  function EventEpoch() {
	    return EventEpoch.__super__.constructor.apply(this, arguments);
	  }

	  EventEpoch.singletonClass();

	  EventEpoch.prototype.queue = function(event) {
	    return this.queueItem(event);
	  };

	  EventEpoch.prototype.logEvent = function(name, id) {};

	  return EventEpoch;

	})(Epoch));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var Event, EventEpoch, EventManager, EventedBaseMixin, Foundation, defineModule, eventEpoch, isFunction, isPlainObject, log,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(24);

	EventManager = __webpack_require__(133);

	EventEpoch = __webpack_require__(131);

	Event = __webpack_require__(129);

	EventedBaseMixin = __webpack_require__(130);

	defineModule = Foundation.defineModule, isFunction = Foundation.isFunction, log = Foundation.log, isPlainObject = Foundation.isPlainObject;

	eventEpoch = EventEpoch.eventEpoch;

	defineModule(module, function() {
	  return function(superClass) {
	    var EventedMixin;
	    return EventedMixin = (function(superClass1) {
	      extend(EventedMixin, superClass1);

	      function EventedMixin() {
	        return EventedMixin.__super__.constructor.apply(this, arguments);
	      }


	      /*
	      optional: call from your constructor to make your object more efficient
	      Explanation: Most optimized javascript engines like objects that declare all their fields
	        in the same order every time. In practice, this means do it in the constructor w/o conditionals.
	       */

	      EventedMixin.prototype.initEventHandling = function() {
	        return this.eventManager = null;
	      };

	      EventedMixin.prototype._sendToEventHandler = function(event) {
	        return this.eventManager.handleEvent(event);
	      };

	      EventedMixin.prototype._hasEventHandler = function(eventType) {
	        var ref;
	        return (ref = this.eventManager) != null ? ref.hasHandler(eventType) : void 0;
	      };

	      EventedMixin.prototype.clearEventHandlers = function() {
	        return this.eventManager = null;
	      };

	      EventedMixin.prototype.removeListeners = function(handlerMap) {
	        var ref;
	        return (ref = this.eventManager) != null ? ref.removeListeners(handlerMap) : void 0;
	      };

	      EventedMixin.prototype.preprocessEventHandlers = function(handlerMap) {
	        return handlerMap;
	      };

	      EventedMixin.prototype.on = function(handlerMap) {
	        (this.eventManager || (this.eventManager = new EventManager(this))).on(handlerMap);
	        return this.preprocessEventHandlers(handlerMap);
	      };

	      EventedMixin.prototype.onNext = function(handlerMap) {
	        return (this.eventManager || (this.eventManager = new EventManager(this))).onNext(handlerMap);
	      };

	      return EventedMixin;

	    })(EventedBaseMixin(superClass));
	  };
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {
	/*

	TODO:
	  handlEvent alternate signature:
	    (type, functionReturningEventElement) ->

	  The function would only be invoked if there are actually event handlers for the specified type.
	 */
	var Event, EventManager, Foundation, arrayWith, clone, defineModule, inspect, isFunction, nextTick, rawErrorLog,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(24);

	Event = __webpack_require__(129);

	defineModule = Foundation.defineModule, nextTick = Foundation.nextTick, isFunction = Foundation.isFunction, inspect = Foundation.inspect, clone = Foundation.clone, arrayWith = Foundation.arrayWith;

	rawErrorLog = Foundation.Log.rawErrorLog;

	defineModule(module, EventManager = (function(superClass) {
	  extend(EventManager, superClass);

	  function EventManager(parent) {
	    this.parent = parent;
	    this.eventHandlers = {};
	  }

	  EventManager.prototype.hasHandler = function(type) {
	    var handlers;
	    return !!((handlers = this.eventHandlers[type]) && handlers.length > 0);
	  };

	  EventManager.prototype.on = function(handlerMap) {
	    var action, results, type;
	    results = [];
	    for (type in handlerMap) {
	      action = handlerMap[type];
	      if (!(action)) {
	        continue;
	      }
	      if (!isFunction(action)) {
	        throw new Error("EventManager: action is not a function for " + (inspect(type)) + " event handler. (action: " + (inspect(action)) + ", parent: " + (inspect(this.parent)) + ")");
	      }
	      results.push(this.eventHandlers[type] = arrayWith(this.eventHandlers[type], {
	        action: action,
	        oneTime: false
	      }));
	    }
	    return results;
	  };

	  EventManager.prototype.removeListeners = function(handlerMap) {
	    var action, beforeCount, count, handler, handlers, type;
	    count = 0;
	    for (type in handlerMap) {
	      action = handlerMap[type];
	      if (!(handlers = this.eventHandlers[type])) {
	        continue;
	      }
	      beforeCount = handlers.length;
	      this.eventHandlers[type] = (function() {
	        var i, len, results;
	        results = [];
	        for (i = 0, len = handlers.length; i < len; i++) {
	          handler = handlers[i];
	          if (handler.action !== action) {
	            results.push(handler);
	          }
	        }
	        return results;
	      })();
	      count = beforeCount - this.eventHandlers[type].length;
	    }
	    return count;
	  };

	  EventManager.prototype.onNext = function(handlerMap) {
	    var action, base, results, type;
	    results = [];
	    for (type in handlerMap) {
	      action = handlerMap[type];
	      if ((base = this.eventHandlers)[type] == null) {
	        base[type] = [];
	      }
	      results.push(this.eventHandlers[type].push({
	        action: action,
	        oneTime: true
	      }));
	    }
	    return results;
	  };

	  EventManager.prototype.countOneTimeHandlersFor = function(eventType) {
	    var count, handler, handlers, i, len;
	    count = 0;
	    if (handlers = this.eventHandlers[eventType]) {
	      for (i = 0, len = handlers.length; i < len; i++) {
	        handler = handlers[i];
	        if (handler.oneTime) {
	          count++;
	        }
	      }
	    }
	    return count;
	  };

	  EventManager.prototype.handleEvent = function(event) {
	    if (typeof event === "string") {
	      event = new Event(event);
	    }
	    return this.sendToHandlers(event.type, event);
	  };

	  EventManager.prototype.handleEvents = function(events) {
	    var event, i, len, results;
	    results = [];
	    for (i = 0, len = events.length; i < len; i++) {
	      event = events[i];
	      results.push(this.handleEvent(event));
	    }
	    return results;
	  };

	  EventManager.prototype.sendToHandlers = function(eventType, event) {
	    var action, error, firedOneTimeHandler, handler, handlers, i, len;
	    handlers = this.eventHandlers[eventType];
	    if (!(handlers && handlers.length > 0)) {
	      return;
	    }
	    firedOneTimeHandler = false;
	    for (i = 0, len = handlers.length; i < len; i++) {
	      handler = handlers[i];
	      try {
	        if (handler.oneTime) {
	          handler.remove = firedOneTimeHandler = true;
	        }
	        action = handler.action;
	        action(event);
	      } catch (error1) {
	        error = error1;
	        this.handleErrorInHandler(handler, event, error);
	      }
	    }
	    if (firedOneTimeHandler) {
	      return this.eventHandlers[event.type] = (function() {
	        var j, len1, ref, results;
	        ref = this.eventHandlers[eventType];
	        results = [];
	        for (j = 0, len1 = ref.length; j < len1; j++) {
	          handler = ref[j];
	          if (!handler.remove) {
	            results.push(handler);
	          }
	        }
	        return results;
	      }).call(this);
	    }
	  };

	  EventManager.prototype.handleErrorInHandler = function(handler, event, error) {
	    if (event.type === "eventException") {
	      rawErrorLog("exception in eventException handler.\nEvent:" + (inspect(event, 1)) + ".\n\nError:\n" + error.stack);
	      return Foundation.throwErrorOutOfStack(error);
	    } else if (this.eventHandlers["eventException"]) {
	      return this.handleEvent(new Event("eventException", {
	        event: clone(event),
	        exception: error,
	        handler: handler
	      }));
	    } else {
	      rawErrorLog("exception in handler AND no eventException handler. Error:");
	      rawErrorLog(error);
	      rawErrorLog("Event: " + (inspect(event, 1)));
	      rawErrorLog("Stack:\n" + error.stack);
	      return Foundation.throwErrorOutOfStack(error);
	    }
	  };

	  return EventManager;

	})(Foundation.BaseObject));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var Event, EventEpoch, EventManager, EventedObject, EventedObjectBase, Foundation, defineModule, eventEpoch, isFunction, isPlainObject, log,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(24);

	EventManager = __webpack_require__(133);

	EventEpoch = __webpack_require__(131);

	Event = __webpack_require__(129);

	EventedObjectBase = __webpack_require__(135);

	defineModule = Foundation.defineModule, isFunction = Foundation.isFunction, log = Foundation.log, isPlainObject = Foundation.isPlainObject;

	eventEpoch = EventEpoch.eventEpoch;

	defineModule(module, EventedObject = (function(superClass) {
	  extend(EventedObject, superClass);

	  function EventedObject() {
	    return EventedObject.__super__.constructor.apply(this, arguments);
	  }


	  /*
	  optional: call from your constructor to make your object more efficient
	  Explanation: Most optimized javascript engines like objects that declare all their fields
	    in the same order every time. In practice, this means do it in the constructor w/o conditionals.
	   */

	  EventedObject.prototype.initEventHandling = function() {
	    return this.eventManager = null;
	  };

	  EventedObject.prototype._sendToEventHandler = function(event) {
	    return this.eventManager.handleEvent(event);
	  };

	  EventedObject.prototype._hasEventHandler = function(eventType) {
	    var ref;
	    return (ref = this.eventManager) != null ? ref.hasHandler(eventType) : void 0;
	  };

	  EventedObject.prototype.clearEventHandlers = function() {
	    return this.eventManager = null;
	  };

	  EventedObject.prototype.removeListeners = function(handlerMap) {
	    var ref;
	    return (ref = this.eventManager) != null ? ref.removeListeners(handlerMap) : void 0;
	  };

	  EventedObject.prototype.preprocessEventHandlers = function(handlerMap) {
	    return handlerMap;
	  };

	  EventedObject.prototype.on = function(handlerMap) {
	    (this.eventManager || (this.eventManager = new EventManager(this))).on(handlerMap);
	    return this.preprocessEventHandlers(handlerMap);
	  };

	  EventedObject.prototype.onNext = function(handlerMap) {
	    return (this.eventManager || (this.eventManager = new EventManager(this))).onNext(handlerMap);
	  };

	  return EventedObject;

	})(EventedObjectBase));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var Event, EventEpoch, EventedObjectBase, Foundation, defineModule, eventEpoch, inspect, isFunction, isPlainObject, log;

	Foundation = __webpack_require__(24);

	EventEpoch = __webpack_require__(131);

	Event = __webpack_require__(129);

	defineModule = Foundation.defineModule, isFunction = Foundation.isFunction, log = Foundation.log, isPlainObject = Foundation.isPlainObject, inspect = Foundation.inspect;

	eventEpoch = EventEpoch.eventEpoch;


	/*
	to be used as a mixin via BaseObject's @include method

	If this class is included directly, you must also implement the methods
	  listed in "TO IMPLEMENT" below.
	 */

	defineModule(module, EventedObjectBase = (function() {
	  var typeFromEventOrType;

	  function EventedObjectBase() {}

	  EventedObjectBase.typeFromEventOrType = typeFromEventOrType = function(eventOrType) {
	    return eventOrType && (eventOrType.type || eventOrType);
	  };


	  /*
	  Purpose:
	    handle event immediately
	    do some preprocessing on the event
	  
	  Inputs: see #event()'s inputs
	  
	  Output: true if the event was actually handled
	  
	  IMPORTANT: This should only be called during an eventEpoch.
	    This means:
	      Usually, just don't call this directly. Use @queueEvent.
	      If you need to call this directly, only do it from within an event handler.
	    Examples reasons to call directly:
	      - to do custom event routing
	      - send a new event triggered from the first
	   */

	  EventedObjectBase.prototype.handleEvent = function(eventOrType, eventPropertiesOrCreator) {
	    var e, event, eventType;
	    eventType = typeFromEventOrType(eventOrType);
	    if (!(eventType && this._hasEventHandler(eventType))) {
	      return false;
	    }
	    event = eventOrType instanceof Event ? eventOrType : isFunction(eventPropertiesOrCreator) ? isPlainObject(e = eventPropertiesOrCreator()) ? new Event(eventType, e) : e : new Event(eventType, eventPropertiesOrCreator);
	    if (!event) {
	      return false;
	    }
	    event.target = this;
	    try {
	      this._sendToEventHandler(event);
	    } catch (error1) {
	      e = error1;
	      this._handleErrorInHandler(event, "unknown", e);
	    }
	    event.target = null;
	    return true;
	  };


	  /*
	  Inputs:
	    eventOrType can be:
	     * an instanceof Event or
	     * a string representing the "type" of the event
	        (a new Event will be created)
	  
	    eventPropertiesOrCreator can be:
	     * null: only if eventOrType is an instanceof Event
	     * Object: properties passed into: new Event eventOrType, eventPropertiesOrCreator
	     * Function: returns null (indicating a noop) or a new instanceof Event
	  
	  Output:
	    true:   The event was queued.
	    false:  There is no handler for the event. The event was ignored (discarded).
	   */

	  EventedObjectBase.prototype.queueEvent = function(eventOrType, eventPropertiesOrCreator) {
	    var eventType;
	    eventType = typeFromEventOrType(eventOrType);
	    if (eventType && this._hasEventHandler(eventType)) {
	      eventEpoch.queue((function(_this) {
	        return function() {
	          return _this.handleEvent(eventOrType, eventPropertiesOrCreator);
	        };
	      })(this));
	      return true;
	    } else {
	      return false;
	    }
	  };


	  /*
	  inputs: eventType is a string
	  outputs: true if there is a handler for the specified type
	   */

	  EventedObjectBase.prototype._hasEventHandler = function(eventType) {
	    throw new Error("must implement");
	  };


	  /*
	  inputs: an Event object with event.target set to @
	  output: ignored
	  
	  - Called exclusively from handleEvent. Don't call manually.
	  - This is where the event handler is actually called.
	  - Only called during an eventEpoch.
	  - Only called if @_hasEventHandler returned true for event.type
	   */

	  EventedObjectBase.prototype._sendToEventHandler = function(event) {
	    throw new Error("must implement");
	  };

	  EventedObjectBase.prototype._handleErrorInHandler = function(event, handler, error) {
	    console.log("EventedObjectBase: exception in handler. Error:", error);
	    console.log("Event: " + (inspect(event, 1)));
	    console.log("Handler:", handler);
	    console.log("Stack:", error.stack);
	    return Foundation.throwErrorOutOfStack(error);
	  };

	  return EventedObjectBase;

	})());

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var ArtEry, ArtEryBaseObject, BaseObject, defineModule, ref,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(24), BaseObject = ref.BaseObject, defineModule = ref.defineModule;

	ArtEry = __webpack_require__(118);

	defineModule(module, ArtEryBaseObject = (function(superClass) {
	  extend(ArtEryBaseObject, superClass);

	  function ArtEryBaseObject() {
	    return ArtEryBaseObject.__super__.constructor.apply(this, arguments);
	  }

	  ArtEryBaseObject.abstractClass();

	  ArtEryBaseObject.getter({
	    productionEnvironment: function() {
	      return false;
	    },
	    pipelines: function() {
	      return ArtEry.pipelines;
	    }
	  });

	  return ArtEryBaseObject;

	})(BaseObject));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 137 */
/***/ function(module, exports) {

	module.exports = {
		"author": "Shane Brinkman-Davis Delamore, Imikimi LLC",
		"dependencies": {
			"art-events": "git://github.com/imikimi/art-events.git",
			"art-flux": "git://github.com/imikimi/art-flux.git",
			"art-foundation": "git://github.com/imikimi/art-foundation.git",
			"chai": "^3.5.0",
			"coffee-loader": "^0.7.2",
			"coffee-script": "^1.11.1",
			"css-loader": "^0.23.1",
			"json-loader": "^0.5.4",
			"jsonwebtoken": "^7.1.9",
			"mocha": "^2.5.3",
			"neptune-namespaces": "^1.5.0",
			"script-loader": "^0.7.0",
			"sourcemapped-stacktrace": "^1.1.3",
			"style-loader": "^0.13.1",
			"throng": "^4.0.0",
			"webpack": "^1.13.2",
			"webpack-dev-server": "^1.16.2"
		},
		"description": "A pipelined business-logic framework for cloud-backed data. ArtEry conceptially allows you to write apps 100% as client-code, but with the security and performance of cloud-code.",
		"license": "ISC",
		"name": "art-ery",
		"scripts": {
			"dev": "neptune-namespaces --std; webpack-dev-server -d --progress",
			"hot": "neptune-namespaces --std; webpack-dev-server --hot --inline --progress",
			"nn": "neptune-namespaces --std",
			"nodeTest": "neptune-namespaces --std;mocha -u tdd --compilers coffee:coffee-script/register",
			"test": "neptune-namespaces --std; webpack-dev-server -d --progress",
			"testServer": "./art-ery-server -r ./test/tests/Art/Ery/ClientServer/Pipelines"
		},
		"version": "1.14.3"
	};

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, Config, Validator, defineModule, mergeInto, ref, w,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	ref = __webpack_require__(24), w = ref.w, Validator = ref.Validator, defineModule = ref.defineModule, mergeInto = ref.mergeInto, BaseObject = ref.BaseObject;

	defineModule(module, Config = (function(superClass) {
	  var configureOptionsValidator;

	  extend(Config, superClass);

	  function Config() {
	    return Config.__super__.constructor.apply(this, arguments);
	  }

	  Config.config = {
	    tableNamePrefix: "",
	    location: "client",
	    apiRoot: "api",

	    /*
	    remoteServer examples:
	      "http://localhost:8085"
	      "http://domain.com"
	      "https://domain.com"
	     */
	    remoteServer: null,
	    verbose: false
	  };

	  Config.getPrefixedTableName = function(tableName) {
	    return "" + Config.tableNamePrefix + tableName;
	  };

	  configureOptionsValidator = new Validator((function() {
	    var validLocations;
	    validLocations = w("server client both");
	    return {
	      location: {
	        validate: function(v) {
	          return !v || indexOf.call(validLocations, v) >= 0;
	        }
	      }
	    };
	  })());

	  Config.configure = function(config) {
	    if (config == null) {
	      config = {};
	    }
	    configureOptionsValidator.validateSync(config);
	    return mergeInto(Config.config, config, Config.config);
	  };

	  return Config;

	})(BaseObject));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, CommunicationStatus, Filter, Foundation, Promise, Request, Response, config, defineModule, failure, getInspectedObjects, isPlainObject, log, merge, mergeInto, shallowClone, success, toInspectedObjects,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(24);

	Request = __webpack_require__(140);

	Response = __webpack_require__(142);

	config = __webpack_require__(138).config;

	toInspectedObjects = Foundation.toInspectedObjects, getInspectedObjects = Foundation.getInspectedObjects, defineModule = Foundation.defineModule, BaseObject = Foundation.BaseObject, Promise = Foundation.Promise, log = Foundation.log, isPlainObject = Foundation.isPlainObject, mergeInto = Foundation.mergeInto, merge = Foundation.merge, shallowClone = Foundation.shallowClone, CommunicationStatus = Foundation.CommunicationStatus;

	success = CommunicationStatus.success, failure = CommunicationStatus.failure;


	/*
	TODO

	Filters should be able to detect if they are being run server-side or client-side.
	  This is a simple global value, since the entire code-base is either running in Node or in the Browser.
	  It doesn't change at runtime - duh!
	  So, I think we should have a value like: Art.Ery.location, which is set at init-time
	  to the code-base's running location.

	  WHY do we need this? Filters may want to run on both AND run a little differently on both.

	    LinkFieldsFilter, for example, would translate a linked field {foo: id: 123} to {fooId: 123} and not need
	    to transmit the whole foo-record over the wire. BUT, if the data was {foo: username: "hi"}, that indicates
	    a new foo-record should be created, and that should be done server-side.

	    IT's a little thing right now, so I'm not implementing it... yet

	  WHY PART 2

	    This may be the solution to Filters which are not symmetrical. It's possible the before-part should be
	    client-side-only, but the after-part should be server-side-only (for example).

	    We could add @beforeLocation and @afterLocation props, but maybe this one solution is "good enough" for everything.
	    The only down-side is it isn't as clear in the ArtEry-Pipeline report, but that may be OK since it doesn't seem like
	    it'll be used that much.

	Art.Ery.location values:
	  "server"
	  "client"
	  "both" - this is the "serverless" mode, it's all run client-side, but it includes both client-side and server-side filters.
	 */

	defineModule(module, Filter = (function(superClass) {
	  extend(Filter, superClass);

	  Filter.location = "server";

	  Filter.extendableProperty({
	    beforeFilters: {},
	    afterFilters: {},
	    fields: {}
	  });

	  Filter.fields = Filter.extendFields;


	  /*
	  IN: requestType, requestFilter
	  IN: map from requestTypes to requestFilters
	  
	  requestFilter: (request) ->
	    IN: Request instance
	    OUT: return a Promise returning one of the list below OR just return one of the list below:
	      Request instance
	      Response instance
	      anythingElse -> toResponse anythingElse
	  
	    To reject a request:
	    - throw an error
	    - return a rejected promise
	    - or create a Response object with the appropriate fields
	   */

	  Filter.before = function(a, b) {
	    if (a) {
	      return this.extendBeforeFilters(a, b);
	    }
	  };

	  Filter.prototype.before = function(a, b) {
	    if (a) {
	      return this.extendBeforeFilters(a, b);
	    }
	  };


	  /*
	  IN: requestType, responseFilter
	  IN: map from requestTypes to responseFilter
	  
	  responseFilter: (response) ->
	    IN: Response instance
	    OUT: return a Promise returning one of the list below OR just return one of the list below:
	      Response instance
	      anythingElse -> toResponse anythingElse
	  
	    To reject a request:
	    - throw an error
	    - return a rejected promise
	    - or create a Response object with the appropriate fields
	   */

	  Filter.after = function(a, b) {
	    if (a) {
	      return this.extendAfterFilters(a, b);
	    }
	  };

	  Filter.prototype.after = function(a, b) {
	    if (a) {
	      return this.extendAfterFilters(a, b);
	    }
	  };

	  function Filter(options) {
	    if (options == null) {
	      options = {};
	    }
	    Filter.__super__.constructor.apply(this, arguments);
	    this.serverSideOnly = options.serverSideOnly, this.clientSideOnly = options.clientSideOnly, this.name = options.name, this.location = options.location;
	    this.name || (this.name = this["class"].getName());
	    this._location || (this._location = this["class"].location || "server");
	    this.shouldFilter();
	    this.after(options.after);
	    this.before(options.before);
	  }

	  Filter.property("name");

	  Filter.property("location");

	  Filter.prototype.shouldFilter = function(processingLocation) {
	    switch (this.location) {
	      case "server":
	        return processingLocation !== "client";
	      case "client":
	        return processingLocation !== "server";
	      case "both":
	        return true;
	      default:
	        throw new Error("Filter " + (this.getName()) + ": invalid filter location: " + this.location);
	    }
	  };

	  Filter.prototype.toString = function() {
	    return this.getName();
	  };

	  Filter.prototype.getBeforeFilter = function(requestType, location) {
	    if (location == null) {
	      location = config.location;
	    }
	    return this.shouldFilter(location) && (this.beforeFilters[requestType] || this.beforeFilters.all);
	  };

	  Filter.prototype.getAfterFilter = function(requestType, location) {
	    if (location == null) {
	      location = config.location;
	    }
	    return this.shouldFilter(location) && (this.afterFilters[requestType] || this.afterFilters.all);
	  };

	  Filter.prototype.processBefore = function(request) {
	    return this._processFilter(request, this.getBeforeFilter(request.type, request.pipeline.location));
	  };

	  Filter.prototype.processAfter = function(response) {
	    return this._processFilter(response, this.getAfterFilter(response.type, response.request.pipeline.location));
	  };

	  Filter.getter({
	    inspectedObjects: function() {
	      var obj;
	      return (
	        obj = {},
	        obj["" + this.name] = toInspectedObjects(this.props),
	        obj
	      );
	    },
	    props: function() {
	      return {
	        location: this.location
	      };
	    }
	  });


	  /*
	  OUT:
	    promise.then (successful Request or Response instance) ->
	    .catch (failingResponse) ->
	   */

	  Filter.prototype._processFilter = function(responseOrRequest, filterFunction) {
	    return Promise.then((function(_this) {
	      return function() {
	        if (filterFunction) {
	          responseOrRequest.addFilterLog(_this);
	          return filterFunction.call(_this, responseOrRequest);
	        } else {
	          return responseOrRequest;
	        }
	      };
	    })(this)).then((function(_this) {
	      return function(result) {
	        return responseOrRequest.next(result);
	      };
	    })(this))["catch"]((function(_this) {
	      return function(error) {
	        return responseOrRequest.next(error, failure);
	      };
	    })(this));
	  };

	  return Filter;

	})(__webpack_require__(136)));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var ArtEry, BaseObject, CommunicationStatus, Foundation, Request, RestClient, Validator, arrayWith, failure, inspect, isObject, isString, log, merge, missing, present, ref, success, validStatus, validator, w,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = Foundation = __webpack_require__(24), present = ref.present, BaseObject = ref.BaseObject, RestClient = ref.RestClient, merge = ref.merge, inspect = ref.inspect, isString = ref.isString, isObject = ref.isObject, log = ref.log, Validator = ref.Validator, CommunicationStatus = ref.CommunicationStatus, arrayWith = ref.arrayWith, w = ref.w;

	ArtEry = __webpack_require__(118);

	success = CommunicationStatus.success, missing = CommunicationStatus.missing, failure = CommunicationStatus.failure, validStatus = CommunicationStatus.validStatus;

	validator = new Validator({
	  type: w("required string"),
	  pipeline: {
	    required: {
	      "instanceof": Neptune.Art.Ery.Pipeline
	    }
	  },
	  session: w("required object"),
	  data: "object",
	  key: "string",
	  originatedOnServer: "boolean"
	});

	module.exports = Request = (function(superClass) {
	  var getRestClientParamsForArtEryRequest, restMap;

	  extend(Request, superClass);

	  function Request(options) {
	    Request.__super__.constructor.apply(this, arguments);
	    validator.preCreateSync(options, {
	      context: "Request options"
	    });
	    this.type = options.type, this.key = options.key, this.pipeline = options.pipeline, this.session = options.session, this.data = options.data, this.originatedOnServer = options.originatedOnServer, this.originatedOnClient = options.originatedOnClient, this.sessionSignature = options.sessionSignature;
	  }

	  Request.property("type key pipeline session data originatedOnServer sessionSignature originatedOnClient");

	  Request.prototype.toString = function() {
	    return "ArtEry.Request(" + this.type + " key: " + this.key + ", hasData: " + (!!this.data) + ")";
	  };

	  Request.prototype.requireServerOrigin = function(message) {
	    if (message == null) {
	      message = "(no further explanation)";
	    }
	    if (!this.originatedOnServer) {
	      throw this.failure({
	        data: {
	          message: this.type + "-request: originatedOnServer required " + (message || "")
	        }
	      });
	    }
	    return this;
	  };

	  Request.getter({
	    request: function() {
	      return this;
	    },
	    props: function() {
	      return {
	        pipeline: this.pipeline,
	        type: this.type,
	        key: this.key,
	        session: this.session,
	        data: this.data,
	        filterLog: this.filterLog,
	        originatedOnServer: this.originatedOnServer,
	        originatedOnClient: this.originatedOnClient
	      };
	    },
	    urlKeyClause: function() {
	      if (present(this.key)) {
	        return "/" + this.key;
	      } else {
	        return "";
	      }
	    }
	  });

	  Request.prototype.getRestRequestUrl = function(server) {
	    return server + "/" + this.pipeline.name + this.urlKeyClause;
	  };

	  Request.prototype.getNonRestRequestUrl = function(server) {
	    return server + "/" + this.pipeline.name + "-" + this.type + this.urlKeyClause;
	  };

	  restMap = {
	    get: "get",
	    create: "post",
	    update: "put",
	    "delete": "delete"
	  };

	  Request.getRestClientParamsForArtEryRequest = getRestClientParamsForArtEryRequest = function(arg) {
	    var data, key, method, restPath, server, type, url, urlKeyClause;
	    server = arg.server, restPath = arg.restPath, type = arg.type, key = arg.key, data = arg.data;
	    urlKeyClause = present(key) ? "/" + key : "";
	    server || (server = "");
	    url = (method = restMap[type]) ? "" + server + restPath + urlKeyClause : (method = "post", "" + server + restPath + "-" + type + urlKeyClause);
	    return {
	      method: method,
	      url: url,
	      data: data
	    };
	  };

	  Request.prototype.sendRemoteRequest = function() {
	    var remoteRequestOptions;
	    remoteRequestOptions = getRestClientParamsForArtEryRequest({
	      restPath: this.pipeline.restPath,
	      server: this.pipeline.remoteServer,
	      type: this.type,
	      key: this.key,
	      data: {
	        data: this.data,
	        session: this.session,
	        sessionSignature: this.sessionSignature
	      }
	    });
	    return RestClient.restJsonRequest(remoteRequestOptions)["catch"]((function(_this) {
	      return function(error) {
	        if (CommunicationStatus[error.response.status]) {
	          return error.response;
	        } else {
	          return _this.failure({
	            error: error
	          });
	        }
	      };
	    })(this)).then((function(_this) {
	      return function(remoteResponseOptions) {
	        var data, filterLog, session, sessionSignature, status;
	        data = remoteResponseOptions.data, status = remoteResponseOptions.status, filterLog = remoteResponseOptions.filterLog, session = remoteResponseOptions.session, sessionSignature = remoteResponseOptions.sessionSignature;
	        return _this._toResponse(status, {
	          data: data,
	          filterLog: filterLog,
	          session: session,
	          sessionSignature: sessionSignature,
	          remoteRequest: remoteRequestOptions,
	          remoteResponse: remoteResponseOptions
	        }).then(function(response) {
	          return response.handled((remoteRequestOptions.method.toLocaleUpperCase()) + " " + remoteRequestOptions.url);
	        });
	      };
	    })(this));
	  };

	  return Request;

	})(__webpack_require__(141));


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var ArtEry, ArtEryBaseObject, BaseObject, CommunicationStatus, RequestResponseBase, arrayWith, defineModule, failure, formattedInspect, inspect, inspectedObjectLiteral, isJsonType, isPlainObject, isString, log, merge, missing, ref, success, toInspectedObjects,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(24), BaseObject = ref.BaseObject, CommunicationStatus = ref.CommunicationStatus, log = ref.log, arrayWith = ref.arrayWith, defineModule = ref.defineModule, merge = ref.merge, isJsonType = ref.isJsonType, isString = ref.isString, isPlainObject = ref.isPlainObject, inspect = ref.inspect, inspectedObjectLiteral = ref.inspectedObjectLiteral, toInspectedObjects = ref.toInspectedObjects, formattedInspect = ref.formattedInspect;

	ArtEry = __webpack_require__(118);

	ArtEryBaseObject = __webpack_require__(136);

	success = CommunicationStatus.success, missing = CommunicationStatus.missing, failure = CommunicationStatus.failure;

	defineModule(module, RequestResponseBase = (function(superClass) {
	  extend(RequestResponseBase, superClass);

	  function RequestResponseBase(options) {
	    RequestResponseBase.__super__.constructor.apply(this, arguments);
	    this.filterLog = options.filterLog;
	  }

	  RequestResponseBase.property("filterLog");

	  RequestResponseBase.prototype.addFilterLog = function(filter) {
	    return this._filterLog = arrayWith(this._filterLog, "" + filter);
	  };

	  RequestResponseBase.getter({
	    inspectedObjects: function() {
	      var obj;
	      return (
	        obj = {},
	        obj["" + this["class"].namespacePath] = toInspectedObjects(this.props),
	        obj
	      );
	    }
	  });


	  /*
	  IN: data can be a plainObject or a promise returning a plainObject
	  OUT: promise.then (newRequestWithNewData) ->
	   */

	  RequestResponseBase.prototype.withData = function(data) {
	    return Promise.resolve(data).then((function(_this) {
	      return function(resolvedData) {
	        return new _this["class"](merge(_this.props, {
	          data: resolvedData
	        }));
	      };
	    })(this));
	  };


	  /*
	  IN: data can be a plainObject or a promise returning a plainObject
	  OUT: promise.then (newRequestWithNewData) ->
	   */

	  RequestResponseBase.prototype.withMergedData = function(data) {
	    return Promise.resolve(data).then((function(_this) {
	      return function(resolvedData) {
	        return new _this["class"](merge(_this.props, {
	          data: merge(_this.data, resolvedData)
	        }));
	      };
	    })(this));
	  };

	  RequestResponseBase.prototype.next = function(data, status) {
	    if (status == null) {
	      status = success;
	    }
	    return Promise.resolve(data).then((function(_this) {
	      return function(data) {
	        var responseProps;
	        responseProps = !data ? (status = missing, {
	          data: {
	            message: "missing response"
	          }
	        }) : isJsonType(data) ? {
	          data: data
	        } : data;
	        return _this._toResponse(status, responseProps);
	      };
	    })(this));
	  };

	  RequestResponseBase.prototype.success = function(responseProps) {
	    return this._toResponse(success, responseProps);
	  };

	  RequestResponseBase.prototype.missing = function(responseProps) {
	    return this._toResponse(missing, responseProps);
	  };

	  RequestResponseBase.prototype.failure = function(responseProps) {
	    return this._toResponse(failure, responseProps);
	  };


	  /*
	  IN:
	    responseProps: (optionally Promise returning:)
	      an object which is directly passed into the Response constructor
	      OR instanceof RequestResponseBase
	      OR anything else:
	        considered internal error, but it will create a valid, failing Response object
	  OUT:
	    promise.then (response) ->
	    .catch -> # should never happen
	   */

	  RequestResponseBase.prototype._toResponse = function(status, responseProps) {
	    return Promise.resolve(responseProps)["catch"]((function(_this) {
	      return function(e) {
	        status = failure;
	        return e;
	      };
	    })(this)).then((function(_this) {
	      return function(responseProps) {
	        var message, response;
	        if (responseProps == null) {
	          responseProps = {};
	        }
	        if (responseProps instanceof RequestResponseBase) {
	          return responseProps;
	        }
	        if (isString(responseProps)) {
	          responseProps = {
	            data: {
	              message: responseProps
	            }
	          };
	        }
	        if (!isPlainObject(responseProps)) {
	          status = failure;
	          message = null;
	          responseProps = {
	            data: {
	              message: responseProps instanceof Error ? (log.error(message = "Internal Error: ArtEry.RequestResponseBase#_toResponse received Error instance: " + (formattedInspect(responseProps)), _this, responseProps), message) : log.error("Internal Error: ArtEry.RequestResponseBase#_toResponse expecting responseProps or error", responseProps)
	            }
	          };
	        }
	        response = new ArtEry.Response(merge({
	          request: _this.request,
	          status: status
	        }, responseProps));
	        if (status === success) {
	          return Promise.resolve(response);
	        } else {
	          return Promise.reject(response);
	        }
	      };
	    })(this));
	  };

	  return RequestResponseBase;

	})(ArtEryBaseObject));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, CommunicationStatus, Foundation, Request, Response, Validator, arrayWith, failure, formattedInspect, inspect, isJsonType, isPlainObject, log, merge, missing, responseValidator, success, w,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(24);

	Request = __webpack_require__(140);

	BaseObject = Foundation.BaseObject, arrayWith = Foundation.arrayWith, inspect = Foundation.inspect, isPlainObject = Foundation.isPlainObject, log = Foundation.log, CommunicationStatus = Foundation.CommunicationStatus, Validator = Foundation.Validator, merge = Foundation.merge, isJsonType = Foundation.isJsonType, formattedInspect = Foundation.formattedInspect, w = Foundation.w;

	success = CommunicationStatus.success, missing = CommunicationStatus.missing, failure = CommunicationStatus.failure;

	responseValidator = new Validator({
	  request: w("required", {
	    "instanceof": Request
	  }),
	  status: w("required communicationStatus"),
	  data: {
	    validate: function(a) {
	      return a === void 0 || isJsonType(a);
	    }
	  },
	  session: "object"
	});

	module.exports = Response = (function(superClass) {
	  extend(Response, superClass);

	  function Response(options) {
	    var ref;
	    Response.__super__.constructor.apply(this, arguments);
	    responseValidator.preCreateSync(options, {
	      context: "Response options"
	    });
	    this.request = options.request, this.status = options.status, this.data = (ref = options.data) != null ? ref : {}, this.session = options.session, this.sessionSignature = options.sessionSignature, this.error = options.error, this.remoteRequest = options.remoteRequest, this.remoteResponse = options.remoteResponse, this.handledBy = options.handledBy;
	    this.session || (this.session = this.request.session);
	  }

	  Response.prototype.isResponse = true;

	  Response.prototype.toString = function() {
	    return "ArtEry.Response(" + this.type + ": " + this.status + "): " + this.message;
	  };

	  Response.prototype.handled = function(handledBy) {
	    if (this.status === success) {
	      this.handledBy = handledBy;
	    }
	    return Promise.resolve(this);
	  };

	  Response.property("request status data session sessionSignature error remoteResponse remoteRequest handledBy");

	  Response.getter({
	    type: function() {
	      return this.request.type;
	    },
	    originatedOnServer: function() {
	      return this.request.originatedOnServer;
	    },
	    beforeFilterLog: function() {
	      return this.request.filterLog;
	    },
	    afterFilterLog: function() {
	      return this.filterLog;
	    },
	    message: function() {
	      var ref;
	      return (ref = this.data) != null ? ref.message : void 0;
	    },
	    isSuccessful: function() {
	      return this._status === success;
	    },
	    notSuccessful: function() {
	      return this._status !== success;
	    },
	    props: function() {
	      return {
	        request: this.request,
	        status: this.status,
	        data: this.data,
	        session: this.session,
	        filterLog: this.filterLog,
	        handledBy: this.handledBy,
	        remoteRequest: this.remoteRequest,
	        remoteResponse: this.remoteResponse
	      };
	    },
	    plainObjectsResponse: function() {
	      var out, ref, ref1;
	      out = {
	        status: this.status,
	        data: this.data,
	        session: this.session
	      };
	      if (((ref = this.beforeFilterLog) != null ? ref.length : void 0) > 0) {
	        out.beforeFilterLog = this.beforeFilterLog;
	      }
	      out.handledBy = this.handledBy;
	      if (((ref1 = this.afterFilterLog) != null ? ref1.length : void 0) > 0) {
	        out.afterFilterLog = this.afterFilterLog;
	      }
	      return out;
	    }
	  });

	  return Response;

	})(__webpack_require__(141));


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, CommunicationStatus, Filter, Foundation, Pipeline, PipelineRegistry, Promise, Request, Response, Session, Validator, arrayToTruthMap, compactFlatten, config, decapitalize, defineModule, escapeRegExp, failure, inspect, inspectedObjectLiteral, isClass, isFunction, isPlainArray, isPlainObject, isString, log, lowerCamelCase, merge, mergeInto, missing, newObjectFromEach, normalizeFieldProps, peek, reverseForEach, success,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	Foundation = __webpack_require__(24);

	Response = __webpack_require__(142);

	Request = __webpack_require__(140);

	Filter = __webpack_require__(139);

	Session = __webpack_require__(122);

	config = __webpack_require__(138).config;

	PipelineRegistry = __webpack_require__(121);

	newObjectFromEach = Foundation.newObjectFromEach, compactFlatten = Foundation.compactFlatten, BaseObject = Foundation.BaseObject, reverseForEach = Foundation.reverseForEach, Promise = Foundation.Promise, log = Foundation.log, isPlainObject = Foundation.isPlainObject, inspect = Foundation.inspect, isString = Foundation.isString, isClass = Foundation.isClass, isFunction = Foundation.isFunction, inspect = Foundation.inspect, CommunicationStatus = Foundation.CommunicationStatus, merge = Foundation.merge, isPlainArray = Foundation.isPlainArray, decapitalize = Foundation.decapitalize, defineModule = Foundation.defineModule, Validator = Foundation.Validator, mergeInto = Foundation.mergeInto, arrayToTruthMap = Foundation.arrayToTruthMap, lowerCamelCase = Foundation.lowerCamelCase, peek = Foundation.peek, inspectedObjectLiteral = Foundation.inspectedObjectLiteral, escapeRegExp = Foundation.escapeRegExp;

	normalizeFieldProps = Validator.normalizeFieldProps;

	success = CommunicationStatus.success, missing = CommunicationStatus.missing, failure = CommunicationStatus.failure;

	defineModule(module, Pipeline = (function(superClass) {
	  var instantiateFilter, noOptions, preprocessFilter;

	  extend(Pipeline, superClass);

	  Pipeline.register = function() {
	    this.singletonClass();
	    return PipelineRegistry.register(this);
	  };

	  Pipeline.abstractClass();

	  Pipeline.postCreateConcreteClass = function(arg) {
	    var hotReloaded;
	    hotReloaded = arg.hotReloaded;
	    if (!hotReloaded) {
	      this.register();
	    }
	    this._defineQueryHandlers();
	    this._initClientApiRequest();
	    this._initFields();
	    return Pipeline.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
	  };

	  Pipeline.instantiateFilter = instantiateFilter = function(filter) {
	    if (isClass(filter)) {
	      return new filter;
	    } else if (isFunction(filter)) {
	      return filter(this);
	    } else if (filter instanceof Filter) {
	      return filter;
	    } else if (isPlainObject(filter)) {
	      return new Filter(filter);
	    } else {
	      throw "invalid filter: " + (inspect(filter)) + " " + (filter instanceof Filter);
	    }
	  };

	  Pipeline.getAliases = function() {
	    return this._aliases || {};
	  };

	  Pipeline.extendableProperty({
	    queries: {},
	    filters: [],
	    handlers: {},
	    clientApiMethodList: [],
	    fields: {}
	  });


	  /*
	  define a single filter OR an array of filters to define.
	  
	  NOTE: the order of filter definitions matter:
	    last-defined filters FIRST in the before-filter sequence
	    last-defined filters LAST in the after-filter sequence
	  
	    Example request processing sequence:
	  
	      filterDefinedLast.beforeFilter
	        filterDefinedSecond.beforeFilter
	          filterDefinedFirst.beforeFilter
	            handler
	          filterDefinedFirst.afterFilter
	        filterDefinedSecond.afterFilter
	      filterDefinedLast.afterFilter
	  
	  IN:
	    name: "myFilter"                    # only used for debug purposes
	    location: "server"/"client"/"both"  # where the filter will be applied
	    before: map:
	      requestType: (request) ->
	        OUT one of these (or a promise returning one of these):
	          request
	          - the same request if nothing was filtered
	          - a new request with the new, filtered values
	  
	          response in the form of:
	          - new Response
	          - null        >> request.missing()
	          - string      >> request.success data: message: string
	          - plainObject >> request.success data: plainObject
	          - plainArray  >> request.success data: plainArray
	          NOTE, if a response is returned, it shortcircuits the handler and all other
	            filters. The response is returned directly to the caller.
	  
	    after: map:
	      requestType: (response) ->
	        OUT: same or new response
	           NOTE: all after-filters are applied if the handler generated the first response object
	           UNLESS there is an error, in which case the error is returned directly.
	   */

	  Pipeline.filter = function(filter) {
	    return this.extendFilters(preprocessFilter(filter));
	  };


	  /*
	  add one or more handlers
	  
	  IN map:
	    requestType: (request) ->
	      IN: ArtEry.Request instance
	      OUT:
	        ArtEry.Response instance
	      OR
	        plain data which will be wrapped up in an ArtEry.Response instance
	  
	  @handler and @handlers are aliases.
	   */

	  Pipeline.handler = Pipeline.extendHandlers;

	  Pipeline.handlers = Pipeline.extendHandlers;

	  Pipeline.remoteServer = function(_remoteServer) {
	    this._remoteServer = _remoteServer;
	  };

	  Pipeline.apiRoot = function(_apiRoot) {
	    this._apiRoot = _apiRoot;
	  };

	  Pipeline.tableNamePrefix = function(_tableNamePrefix) {
	    this._tableNamePrefix = _tableNamePrefix;
	  };


	  /*
	  declare a query - used by ArtEryFlux
	  
	  IN: map:
	    queryName: map:
	      class properties for anonymous subclass of ArtEryQueryFluxModel
	  
	  queryName is used as both the ArtFlux model-name AND the ArtEry request-type:
	    Example:
	       * invoke query
	      myPipeline.myQueryName key: queryKey
	  
	       * subscribe to Model in FluxComponent
	      @subscriptions
	        myQueryName: queryKey
	   */

	  Pipeline.query = Pipeline.extendQueries;


	  /*
	  aliases
	  
	  INPUT: zero or more strings or arrays of strings
	    - arbitrary nesting of arrays is OK
	    - nulls are OK, they are ignored
	  OUTPUT: null
	  
	  NOTE: @aliases can only be called once
	  
	  example:
	    class Post extends Pipeline
	      @aliases "chapterPost"
	  
	  purpose:
	    - used by ArtEryFluxComponent to make model aliases
	      (see FluxModel.aliases)
	   */

	  Pipeline.aliases = function() {
	    this._aliases = newObjectFromEach(arguments, function(map, k, v) {
	      return map[lowerCamelCase(v)] = true;
	    });
	    return this;
	  };

	  function Pipeline(_options) {
	    this._options = _options != null ? _options : {};
	    this.getPrefixedTableName = bind(this.getPrefixedTableName, this);
	    Pipeline.__super__.constructor.apply(this, arguments);
	  }

	  Pipeline.prototype.getPrefixedTableName = function(tableName) {
	    return "" + this.tableNamePrefix + tableName;
	  };

	  Pipeline.getter("options", {
	    tableNamePrefix: function() {
	      return this["class"]._tableNamePrefix || config.tableNamePrefix;
	    },
	    tableName: function() {
	      return this.getPrefixedTableName(this.name);
	    },
	    normalizedFields: function() {
	      var k, nf, ref, v;
	      nf = {};
	      ref = this.fields;
	      for (k in ref) {
	        v = ref[k];
	        nf[k] = normalizeFieldProps(v);
	      }
	      return nf;
	    },
	    name: function() {
	      return this._name || (this._name = this._options.name || decapitalize(this["class"].getName()));
	    },
	    session: function() {
	      return this._session || (this._session = this._options.session || Session.singleton);
	    },
	    handlerRequestTypesMap: function(into) {
	      if (into == null) {
	        into = {};
	      }
	      mergeInto(into, this.handlers);
	      return into;
	    },
	    filterRequestTypesMap: function(into) {
	      var filter, i, len, ref;
	      if (into == null) {
	        into = {};
	      }
	      ref = this.filters;
	      for (i = 0, len = ref.length; i < len; i++) {
	        filter = ref[i];
	        mergeInto(into, filter.beforeFilters);
	      }
	      return into;
	    },
	    requestTypesMap: function(into) {
	      if (into == null) {
	        into = {};
	      }
	      return this.getHandlerRequestTypesMap(this.getFilterRequestTypesMap(into));
	    },
	    requestTypes: function() {
	      return Object.keys(this.requestTypesMap);
	    },
	    aliases: function() {
	      return Object.keys(this["class"].getAliases());
	    },
	    inspectedObjects: function() {
	      return inspectedObjectLiteral(this.name);
	    },
	    isRemoteClient: function() {
	      return !!this.remoteServer;
	    },
	    apiRoot: function() {
	      return this["class"]._apiRoot || config._apiRoot;
	    },
	    remoteServer: function() {
	      return this["class"]._remoteServer || config.remoteServer;
	    },
	    location: function() {
	      if (this.remoteServer) {
	        return config.location;
	      } else {
	        return "both";
	      }
	    },
	    restPath: function() {
	      return this._restPath || (this._restPath = "/" + config.apiRoot + "/" + this.name);
	    },
	    restPathRegex: function() {
	      return this._restPathRegex || (this._restPathRegex = RegExp("^" + (escapeRegExp(this.restPath)) + "(?:-([a-z0-9_]+))?(?:\\/([-_.a-z0-9]+))?", "i"));
	    },
	    beforeFilters: function() {
	      return this._beforeFilters || (this._beforeFilters = this.filters.slice().reverse());
	    },
	    afterFilters: function() {
	      return this.filters;
	    },
	    status: function() {
	      return "OK";
	    }
	  });

	  Pipeline.prototype.getBeforeFiltersFor = function(type, location) {
	    var filter, i, len, ref, results;
	    if (location == null) {
	      location = this.location;
	    }
	    ref = this.beforeFilters;
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      filter = ref[i];
	      if (filter.getBeforeFilter(type, location)) {
	        results.push(filter);
	      }
	    }
	    return results;
	  };

	  Pipeline.prototype.getAfterFiltersFor = function(type, location) {
	    var filter, i, len, ref, results;
	    if (location == null) {
	      location = this.location;
	    }
	    ref = this.afterFilters;
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      filter = ref[i];
	      if (filter.getAfterFilter(type, location)) {
	        results.push(filter);
	      }
	    }
	    return results;
	  };


	  /*
	  OVERRIDE
	  OUT: queryModelName:
	    query: (queryKey, pipeline) -> array of plain objects
	   */

	  Pipeline.prototype.getAutoDefinedQueries = function() {
	    return {};
	  };

	  Pipeline.prototype.getRequestProcessingReport = function(processingLocation) {
	    if (processingLocation == null) {
	      processingLocation = config.location;
	    }
	    return newObjectFromEach(this.requestTypes, (function(_this) {
	      return function(type) {
	        var filter;
	        return inspectedObjectLiteral(compactFlatten([
	          (function() {
	            var i, len, ref, results;
	            ref = this.getBeforeFiltersFor(type, processingLocation);
	            results = [];
	            for (i = 0, len = ref.length; i < len; i++) {
	              filter = ref[i];
	              results.push(filter.getName());
	            }
	            return results;
	          }).call(_this), processingLocation === "client" ? "[remote request]" : "[local handler]", (function() {
	            var i, len, ref, results;
	            ref = this.getAfterFiltersFor(type, processingLocation);
	            results = [];
	            for (i = 0, len = ref.length; i < len; i++) {
	              filter = ref[i];
	              results.push(filter.getName());
	            }
	            return results;
	          }).call(_this)
	        ]).join(' > '));
	      };
	    })(this));
	  };

	  Pipeline.getter({
	    pipelineReport: function(processingLocation) {
	      var out;
	      out = {
	        tableName: this.tableName,
	        fields: newObjectFromEach(this.fields, function(fieldProps) {
	          return newObjectFromEach(Object.keys(fieldProps).sort(), function(out, index, k) {
	            var v;
	            v = fieldProps[k];
	            if (!(k === "preprocess" || k === "validate" || k === "fieldType")) {
	              return out[k] = v;
	            }
	          });
	        })
	      };
	      if (processingLocation) {
	        out[processingLocation + "Processing"] = this.getRequestProcessingReport("client");
	      } else {
	        out.clientSideRequestProcessing = this.getRequestProcessingReport("client");
	        out.serverSideRequestProcessing = this.getRequestProcessingReport("server");
	        out.serverlessDevelopmentRequestProcessing = this.getRequestProcessingReport("both");
	      }
	      return out;
	    },
	    apiReport: function(options) {
	      var server;
	      if (options == null) {
	        options = {};
	      }
	      server = options.server;
	      return newObjectFromEach(this.requestTypes, (function(_this) {
	        return function(type) {
	          var method, obj, ref, url;
	          ref = Request.getRestClientParamsForArtEryRequest({
	            server: _this.remoteServer || server,
	            type: type,
	            restPath: _this.restPath
	          }), method = ref.method, url = ref.url;
	          return (
	            obj = {},
	            obj["" + (method.toLocaleUpperCase())] = url,
	            obj
	          );
	        };
	      })(this));
	    }
	  });

	  preprocessFilter = function(filter) {
	    var f, i, len, results;
	    if (isPlainArray(filter)) {
	      results = [];
	      for (i = 0, len = filter.length; i < len; i++) {
	        f = filter[i];
	        if (f) {
	          results.push(instantiateFilter(f));
	        }
	      }
	      return results;
	    } else {
	      return instantiateFilter(filter);
	    }
	  };

	  Pipeline._defineQueryHandlers = function() {
	    var k, ref, results, v;
	    ref = this.getQueries();
	    results = [];
	    for (k in ref) {
	      v = ref[k];
	      results.push(this.extendHandlers(k, (function() {
	        if (isFunction(v)) {
	          return v;
	        } else {
	          v = v.query;
	          if (!isFunction(v)) {
	            throw new Error("query delaration must be a function or have a 'query' property that is a function");
	          }
	          return v;
	        }
	      })()));
	    }
	    return results;
	  };

	  Pipeline.prototype._applyBeforeFilters = function(request) {
	    var applyNextFilter, filterIndex, filters;
	    filters = this.getBeforeFiltersFor(request.type);
	    filterIndex = 0;
	    applyNextFilter = (function(_this) {
	      return function(partiallyBeforeFilteredRequest) {
	        var filter;
	        if (partiallyBeforeFilteredRequest.isResponse || filterIndex >= filters.length) {
	          return Promise.resolve(partiallyBeforeFilteredRequest);
	        } else {
	          return (filter = filters[filterIndex++]).processBefore(partiallyBeforeFilteredRequest).then(function(result) {
	            if (result.isResponse) {
	              result.handled("beforeFilter: " + filter);
	            }
	            return applyNextFilter(result);
	          });
	        }
	      };
	    })(this);
	    return applyNextFilter(request);
	  };

	  Pipeline.prototype._applyHandler = function(request) {
	    var handler, message;
	    if (request.isResponse) {
	      return request;
	    }
	    if (config.location === "client" && this.remoteServer) {
	      return request.sendRemoteRequest(this.remoteServer);
	    } else if (handler = this.handlers[request.type]) {
	      return request.next(handler.call(this, request)).then((function(_this) {
	        return function(response) {
	          return response.handled("handler");
	        };
	      })(this));
	    } else {
	      message = "no Handler for request type: " + request.type;
	      log.error(message, {
	        request: request
	      });
	      return request.missing({
	        data: {
	          message: message
	        }
	      });
	    }
	  };

	  Pipeline.prototype._applyAfterFilters = function(response) {
	    var applyNextFilter, filterIndex, filters;
	    filters = this.getAfterFiltersFor(response.type);
	    filterIndex = 0;
	    applyNextFilter = function(partiallyAfterFilteredReponse) {
	      if (partiallyAfterFilteredReponse.notSuccessful || filterIndex >= filters.length) {
	        return Promise.resolve(partiallyAfterFilteredReponse);
	      } else {
	        return filters[filterIndex++].processAfter(partiallyAfterFilteredReponse).then(function(result) {
	          return applyNextFilter(result);
	        });
	      }
	    };
	    return applyNextFilter(response);
	  };

	  Pipeline.prototype._processRequest = function(request) {
	    if (isPlainObject(request)) {
	      request = new Request(merge(request, {
	        pipeline: this
	      }));
	    }
	    return this._applyBeforeFilters(request).then((function(_this) {
	      return function(request) {
	        return _this._applyHandler(request);
	      };
	    })(this)).then((function(_this) {
	      return function(response) {
	        return _this._applyAfterFilters(response);
	      };
	    })(this))["catch"]((function(_this) {
	      return function(error) {
	        return request.next(error);
	      };
	    })(this));
	  };


	  /*
	  options
	    all the Request options are valid here
	    returnResponseObject: true [default: false]
	      if true, the response object is returned, otherwise, just the data field is returned.
	   */

	  noOptions = {};

	  Pipeline.prototype._processClientRequest = function(type, options) {
	    var returnResponseObject;
	    if (options == null) {
	      options = noOptions;
	    }
	    returnResponseObject = options.returnResponseObject;
	    if (isString(options)) {
	      options = {
	        key: options
	      };
	    }
	    return this._processRequest(new Request(merge(options, {
	      type: type,
	      pipeline: this,
	      session: this.session.data,
	      sessionSignature: this.session.signature
	    }))).then((function(_this) {
	      return function(response) {
	        var data, session, sessionSignature, status;
	        status = response.status, data = response.data, session = response.session, sessionSignature = response.sessionSignature;
	        if (status === success) {
	          if (session) {
	            _this.session.data = session;
	            _this.session.signature = sessionSignature;
	          }
	          if (returnResponseObject) {
	            return response;
	          } else {
	            return data;
	          }
	        } else {
	          throw response;
	        }
	      };
	    })(this));
	  };

	  Pipeline._clientApiRequest = function(requestType) {
	    var base;
	    if (indexOf.call(this.getClientApiMethodList(), requestType) < 0) {
	      this.extendClientApiMethodList(requestType);
	    }
	    return (base = this.prototype)[requestType] || (base[requestType] = function(options) {
	      return this._processClientRequest(requestType, options);
	    });
	  };

	  Pipeline._initClientApiRequest = function() {
	    var handler, name, ref, results;
	    ref = this.getHandlers();
	    results = [];
	    for (name in ref) {
	      handler = ref[name];
	      results.push(this._clientApiRequest(name));
	    }
	    return results;
	  };

	  Pipeline._initFields = function() {
	    var filter, i, len, ref, results;
	    ref = this.getFilters();
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      filter = ref[i];
	      results.push(this.extendFields(filter.fields));
	    }
	    return results;
	  };

	  return Pipeline;

	})(__webpack_require__(136)));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var CommunicationStatus, FilterLocation, Pipeline, Request, Response, Session, arrayWith, config, defineModule, failure, isPresentString, isString, log, missing, present, ref, ref1, success,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(24), defineModule = ref.defineModule, log = ref.log, isString = ref.isString, present = ref.present, CommunicationStatus = ref.CommunicationStatus, arrayWith = ref.arrayWith;

	ref1 = __webpack_require__(116), Response = ref1.Response, Request = ref1.Request, Pipeline = ref1.Pipeline, Session = ref1.Session, config = ref1.config;

	success = CommunicationStatus.success, failure = CommunicationStatus.failure, missing = CommunicationStatus.missing;

	isPresentString = function(s) {
	  return isString(s) && present(s);
	};

	defineModule(module, FilterLocation = (function(superClass) {
	  var requestWithLog;

	  extend(FilterLocation, superClass);

	  function FilterLocation() {
	    return FilterLocation.__super__.constructor.apply(this, arguments);
	  }

	  FilterLocation.remoteServer("http://localhost:8085");

	  requestWithLog = function(request, name) {
	    var ref2;
	    return request.withData({
	      customLog: arrayWith((ref2 = request.data) != null ? ref2.customLog : void 0, name + "@" + config.location)
	    });
	  };

	  FilterLocation.filter({
	    location: "client",
	    name: "clientFilter",
	    before: {
	      filterTest: function(request) {
	        return requestWithLog(request, this.name);
	      }
	    }
	  });

	  FilterLocation.filter({
	    location: "both",
	    name: "bothFilter",
	    before: {
	      filterTest: function(request) {
	        return requestWithLog(request, this.name);
	      }
	    }
	  });

	  FilterLocation.filter({
	    location: "server",
	    name: "serverFilter",
	    before: {
	      filterTest: function(request) {
	        return requestWithLog(request, this.name);
	      }
	    }
	  });

	  FilterLocation.handlers({
	    filterTest: function(request) {
	      var ref2;
	      return request.success({
	        data: {
	          customLog: arrayWith((ref2 = request.data) != null ? ref2.customLog : void 0, "[handler@" + config.location + "]")
	        }
	      });
	    }
	  });

	  return FilterLocation;

	})(Pipeline));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var MyRemote, Pipeline, defineModule, log, ref,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(24), defineModule = ref.defineModule, log = ref.log;

	Pipeline = __webpack_require__(116).Pipeline;

	defineModule(module, MyRemote = (function(superClass) {
	  extend(MyRemote, superClass);

	  function MyRemote() {
	    return MyRemote.__super__.constructor.apply(this, arguments);
	  }

	  MyRemote.remoteServer("http://localhost:8085");

	  MyRemote.filter({
	    name: "handleByFilter",
	    before: {
	      handledByFilterRequest: function(request) {
	        return request.success();
	      }
	    }
	  });

	  MyRemote.handlers({
	    get: function(arg) {
	      var key;
	      key = arg.key;
	      return "Hello " + (key || 'World') + "!";
	    },
	    missing: function(request) {
	      return request.missing();
	    },
	    handledByFilterRequest: function() {}
	  });

	  return MyRemote;

	})(Pipeline));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	Used for buidling the minimal node.js code to deploy for production.
	Right now, this is tested with HEROKU, but it should work in other cases.

	Basically, you will build a single JS file that inludes:

	  require and init your pipelines
	  require this file

	See art-ery-heroku-dev for a concrete example. In fact, you can use that repository
	as a starting point. All you need to do is require your own pipelines in
	the index.coffe file.
	 */
	__webpack_require__(147).start({
	  numWorkers: process.env.WEB_CONCURRENCY || 1,
	  port: process.env.PORT
	});


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(148);


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(149).includeInNamespace(__webpack_require__(150)).addModules({
	  Main: __webpack_require__(151),
	  PromiseHttp: __webpack_require__(157),
	  PromiseJsonWebToken: __webpack_require__(160)
	});


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	var Ery, Server,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Ery = __webpack_require__(118);

	module.exports = Ery.Server || Ery.addNamespace('Server', Server = (function(superClass) {
	  extend(Server, superClass);

	  function Server() {
	    return Server.__super__.constructor.apply(this, arguments);
	  }

	  return Server;

	})(Neptune.Base));


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [__webpack_require__(151)];


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var ArtEry, CommunicationStatus, PromiseHttp, PromiseJsonWebToken, defineModule, isNumber, log, merge, newObjectFromEach, objectKeyCount, objectWithout, pipelines, privateSessionKey, ref, select, success, throng;

	throng = __webpack_require__(152);

	ref = __webpack_require__(24), select = ref.select, objectWithout = ref.objectWithout, newObjectFromEach = ref.newObjectFromEach, objectKeyCount = ref.objectKeyCount, log = ref.log, defineModule = ref.defineModule, merge = ref.merge, CommunicationStatus = ref.CommunicationStatus, isNumber = ref.isNumber;

	success = CommunicationStatus.success;

	PromiseHttp = __webpack_require__(157);

	pipelines = __webpack_require__(117).pipelines;

	PromiseJsonWebToken = __webpack_require__(160);


	/*
	generating a secury HMAC privateSessionKey:

	in short, run: openssl rand -base64 16

	http://security.stackexchange.com/questions/95972/what-are-requirements-for-hmac-secret-key
	Recommends 128bit string generated with a "cryptographically
	secure pseudo random number generator (CSPRNG)."

	http://osxdaily.com/2011/05/10/generate-random-passwords-command-line/
	 * 128 bits:
	> openssl rand -base64 16

	 * 256 bits:
	> openssl rand -base64 32
	 */

	privateSessionKey = "todo+generate+your+one+unique+key";

	ArtEry = __webpack_require__(116);

	defineModule(module, function() {
	  var Main;
	  return Main = (function() {
	    var httpMethodsToArtEryRequestTypes, signSession, verifySession;

	    function Main() {}

	    Main.defaults = {
	      port: 8085
	    };

	    httpMethodsToArtEryRequestTypes = {
	      get: "get",
	      post: "create",
	      put: "update",
	      "delete": "delete"
	    };

	    Main.findPipelineForRequest = function(request) {
	      var __, key, m, pipeline, pipelineName, type, url;
	      url = request.url;
	      for (pipelineName in pipelines) {
	        pipeline = pipelines[pipelineName];
	        if (m = url.match(pipeline.restPathRegex)) {
	          __ = m[0], type = m[1], key = m[2];
	          type || (type = httpMethodsToArtEryRequestTypes[request.method.toLocaleLowerCase()]);
	          if (type) {
	            return {
	              pipeline: pipeline,
	              type: type,
	              key: key
	            };
	          }
	        }
	      }
	      return null;
	    };


	    /*
	    NOTE: sessions expire after 30 days of inactivity; expiration is renewed every request.
	      TODO:
	      1) for your app, have a server-backend session record that can be manually expired
	         and store it's id in the session object
	      2) have a short-term expiration value you set in the session (5m - 1h)
	      3) check server-backend session for manual expiration after every short-term expiration
	      *) Use an ArtEry filter to do this. I'll probably write one and include it in ArtEry.Filters soon.
	        BUT it won't be tied to a specific backend; you'll still have to do that part yourself.
	     */

	    Main.signSession = signSession = function(plainObjectRequest, plainObjectsResponse) {
	      var session;
	      session = plainObjectsResponse.session;
	      return PromiseJsonWebToken.sign(objectWithout(session || plainObjectRequest.session || {}, "exp"), privateSessionKey, {
	        expiresIn: "30 days"
	      }).then(function(sessionSignature) {
	        return merge(plainObjectsResponse, {
	          sessionSignature: sessionSignature
	        });
	      });
	    };


	    /*
	    IN: plainObjectsRequest
	      .sessionSignature - required
	    OUT: (promise) verified session or {} if not valid
	     */

	    Main.verifySession = verifySession = function(plainObjectsRequest) {
	      var sessionSignature;
	      sessionSignature = plainObjectsRequest.sessionSignature;
	      if (!sessionSignature) {
	        return Promise.resolve({});
	      }
	      return PromiseJsonWebToken.verify(sessionSignature, privateSessionKey).then(function(session) {
	        return session;
	      })["catch"](function(e) {
	        return {};
	      });
	    };

	    Main.artEryPipelineApiHandler = function(request, plainObjectRequest) {
	      var found;
	      if (found = Main.findPipelineForRequest(request)) {
	        return verifySession(plainObjectRequest).then(function(session) {
	          var key, pipeline, requestOptions, type;
	          pipeline = found.pipeline, type = found.type, key = found.key;
	          requestOptions = {
	            type: type,
	            key: key,
	            originatedOnClient: true,
	            data: merge(plainObjectRequest.query, plainObjectRequest.data),
	            session: session
	          };
	          return pipeline._processRequest(requestOptions).then(function(arg) {
	            var plainObjectsResponse;
	            plainObjectsResponse = arg.plainObjectsResponse;
	            if (ArtEry.config.verbose) {
	              log({
	                out: plainObjectsResponse
	              });
	            }
	            return signSession(plainObjectRequest, plainObjectsResponse);
	          });
	        });
	      }
	    };

	    Main.getArtEryPipelineApiInfo = function() {
	      var port, ref1, server;
	      ref1 = Main.options, server = ref1.server, port = ref1.port;
	      server || (server = "http://localhost");
	      if (port) {
	        server += ":" + port;
	      }
	      return {
	        "Art.Ery.pipeline.json.rest.api": newObjectFromEach(pipelines, function(pipeline) {
	          return pipeline.getApiReport({
	            server: server
	          });
	        })
	      };
	    };

	    Main.artEryPipelineDefaultHandler = function(arg, plainObjectRequest) {
	      var apiPath, url;
	      url = arg.url;
	      apiPath = "/" + ArtEry.config.apiRoot;
	      if (url === "/" || apiPath === url.slice(0, apiPath.length)) {
	        return {
	          status: "missing",
	          data: {
	            api: Main.getArtEryPipelineApiInfo()
	          }
	        };
	      } else {
	        return {
	          status: "missing"
	        };
	      }
	    };

	    Main.start = function(options) {
	      var numWorkers, port, startSingleServer;
	      Main.options = options || {};
	      if (options.port == null) {
	        options.port = Main.defaults.port;
	      }
	      options.port |= 0;
	      if (!(0 < objectKeyCount(pipelines))) {
	        throw new Error("no pipelines");
	      }
	      startSingleServer = function() {
	        ArtEry.configure({
	          location: "server"
	        });
	        return PromiseHttp.start(merge(options, {
	          name: "Art.Ery.Server",
	          commonResponseHeaders: {
	            "Access-Control-Allow-Origin": "*"
	          },
	          apiHandlers: [Main.artEryPipelineApiHandler, Main.artEryPipelineDefaultHandler]
	        }));
	      };
	      numWorkers = options.numWorkers, port = options.port;
	      log({
	        ArtEryServer: {
	          numWorkers: numWorkers,
	          port: options.port,
	          env: process.env
	        }
	      });
	      if (numWorkers > 1) {
	        return throng({
	          start: startSingleServer,
	          workers: numWorkers,
	          lifetime: 2e308
	        });
	      } else {
	        return startSingleServer();
	      }
	    };

	    return Main;

	  })();
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	const cluster = __webpack_require__(153);
	const EventEmitter = __webpack_require__(154).EventEmitter;
	const defaults = __webpack_require__(155);
	const cpuCount = __webpack_require__(156).cpus().length;

	const DEFAULT_OPTIONS = {
	  workers: cpuCount,
	  lifetime: Infinity,
	  grace: 5000
	};

	const NOOP = () => {};

	module.exports = function throng(options, startFunction) {
	  options = options || {};
	  let startFn = options.start || startFunction || options;
	  let masterFn = options.master || NOOP;

	  if (typeof startFn !== 'function') {
	    throw new Error('Start function required');
	  }
	  if (cluster.isWorker) {
	    return startFn(cluster.worker.id);
	  }

	  let opts = isNaN(options) ?
	    defaults(options, DEFAULT_OPTIONS) : defaults({ workers: options }, DEFAULT_OPTIONS);
	  let emitter = new EventEmitter();
	  let running = true;
	  let runUntil = Date.now() + opts.lifetime;

	  listen();
	  masterFn();
	  fork();

	  function listen() {
	    cluster.on('exit', revive);
	    emitter.once('shutdown', shutdown);
	    process
	      .on('SIGINT', proxySignal)
	      .on('SIGTERM', proxySignal);
	  }

	  function fork() {
	    for (var i = 0; i < opts.workers; i++) {
	      cluster.fork();
	    }
	  }

	  function proxySignal() {
	    emitter.emit('shutdown');
	  }

	  function shutdown() {
	    running = false;
	    for (var id in cluster.workers) {
	      cluster.workers[id].process.kill();
	    }
	    setTimeout(forceKill, opts.grace).unref();
	  }

	  function revive(worker, code, signal) {
	    if (running && Date.now() < runUntil) cluster.fork();
	  }

	  function forceKill() {
	    for (var id in cluster.workers) {
	      cluster.workers[id].kill();
	    }
	    process.exit();
	  }
	};


/***/ },
/* 153 */
/***/ function(module, exports) {

	module.exports = require("cluster");

/***/ },
/* 154 */
/***/ function(module, exports) {

	module.exports = require("events");

/***/ },
/* 155 */
/***/ function(module, exports) {

	/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]';

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  // Safari 9 makes `arguments.length` enumerable in strict mode.
	  var result = (isArray(value) || isArguments(value))
	    ? baseTimes(value.length, String)
	    : [];

	  var length = result.length,
	      skipIndexes = !!length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Used by `_.defaults` to customize its `_.assignIn` use.
	 *
	 * @private
	 * @param {*} objValue The destination value.
	 * @param {*} srcValue The source value.
	 * @param {string} key The key of the property to assign.
	 * @param {Object} object The parent object of `objValue`.
	 * @returns {*} Returns the value to assign.
	 */
	function assignInDefaults(objValue, srcValue, key, object) {
	  if (objValue === undefined ||
	      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	    return srcValue;
	  }
	  return objValue;
	}

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    object[key] = value;
	  }
	}

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = array;
	    return apply(func, this, otherArgs);
	  };
	}

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    assignValue(object, key, newValue === undefined ? source[key] : newValue);
	  }
	  return object;
	}

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * This method is like `_.assignIn` except that it accepts `customizer`
	 * which is invoked to produce the assigned values. If `customizer` returns
	 * `undefined`, assignment is handled by the method instead. The `customizer`
	 * is invoked with five arguments: (objValue, srcValue, key, object, source).
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @alias extendWith
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} sources The source objects.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @returns {Object} Returns `object`.
	 * @see _.assignWith
	 * @example
	 *
	 * function customizer(objValue, srcValue) {
	 *   return _.isUndefined(objValue) ? srcValue : objValue;
	 * }
	 *
	 * var defaults = _.partialRight(_.assignInWith, customizer);
	 *
	 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
	  copyObject(source, keysIn(source), object, customizer);
	});

	/**
	 * Assigns own and inherited enumerable string keyed properties of source
	 * objects to the destination object for all destination properties that
	 * resolve to `undefined`. Source objects are applied from left to right.
	 * Once a property is set, additional values of the same property are ignored.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.defaultsDeep
	 * @example
	 *
	 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var defaults = baseRest(function(args) {
	  args.push(undefined, assignInDefaults);
	  return apply(assignInWith, undefined, args);
	});

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	module.exports = defaults;


/***/ },
/* 156 */
/***/ function(module, exports) {

	module.exports = require("os");

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, Promise, PromiseHttp, dateFormat, defineModule, formattedInspect, http, inspect, inspectLean, isJsonType, isPlainArray, isPlainObject, log, merge, querystring, ref, select,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(24), inspect = ref.inspect, isPlainObject = ref.isPlainObject, formattedInspect = ref.formattedInspect, isJsonType = ref.isJsonType, select = ref.select, defineModule = ref.defineModule, log = ref.log, Promise = ref.Promise, BaseObject = ref.BaseObject, merge = ref.merge, isPlainArray = ref.isPlainArray, dateFormat = ref.dateFormat, inspectLean = ref.inspectLean;

	http = __webpack_require__(158);

	querystring = __webpack_require__(159);

	defineModule(module, PromiseHttp = (function(superClass) {
	  var logTime;

	  extend(PromiseHttp, superClass);

	  PromiseHttp.start = function(options) {
	    return new PromiseHttp(options).start(options);
	  };

	  function PromiseHttp(options) {
	    var handlers;
	    if (options == null) {
	      options = {};
	    }
	    handlers = options.handlers;
	    this._commonResponseHeaders = options.commonResponseHeaders;
	    this._handlers = options.handlers || [];
	    this.addApiHandler(options.apiHandlers);
	  }

	  PromiseHttp.getter("handlers");


	  /*
	  IN:
	    handler: (request, data) -> promise.then (simpleResponse) ->
	      IN: request is an IncomingMessaage (https://nodejs.org/api/http.html#http_class_http_incomingmessage)
	      IN: data - a string for now, but might also be a Buffer later
	  
	  IN: hanlder: array of handlers; each handler gets added
	  IN: null -> noop
	  
	  OUT:
	    if falsish, then the next handler in the chain is tried
	    else simpleResponse or promise returning simpleResponse
	  
	    simpleResponse:
	      headers: simple object defining the response headers
	      data: unintepreted response data
	      json: JSON.stringified repsonse data
	         * also sets the correct response headers
	   */

	  PromiseHttp.prototype.addHandler = function(handler) {
	    switch (false) {
	      case !!handler:
	        return null;
	      case !isPlainArray(handler):
	        return this._handlers = this._handlers.concat(handler);
	      default:
	        return this._handlers.push(handler);
	    }
	  };


	  /*
	  IN: apiHandler: (request, plainObjectStructureInput) -> Promise.then (plainObjectStructureOutput) ->
	  IN: apiHandler can be an array of apiHandlers to add
	  IN: null -> noop
	  
	  apiHandlers don't need to manage:
	    - parsing and encoding JSON
	    - response headers
	  
	  apiHandler OUT:
	    if the handler can't respond to that request
	      null/false
	    else if success
	      plainObjectStructureOutput or a promise resolving to plainObjectStructureOutput
	    else if failure
	      throw error or return rejected promise
	   */

	  PromiseHttp.prototype.addApiHandler = function(apiHandler) {
	    var h, j, len, results;
	    switch (false) {
	      case !!apiHandler:
	        return null;
	      case !isPlainArray(apiHandler):
	        results = [];
	        for (j = 0, len = apiHandler.length; j < len; j++) {
	          h = apiHandler[j];
	          results.push(this.addApiHandler(h));
	        }
	        return results;
	        break;
	      default:
	        return this.addHandler(function(request, data) {
	          return Promise.then(function() {
	            return JSON.parse(data || "{}");
	          })["catch"](function() {
	            throw new Error("requested data was not valid JSON: " + data);
	          }).then(function(parsedData) {
	            var __, query, ref1, url;
	            url = request.url;
	            ref1 = url.split("?"), __ = ref1[0], query = ref1[1];
	            if (query) {
	              return merge({
	                query: merge(querystring.parse(query))
	              }, parsedData);
	            } else {
	              return parsedData;
	            }
	          }).then(function(parsedData) {
	            return apiHandler(request, parsedData);
	          })["catch"](function(error) {
	            return {
	              status: "failure",
	              message: (new Date) + " PromiseHttp request: " + request.method + " " + request.url + ", ERROR: " + (formattedInspect(error))
	            };
	          }).then(function(responseData) {
	            var ref1;
	            if (!responseData) {
	              return false;
	            }
	            if (!isJsonType(responseData)) {
	              throw new Error("INTERNAL ERROR: api handler did not return a JSON compatible type: " + (inspect(responseData)));
	            }
	            return {
	              statusCode: (function() {
	                switch (responseData.status) {
	                  case "missing":
	                    return 404;
	                  case "failure":
	                    return 500;
	                  default:
	                    return 200;
	                }
	              })(),
	              headers: {
	                "Content-Type": 'application/json'
	              },
	              data: ((ref1 = request.headers.accept) != null ? ref1.match(/json/) : void 0) ? JSON.stringify(responseData) : formattedInspect(responseData, 160)
	            };
	          });
	        });
	    }
	  };

	  logTime = function() {
	    return dateFormat("UTC:yyyy-mm-dd_HH-MM-ss");
	  };

	  PromiseHttp.prototype.start = function(options) {
	    var port;
	    if (options == null) {
	      options = {};
	    }
	    port = options.port;
	    return http.createServer((function(_this) {
	      return function(request, response) {
	        var receivedData;
	        receivedData = "";
	        request.on('data', function(chunk) {
	          return receivedData = "" + receivedData + chunk;
	        });
	        return request.on('end', function() {
	          return Promise.then(function() {
	            var fn, handler, i, j, len, ref1, serilizer;
	            serilizer = new Promise.Serializer;
	            serilizer.then(function() {
	              return false;
	            });
	            ref1 = _this.handlers;
	            fn = function(handler, i) {
	              return serilizer.then(function(previous) {
	                return previous || handler(request, receivedData);
	              });
	            };
	            for (i = j = 0, len = ref1.length; j < len; i = ++j) {
	              handler = ref1[i];
	              fn(handler, i);
	            }
	            return serilizer;
	          }).then(function(plainResponse) {
	            var data, headers, k, logObject, obj, ref1, ref2, ref3, statusCode, v;
	            if (plainResponse) {
	              headers = plainResponse.headers, data = plainResponse.data, statusCode = (ref1 = plainResponse.statusCode) != null ? ref1 : 200;
	              logObject = (
	                obj = {},
	                obj["" + request.method] = request.url,
	                obj
	              );
	              if (receivedData) {
	                logObject["in"] = receivedData;
	              }
	              logObject.bytesOut = (plainResponse != null ? (ref2 = plainResponse.data) != null ? ref2.length : void 0 : void 0) || 0;
	              log((logTime().replace(/\:/g, '_')) + ": " + statusCode + ": " + (inspectLean(logObject)));
	              response.statusCode = statusCode;
	              ref3 = merge(_this._commonResponseHeaders, headers);
	              for (k in ref3) {
	                v = ref3[k];
	                response.setHeader(k, v);
	              }
	              return response.end(data);
	            } else {
	              return log.error("REQUEST NOT HANDLED: " + request.method + ": " + request.url);
	            }
	          })["catch"](function(error) {
	            log.error((logTime()) + " PromiseHttp: " + request.method + " " + request.url + ", ERROR:", error);
	            console.error(error);
	            return response.end((logTime()) + " PromiseHttp: " + request.method + " " + request.url + ", ERROR: " + (formattedInspect(error)));
	          });
	        });
	      };
	    })(this)).listen(port, function() {
	      return log((options.name || 'PromiseHttpServer') + " listening on: http://localhost:" + port);
	    });
	  };

	  return PromiseHttp;

	})(BaseObject));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 158 */
/***/ function(module, exports) {

	module.exports = require('http');

/***/ },
/* 159 */
/***/ function(module, exports) {

	module.exports = require("querystring");

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	var Promise, PromiseJsonWebToken, jwt;

	jwt = __webpack_require__(161);

	Promise = __webpack_require__(24).Promise;

	module.exports = PromiseJsonWebToken = (function() {
	  function PromiseJsonWebToken() {}

	  PromiseJsonWebToken.sign = function(payload, secretOrPrivateKey, options) {
	    return Promise.withCallback(function(callback) {
	      return jwt.sign(payload, secretOrPrivateKey, options, callback);
	    });
	  };

	  PromiseJsonWebToken.verify = function(token, secretOrPrivateKey, options) {
	    return Promise.withCallback(function(callback) {
	      return jwt.verify(token, secretOrPrivateKey, options, callback);
	    });
	  };

	  return PromiseJsonWebToken;

	})();


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	  decode: __webpack_require__(162),
	  verify: __webpack_require__(178),
	  sign: __webpack_require__(184),
	  JsonWebTokenError: __webpack_require__(179),
	  NotBeforeError: __webpack_require__(180),
	  TokenExpiredError: __webpack_require__(181),
	};


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	var jws = __webpack_require__(163);

	module.exports = function (jwt, options) {
	  options = options || {};
	  var decoded = jws.decode(jwt, options);
	  if (!decoded) { return null; }
	  var payload = decoded.payload;

	  //try parse the payload
	  if(typeof payload === 'string') {
	    try {
	      var obj = JSON.parse(payload);
	      if(typeof obj === 'object') {
	        payload = obj;
	      }
	    } catch (e) { }
	  }

	  //return header if `complete` option is enabled.  header includes claims
	  //such as `kid` and `alg` used to select the key within a JWKS needed to
	  //verify the signature
	  if (options.complete === true) {
	    return {
	      header: decoded.header,
	      payload: payload,
	      signature: decoded.signature
	    };
	  }
	  return payload;
	};


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/*global exports*/
	var SignStream = __webpack_require__(164);
	var VerifyStream = __webpack_require__(177);

	var ALGORITHMS = [
	  'HS256', 'HS384', 'HS512',
	  'RS256', 'RS384', 'RS512',
	  'ES256', 'ES384', 'ES512'
	];

	exports.ALGORITHMS = ALGORITHMS;
	exports.sign = SignStream.sign;
	exports.verify = VerifyStream.verify;
	exports.decode = VerifyStream.decode;
	exports.isValid = VerifyStream.isValid;
	exports.createSign = function createSign(opts) {
	  return new SignStream(opts);
	};
	exports.createVerify = function createVerify(opts) {
	  return new VerifyStream(opts);
	};


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/*global module*/
	var base64url = __webpack_require__(165);
	var DataStream = __webpack_require__(166);
	var jwa = __webpack_require__(170);
	var Stream = __webpack_require__(168);
	var toString = __webpack_require__(176);
	var util = __webpack_require__(169);

	function jwsSecuredInput(header, payload, encoding) {
	  encoding = encoding || 'utf8';
	  var encodedHeader = base64url(toString(header), 'binary');
	  var encodedPayload = base64url(toString(payload), encoding);
	  return util.format('%s.%s', encodedHeader, encodedPayload);
	}

	function jwsSign(opts) {
	  var header = opts.header;
	  var payload = opts.payload;
	  var secretOrKey = opts.secret || opts.privateKey;
	  var encoding = opts.encoding;
	  var algo = jwa(header.alg);
	  var securedInput = jwsSecuredInput(header, payload, encoding);
	  var signature = algo.sign(securedInput, secretOrKey);
	  return util.format('%s.%s', securedInput, signature);
	}

	function SignStream(opts) {
	  var secret = opts.secret||opts.privateKey||opts.key;
	  var secretStream = new DataStream(secret);
	  this.readable = true;
	  this.header = opts.header;
	  this.encoding = opts.encoding;
	  this.secret = this.privateKey = this.key = secretStream;
	  this.payload = new DataStream(opts.payload);
	  this.secret.once('close', function () {
	    if (!this.payload.writable && this.readable)
	      this.sign();
	  }.bind(this));

	  this.payload.once('close', function () {
	    if (!this.secret.writable && this.readable)
	      this.sign();
	  }.bind(this));
	}
	util.inherits(SignStream, Stream);

	SignStream.prototype.sign = function sign() {
	  try {
	    var signature = jwsSign({
	      header: this.header,
	      payload: this.payload.buffer,
	      secret: this.secret.buffer,
	      encoding: this.encoding
	    });
	    this.emit('done', signature);
	    this.emit('data', signature);
	    this.emit('end');
	    this.readable = false;
	    return signature;
	  } catch (e) {
	    this.readable = false;
	    this.emit('error', e);
	    this.emit('close');
	  }
	};

	SignStream.sign = jwsSign;

	module.exports = SignStream;


/***/ },
/* 165 */
/***/ function(module, exports) {

	function fromBase64(base64string) {
	  return (
	    base64string
	      .replace(/=/g, '')
	      .replace(/\+/g, '-')
	      .replace(/\//g, '_')
	  );
	}

	function toBase64(base64UrlString) {
	  if (Buffer.isBuffer(base64UrlString))
	    base64UrlString = base64UrlString.toString();

	  var b64str = padString(base64UrlString)
	    .replace(/\-/g, '+')
	    .replace(/_/g, '/');
	  return b64str;
	}

	function padString(string) {
	  var segmentLength = 4;
	  var stringLength = string.length;
	  var diff = string.length % segmentLength;
	  if (!diff)
	    return string;
	  var position = stringLength;
	  var padLength = segmentLength - diff;
	  var paddedStringLength = stringLength + padLength;
	  var buffer = Buffer(paddedStringLength);
	  buffer.write(string);
	  while (padLength--)
	    buffer.write('=', position++);
	  return buffer.toString();
	}

	function decodeBase64Url(base64UrlString, encoding) {
	  return Buffer(toBase64(base64UrlString), 'base64').toString(encoding);
	}

	function base64url(stringOrBuffer, encoding) {
	  return fromBase64(Buffer(stringOrBuffer, encoding).toString('base64'));
	}

	function toBuffer(base64string) {
	  return Buffer(toBase64(base64string), 'base64');
	}

	base64url.toBase64 = toBase64;
	base64url.fromBase64 = fromBase64;
	base64url.decode = decodeBase64Url;
	base64url.encode = base64url;
	base64url.toBuffer = toBuffer;

	module.exports = base64url;


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/*global module, process*/
	var Buffer = __webpack_require__(167).Buffer;
	var Stream = __webpack_require__(168);
	var util = __webpack_require__(169);

	function DataStream(data) {
	  this.buffer = null;
	  this.writable = true;
	  this.readable = true;

	  // No input
	  if (!data) {
	    this.buffer = new Buffer(0);
	    return this;
	  }

	  // Stream
	  if (typeof data.pipe === 'function') {
	    this.buffer = new Buffer(0);
	    data.pipe(this);
	    return this;
	  }

	  // Buffer or String
	  // or Object (assumedly a passworded key)
	  if (data.length || typeof data === 'object') {
	    this.buffer = data;
	    this.writable = false;
	    process.nextTick(function () {
	      this.emit('end', data);
	      this.readable = false;
	      this.emit('close');
	    }.bind(this));
	    return this;
	  }

	  throw new TypeError('Unexpected data type ('+ typeof data + ')');
	}
	util.inherits(DataStream, Stream);

	DataStream.prototype.write = function write(data) {
	  this.buffer = Buffer.concat([this.buffer, Buffer(data)]);
	  this.emit('data', data);
	};

	DataStream.prototype.end = function end(data) {
	  if (data)
	    this.write(data);
	  this.emit('end', data);
	  this.emit('close');
	  this.writable = false;
	  this.readable = false;
	};

	module.exports = DataStream;


/***/ },
/* 167 */
/***/ function(module, exports) {

	module.exports = require("buffer");

/***/ },
/* 168 */
/***/ function(module, exports) {

	module.exports = require("stream");

/***/ },
/* 169 */
/***/ function(module, exports) {

	module.exports = require("util");

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	var bufferEqual = __webpack_require__(171);
	var base64url = __webpack_require__(165);
	var crypto = __webpack_require__(172);
	var formatEcdsa = __webpack_require__(173);
	var util = __webpack_require__(169);

	var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512" and "none".'
	var MSG_INVALID_SECRET = 'secret must be a string or buffer';
	var MSG_INVALID_VERIFIER_KEY = 'key must be a string or a buffer';
	var MSG_INVALID_SIGNER_KEY = 'key must be a string, a buffer or an object';

	function typeError(template) {
	  var args = [].slice.call(arguments, 1);
	  var errMsg = util.format.bind(util, template).apply(null, args);
	  return new TypeError(errMsg);
	}

	function bufferOrString(obj) {
	  return Buffer.isBuffer(obj) || typeof obj === 'string';
	}

	function normalizeInput(thing) {
	  if (!bufferOrString(thing))
	    thing = JSON.stringify(thing);
	  return thing;
	}

	function createHmacSigner(bits) {
	  return function sign(thing, secret) {
	    if (!bufferOrString(secret))
	      throw typeError(MSG_INVALID_SECRET);
	    thing = normalizeInput(thing);
	    var hmac = crypto.createHmac('sha' + bits, secret);
	    var sig = (hmac.update(thing), hmac.digest('base64'))
	    return base64url.fromBase64(sig);
	  }
	}

	function createHmacVerifier(bits) {
	  return function verify(thing, signature, secret) {
	    var computedSig = createHmacSigner(bits)(thing, secret);
	    return bufferEqual(Buffer(signature), Buffer(computedSig));
	  }
	}

	function createKeySigner(bits) {
	 return function sign(thing, privateKey) {
	    if (!bufferOrString(privateKey) && !(typeof privateKey === 'object'))
	      throw typeError(MSG_INVALID_SIGNER_KEY);
	    thing = normalizeInput(thing);
	    // Even though we are specifying "RSA" here, this works with ECDSA
	    // keys as well.
	    var signer = crypto.createSign('RSA-SHA' + bits);
	    var sig = (signer.update(thing), signer.sign(privateKey, 'base64'));
	    return base64url.fromBase64(sig);
	  }
	}

	function createKeyVerifier(bits) {
	  return function verify(thing, signature, publicKey) {
	    if (!bufferOrString(publicKey))
	      throw typeError(MSG_INVALID_VERIFIER_KEY);
	    thing = normalizeInput(thing);
	    signature = base64url.toBase64(signature);
	    var verifier = crypto.createVerify('RSA-SHA' + bits);
	    verifier.update(thing);
	    return verifier.verify(publicKey, signature, 'base64');
	  }
	}

	function createECDSASigner(bits) {
	  var inner = createKeySigner(bits);
	  return function sign() {
	    var signature = inner.apply(null, arguments);
	    signature = formatEcdsa.derToJose(signature, 'ES' + bits);
	    return signature;
	  };
	}

	function createECDSAVerifer(bits) {
	  var inner = createKeyVerifier(bits);
	  return function verify(thing, signature, publicKey) {
	    signature = formatEcdsa.joseToDer(signature, 'ES' + bits).toString('base64');
	    var result = inner(thing, signature, publicKey);
	    return result;
	  };
	}

	function createNoneSigner() {
	  return function sign() {
	    return '';
	  }
	}

	function createNoneVerifier() {
	  return function verify(thing, signature) {
	    return signature === '';
	  }
	}

	module.exports = function jwa(algorithm) {
	  var signerFactories = {
	    hs: createHmacSigner,
	    rs: createKeySigner,
	    es: createECDSASigner,
	    none: createNoneSigner,
	  }
	  var verifierFactories = {
	    hs: createHmacVerifier,
	    rs: createKeyVerifier,
	    es: createECDSAVerifer,
	    none: createNoneVerifier,
	  }
	  var match = algorithm.match(/^(RS|ES|HS)(256|384|512)$|^(none)$/i);
	  if (!match)
	    throw typeError(MSG_INVALID_ALGORITHM, algorithm);
	  var algo = (match[1] || match[3]).toLowerCase();
	  var bits = match[2];

	  return {
	    sign: signerFactories[algo](bits),
	    verify: verifierFactories[algo](bits),
	  }
	};


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/*jshint node:true */
	'use strict';
	var Buffer = __webpack_require__(167).Buffer; // browserify
	var SlowBuffer = __webpack_require__(167).SlowBuffer;

	module.exports = bufferEq;

	function bufferEq(a, b) {

	  // shortcutting on type is necessary for correctness
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    return false;
	  }

	  // buffer sizes should be well-known information, so despite this
	  // shortcutting, it doesn't leak any information about the *contents* of the
	  // buffers.
	  if (a.length !== b.length) {
	    return false;
	  }

	  var c = 0;
	  for (var i = 0; i < a.length; i++) {
	    /*jshint bitwise:false */
	    c |= a[i] ^ b[i]; // XOR
	  }
	  return c === 0;
	}

	bufferEq.install = function() {
	  Buffer.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
	    return bufferEq(this, that);
	  };
	};

	var origBufEqual = Buffer.prototype.equal;
	var origSlowBufEqual = SlowBuffer.prototype.equal;
	bufferEq.restore = function() {
	  Buffer.prototype.equal = origBufEqual;
	  SlowBuffer.prototype.equal = origSlowBufEqual;
	};


/***/ },
/* 172 */
/***/ function(module, exports) {

	module.exports = require("crypto");

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var base64Url = __webpack_require__(174).escape;

	var getParamBytesForAlg = __webpack_require__(175);

	var MAX_OCTET = 0x80,
		CLASS_UNIVERSAL = 0,
		PRIMITIVE_BIT = 0x20,
		TAG_SEQ = 0x10,
		TAG_INT = 0x02,
		ENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6),
		ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);

	function signatureAsBuffer(signature) {
		if (Buffer.isBuffer(signature)) {
			return signature;
		} else if ('string' === typeof signature) {
			return new Buffer(signature, 'base64');
		}

		throw new TypeError('ECDSA signature must be a Base64 string or a Buffer');
	}

	function derToJose(signature, alg) {
		signature = signatureAsBuffer(signature);
		var paramBytes = getParamBytesForAlg(alg);

		// the DER encoded param should at most be the param size, plus a padding
		// zero, since due to being a signed integer
		var maxEncodedParamLength = paramBytes + 1;

		var inputLength = signature.length;

		var offset = 0;
		if (signature[offset++] !== ENCODED_TAG_SEQ) {
			throw new Error('Could not find expected "seq"');
		}

		var seqLength = signature[offset++];
		if (seqLength === (MAX_OCTET | 1)) {
			seqLength = signature[offset++];
		}

		if (inputLength - offset < seqLength) {
			throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
		}

		if (signature[offset++] !== ENCODED_TAG_INT) {
			throw new Error('Could not find expected "int" for "r"');
		}

		var rLength = signature[offset++];

		if (inputLength - offset - 2 < rLength) {
			throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
		}

		if (maxEncodedParamLength < rLength) {
			throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
		}

		var rOffset = offset;
		offset += rLength;

		if (signature[offset++] !== ENCODED_TAG_INT) {
			throw new Error('Could not find expected "int" for "s"');
		}

		var sLength = signature[offset++];

		if (inputLength - offset !== sLength) {
			throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
		}

		if (maxEncodedParamLength < sLength) {
			throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
		}

		var sOffset = offset;
		offset += sLength;

		if (offset !== inputLength) {
			throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
		}

		var rPadding = paramBytes - rLength,
			sPadding = paramBytes - sLength;

		var dst = new Buffer(rPadding + rLength + sPadding + sLength);

		for (offset = 0; offset < rPadding; ++offset) {
			dst[offset] = 0;
		}
		signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);

		offset = paramBytes;

		for (var o = offset; offset < o + sPadding; ++offset) {
			dst[offset] = 0;
		}
		signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);

		dst = dst.toString('base64');
		dst = base64Url(dst);

		return dst;
	}

	function countPadding(buf, start, stop) {
		var padding = 0;
		for (var n = stop; start + padding < n && buf[start + padding] === 0;) {
			++padding;
		}

		var needsSign = buf[start + padding] >= MAX_OCTET;
		if (needsSign) {
			--padding;
		}

		return padding;
	}

	function joseToDer(signature, alg) {
		signature = signatureAsBuffer(signature);
		var paramBytes = getParamBytesForAlg(alg);

		var signatureBytes = signature.length;
		if (signatureBytes !== paramBytes * 2) {
			throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
		}

		var rPadding = countPadding(signature, 0, paramBytes);
		var sPadding = countPadding(signature, paramBytes, signature.length);
		var rLength = paramBytes - rPadding;
		var sLength = paramBytes - sPadding;

		var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;

		var shortLength = rsBytes < MAX_OCTET;

		var dst = new Buffer((shortLength ? 2 : 3) + rsBytes);

		var offset = 0;
		dst[offset++] = ENCODED_TAG_SEQ;
		if (shortLength) {
			// Bit 8 has value "0"
			// bits 7-1 give the length.
			dst[offset++] = rsBytes;
		} else {
			// Bit 8 of first octet has value "1"
			// bits 7-1 give the number of additional length octets.
			dst[offset++] = MAX_OCTET	| 1;
			// length, base 256
			dst[offset++] = rsBytes & 0xff;
		}
		dst[offset++] = ENCODED_TAG_INT;
		dst[offset++] = rLength;
		if (rPadding < 0) {
			dst[offset++] = 0;
			offset += signature.copy(dst, offset, 0, paramBytes);
		} else {
			offset += signature.copy(dst, offset, rPadding, paramBytes);
		}
		dst[offset++] = ENCODED_TAG_INT;
		dst[offset++] = sLength;
		if (sPadding < 0) {
			dst[offset++] = 0;
			signature.copy(dst, offset, paramBytes);
		} else {
			signature.copy(dst, offset, paramBytes + sPadding);
		}

		return dst;
	}

	module.exports = {
		derToJose: derToJose,
		joseToDer: joseToDer
	};


/***/ },
/* 174 */
/***/ function(module, exports) {

	'use strict';

	var base64url = module.exports;

	base64url.unescape = function unescape (str) {
	  return (str + '==='.slice((str.length + 3) % 4))
	    .replace(/\-/g, '+')
	    .replace(/_/g, '/');
	};

	base64url.escape = function escape (str) {
	  return str.replace(/\+/g, '-')
	    .replace(/\//g, '_')
	    .replace(/=/g, '');
	};

	base64url.encode = function encode (str) {
	  return this.escape(new Buffer(str).toString('base64'));
	};

	base64url.decode = function decode (str) {
	  return new Buffer(this.unescape(str), 'base64').toString();
	};


/***/ },
/* 175 */
/***/ function(module, exports) {

	'use strict';

	function getParamSize(keySize) {
		var result = ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);
		return result;
	}

	var paramBytesForAlg = {
		ES256: getParamSize(256),
		ES384: getParamSize(384),
		ES512: getParamSize(521)
	};

	function getParamBytesForAlg(alg) {
		var paramBytes = paramBytesForAlg[alg];
		if (paramBytes) {
			return paramBytes;
		}

		throw new Error('Unknown algorithm "' + alg + '"');
	}

	module.exports = getParamBytesForAlg;


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/*global module*/
	var Buffer = __webpack_require__(167).Buffer;

	module.exports = function toString(obj) {
	  if (typeof obj === 'string')
	    return obj;
	  if (typeof obj === 'number' || Buffer.isBuffer(obj))
	    return obj.toString();
	  return JSON.stringify(obj);
	};


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/*global module*/
	var base64url = __webpack_require__(165);
	var DataStream = __webpack_require__(166);
	var jwa = __webpack_require__(170);
	var Stream = __webpack_require__(168);
	var toString = __webpack_require__(176);
	var util = __webpack_require__(169);
	var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;

	function isObject(thing) {
	  return Object.prototype.toString.call(thing) === '[object Object]';
	}

	function safeJsonParse(thing) {
	  if (isObject(thing))
	    return thing;
	  try { return JSON.parse(thing); }
	  catch (e) { return undefined; }
	}

	function headerFromJWS(jwsSig) {
	  var encodedHeader = jwsSig.split('.', 1)[0];
	  return safeJsonParse(base64url.decode(encodedHeader, 'binary'));
	}

	function securedInputFromJWS(jwsSig) {
	  return jwsSig.split('.', 2).join('.');
	}

	function signatureFromJWS(jwsSig) {
	  return jwsSig.split('.')[2];
	}

	function payloadFromJWS(jwsSig, encoding) {
	  encoding = encoding || 'utf8';
	  var payload = jwsSig.split('.')[1];
	  return base64url.decode(payload, encoding);
	}

	function isValidJws(string) {
	  return JWS_REGEX.test(string) && !!headerFromJWS(string);
	}

	function jwsVerify(jwsSig, algorithm, secretOrKey) {
	  if (!algorithm) {
	    var err = new Error("Missing algorithm parameter for jws.verify");
	    err.code = "MISSING_ALGORITHM";
	    throw err;
	  }
	  jwsSig = toString(jwsSig);
	  var signature = signatureFromJWS(jwsSig);
	  var securedInput = securedInputFromJWS(jwsSig);
	  var algo = jwa(algorithm);
	  return algo.verify(securedInput, signature, secretOrKey);
	}

	function jwsDecode(jwsSig, opts) {
	  opts = opts || {};
	  jwsSig = toString(jwsSig);

	  if (!isValidJws(jwsSig))
	    return null;

	  var header = headerFromJWS(jwsSig);

	  if (!header)
	    return null;

	  var payload = payloadFromJWS(jwsSig);
	  if (header.typ === 'JWT' || opts.json)
	    payload = JSON.parse(payload, opts.encoding);

	  return {
	    header: header,
	    payload: payload,
	    signature: signatureFromJWS(jwsSig)
	  };
	}

	function VerifyStream(opts) {
	  opts = opts || {};
	  var secretOrKey = opts.secret||opts.publicKey||opts.key;
	  var secretStream = new DataStream(secretOrKey);
	  this.readable = true;
	  this.algorithm = opts.algorithm;
	  this.encoding = opts.encoding;
	  this.secret = this.publicKey = this.key = secretStream;
	  this.signature = new DataStream(opts.signature);
	  this.secret.once('close', function () {
	    if (!this.signature.writable && this.readable)
	      this.verify();
	  }.bind(this));

	  this.signature.once('close', function () {
	    if (!this.secret.writable && this.readable)
	      this.verify();
	  }.bind(this));
	}
	util.inherits(VerifyStream, Stream);
	VerifyStream.prototype.verify = function verify() {
	  try {
	    var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
	    var obj = jwsDecode(this.signature.buffer, this.encoding);
	    this.emit('done', valid, obj);
	    this.emit('data', valid);
	    this.emit('end');
	    this.readable = false;
	    return valid;
	  } catch (e) {
	    this.readable = false;
	    this.emit('error', e);
	    this.emit('close');
	  }
	};

	VerifyStream.decode = jwsDecode;
	VerifyStream.isValid = isValidJws;
	VerifyStream.verify = jwsVerify;

	module.exports = VerifyStream;


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	var JsonWebTokenError = __webpack_require__(179);
	var NotBeforeError    = __webpack_require__(180);
	var TokenExpiredError = __webpack_require__(181);
	var decode            = __webpack_require__(162);
	var jws               = __webpack_require__(163);
	var ms                = __webpack_require__(182);
	var xtend             = __webpack_require__(183);

	module.exports = function (jwtString, secretOrPublicKey, options, callback) {
	  if ((typeof options === 'function') && !callback) {
	    callback = options;
	    options = {};
	  }

	  if (!options) {
	    options = {};
	  }

	  //clone this object since we are going to mutate it.
	  options = xtend(options);
	  var done;

	  if (callback) {
	    done = function() {
	      var args = Array.prototype.slice.call(arguments, 0);
	      return process.nextTick(function() {
	        callback.apply(null, args);
	      });
	    };
	  } else {
	    done = function(err, data) {
	      if (err) throw err;
	      return data;
	    };
	  }

	  if (!jwtString){
	    return done(new JsonWebTokenError('jwt must be provided'));
	  }

	  var parts = jwtString.split('.');

	  if (parts.length !== 3){
	    return done(new JsonWebTokenError('jwt malformed'));
	  }

	  var hasSignature = parts[2].trim() !== '';

	  if (!hasSignature && secretOrPublicKey){
	    return done(new JsonWebTokenError('jwt signature is required'));
	  }

	  if (hasSignature && !secretOrPublicKey) {
	    return done(new JsonWebTokenError('secret or public key must be provided'));
	  }

	  if (!hasSignature && !options.algorithms) {
	    options.algorithms = ['none'];
	  }

	  if (!options.algorithms) {
	    options.algorithms = ~secretOrPublicKey.toString().indexOf('BEGIN CERTIFICATE') ||
	                         ~secretOrPublicKey.toString().indexOf('BEGIN PUBLIC KEY') ?
	                          [ 'RS256','RS384','RS512','ES256','ES384','ES512' ] :
	                         ~secretOrPublicKey.toString().indexOf('BEGIN RSA PUBLIC KEY') ?
	                          [ 'RS256','RS384','RS512' ] :
	                          [ 'HS256','HS384','HS512' ];

	  }

	  var decodedToken;
	  try {
	    decodedToken = jws.decode(jwtString);
	  } catch(err) {
	    return done(new JsonWebTokenError('invalid token'));
	  }

	  if (!decodedToken) {
	    return done(new JsonWebTokenError('invalid token'));
	  }

	  var header = decodedToken.header;

	  if (!~options.algorithms.indexOf(header.alg)) {
	    return done(new JsonWebTokenError('invalid algorithm'));
	  }

	  var valid;

	  try {
	    valid = jws.verify(jwtString, header.alg, secretOrPublicKey);
	  } catch (e) {
	    return done(e);
	  }

	  if (!valid)
	    return done(new JsonWebTokenError('invalid signature'));

	  var payload;

	  try {
	    payload = decode(jwtString);
	  } catch(err) {
	    return done(err);
	  }

	  if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {
	    if (typeof payload.nbf !== 'number') {
	      return done(new JsonWebTokenError('invalid nbf value'));
	    }
	    if (payload.nbf > Math.floor(Date.now() / 1000) + (options.clockTolerance || 0)) {
	      return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));
	    }
	  }

	  if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {
	    if (typeof payload.exp !== 'number') {
	      return done(new JsonWebTokenError('invalid exp value'));
	    }
	    if (Math.floor(Date.now() / 1000) >= payload.exp + (options.clockTolerance || 0)) {
	      return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));
	    }
	  }

	  if (options.audience) {
	    var audiences = Array.isArray(options.audience)? options.audience : [options.audience];
	    var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];

	    var match = target.some(function(aud) { return audiences.indexOf(aud) != -1; });

	    if (!match)
	      return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));
	  }

	  if (options.issuer) {
	    var invalid_issuer =
	        (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||
	        (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);

	    if (invalid_issuer) {
	      return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));
	    }
	  }

	  if (options.subject) {
	    if (payload.sub !== options.subject) {
	      return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));
	    }
	  }

	  if (options.jwtid) {
	    if (payload.jti !== options.jwtid) {
	      return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));
	    }
	  }

	  if (options.maxAge) {
	    var maxAge = ms(options.maxAge);
	    if (typeof payload.iat !== 'number') {
	      return done(new JsonWebTokenError('iat required when maxAge is specified'));
	    }
	    if (Date.now() - (payload.iat * 1000) > maxAge + (options.clockTolerance || 0) * 1000) {
	      return done(new TokenExpiredError('maxAge exceeded', new Date(payload.iat * 1000 + maxAge)));
	    }
	  }

	  return done(null, payload);
	};


/***/ },
/* 179 */
/***/ function(module, exports) {

	var JsonWebTokenError = function (message, error) {
	  Error.call(this, message);
	  Error.captureStackTrace(this, this.constructor);
	  this.name = 'JsonWebTokenError';
	  this.message = message;
	  if (error) this.inner = error;
	};

	JsonWebTokenError.prototype = Object.create(Error.prototype);
	JsonWebTokenError.prototype.constructor = JsonWebTokenError;

	module.exports = JsonWebTokenError;

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	var JsonWebTokenError = __webpack_require__(179);

	var NotBeforeError = function (message, date) {
	  JsonWebTokenError.call(this, message);
	  this.name = 'NotBeforeError';
	  this.date = date;
	};

	NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);

	NotBeforeError.prototype.constructor = NotBeforeError;

	module.exports = NotBeforeError;

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	var JsonWebTokenError = __webpack_require__(179);

	var TokenExpiredError = function (message, expiredAt) {
	  JsonWebTokenError.call(this, message);
	  this.name = 'TokenExpiredError';
	  this.expiredAt = expiredAt;
	};

	TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);

	TokenExpiredError.prototype.constructor = TokenExpiredError;

	module.exports = TokenExpiredError;

/***/ },
/* 182 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 183 */
/***/ function(module, exports) {

	module.exports = extend

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function extend() {
	    var target = {}

	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i]

	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key]
	            }
	        }
	    }

	    return target
	}


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var Joi = __webpack_require__(185);
	var timespan = __webpack_require__(316);
	var xtend = __webpack_require__(183);
	var jws = __webpack_require__(163);
	var once = __webpack_require__(317);

	var sign_options_schema = Joi.object().keys({
	  expiresIn: [Joi.number().integer(), Joi.string()],
	  notBefore: [Joi.number().integer(), Joi.string()],
	  audience: [Joi.string(), Joi.array()],
	  algorithm: Joi.string().valid('RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'HS256', 'HS384', 'HS512', 'none'),
	  header: Joi.object(),
	  encoding: Joi.string(),
	  issuer: Joi.string(),
	  subject: Joi.string(),
	  jwtid: Joi.string(),
	  noTimestamp: Joi.boolean()
	});

	var registered_claims_schema = Joi.object().keys({
	  iat: Joi.number(),
	  exp: Joi.number(),
	  nbf: Joi.number()
	}).unknown();


	var options_to_payload = {
	  'audience': 'aud',
	  'issuer': 'iss',
	  'subject': 'sub',
	  'jwtid': 'jti'
	};

	var options_for_objects = [
	  'expiresIn',
	  'notBefore',
	  'noTimestamp',
	  'audience',
	  'issuer',
	  'subject',
	  'jwtid',
	];

	module.exports = function (payload, secretOrPrivateKey, options, callback) {
	  options = options || {};

	  var isObjectPayload = typeof payload === 'object' &&
	                        !Buffer.isBuffer(payload);

	  var header = xtend({
	    alg: options.algorithm || 'HS256',
	    typ: isObjectPayload ? 'JWT' : undefined
	  }, options.header);

	  function failure(err) {
	    if (callback) {
	      return callback(err);
	    }
	    throw err;
	  }


	  if (typeof payload === 'undefined') {
	    return failure(new Error('payload is required'));
	  } else if (isObjectPayload) {
	    var payload_validation_result = registered_claims_schema.validate(payload);

	    if (payload_validation_result.error) {
	      return failure(payload_validation_result.error);
	    }

	    payload = xtend(payload);
	  } else {
	    var invalid_options = options_for_objects.filter(function (opt) {
	      return typeof options[opt] !== 'undefined';
	    });

	    if (invalid_options.length > 0) {
	      return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + (typeof payload ) + ' payload'));
	    }
	  }

	  if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') {
	    return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
	  }

	  if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') {
	    return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
	  }

	  var validation_result = sign_options_schema.validate(options);

	  if (validation_result.error) {
	    return failure(validation_result.error);
	  }

	  var timestamp = payload.iat || Math.floor(Date.now() / 1000);

	  if (!options.noTimestamp) {
	    payload.iat = timestamp;
	  } else {
	    delete payload.iat;
	  }

	  if (typeof options.notBefore !== 'undefined') {
	    payload.nbf = timespan(options.notBefore);
	    if (typeof payload.nbf === 'undefined') {
	      return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
	    }
	  }

	  if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') {
	    payload.exp = timespan(options.expiresIn, timestamp);
	    if (typeof payload.exp === 'undefined') {
	      return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
	    }
	  }

	  Object.keys(options_to_payload).forEach(function (key) {
	    var claim = options_to_payload[key];
	    if (typeof options[key] !== 'undefined') {
	      if (typeof payload[claim] !== 'undefined') {
	        return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
	      }
	      payload[claim] = options[key];
	    }
	  });

	  var encoding = options.encoding || 'utf8';

	  if (typeof callback === 'function') {
	    callback = callback && once(callback);

	    jws.createSign({
	      header: header,
	      privateKey: secretOrPrivateKey,
	      payload: payload,
	      encoding: encoding
	    }).once('error', callback)
	      .once('done', function (signature) {
	        callback(null, signature);
	      });
	  } else {
	    return jws.sign({header: header, payload: payload, secret: secretOrPrivateKey, encoding: encoding});
	  }
	};


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Any = __webpack_require__(186);
	var Cast = __webpack_require__(193);
	var Ref = __webpack_require__(190);


	// Declare internals

	var internals = {
	    alternatives: __webpack_require__(311),
	    array: __webpack_require__(314),
	    boolean: __webpack_require__(310),
	    binary: __webpack_require__(315),
	    date: __webpack_require__(194),
	    number: __webpack_require__(309),
	    object: __webpack_require__(312),
	    string: __webpack_require__(301)
	};


	internals.root = function () {

	    var any = new Any();

	    var root = any.clone();
	    root.any = function () {

	        return any;
	    };

	    root.alternatives = root.alt = function () {

	        return arguments.length ? internals.alternatives.try.apply(internals.alternatives, arguments) : internals.alternatives;
	    };

	    root.array = function () {

	        return internals.array;
	    };

	    root.boolean = root.bool = function () {

	        return internals.boolean;
	    };

	    root.binary = function () {

	        return internals.binary;
	    };

	    root.date = function () {

	        return internals.date;
	    };

	    root.func = function () {

	        return internals.object._func();
	    };

	    root.number = function () {

	        return internals.number;
	    };

	    root.object = function () {

	        return arguments.length ? internals.object.keys.apply(internals.object, arguments) : internals.object;
	    };

	    root.string = function () {

	        return internals.string;
	    };

	    root.ref = function () {

	        return Ref.create.apply(null, arguments);
	    };

	    root.isRef = function (ref) {

	        return Ref.isRef(ref);
	    };

	    root.validate = function (value /*, [schema], [options], callback */) {

	        var last = arguments[arguments.length - 1];
	        var callback = typeof last === 'function' ? last : null;

	        var count = arguments.length - (callback ? 1 : 0);
	        if (count === 1) {
	            return any.validate(value, callback);
	        }

	        var options = count === 3 ? arguments[2] : {};
	        var schema = root.compile(arguments[1]);

	        return schema._validateWithOptions(value, options, callback);
	    };

	    root.describe = function () {

	        var schema = arguments.length ? root.compile(arguments[0]) : any;
	        return schema.describe();
	    };

	    root.compile = function (schema) {

	        try {
	            return Cast.schema(schema);
	        }
	        catch (err) {
	            if (err.hasOwnProperty('path')) {
	                err.message += '(' + err.path + ')';
	            }
	            throw err;
	        }
	    };

	    root.assert = function (value, schema, message) {

	        root.attempt(value, schema, message);
	    };

	    root.attempt = function (value, schema, message) {

	        var result = root.validate(value, schema);
	        var error = result.error;
	        if (error) {
	            if (!message) {
	                error.message = error.annotate();
	                throw error;
	            }

	            if (!(message instanceof Error)) {
	                error.message = message + ' ' + error.annotate();
	                throw error;
	            }

	            throw message;
	        }

	        return result.value;
	    };

	    return root;
	};


	module.exports = internals.root();


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Hoek = __webpack_require__(187);
	var Ref = __webpack_require__(190);
	var Errors = __webpack_require__(191);
	var Alternatives = null;                // Delay-loaded to prevent circular dependencies
	var Cast = null;


	// Declare internals

	var internals = {};


	internals.defaults = {
	    abortEarly: true,
	    convert: true,
	    allowUnknown: false,
	    skipFunctions: false,
	    stripUnknown: false,
	    language: {},
	    presence: 'optional',
	    raw: false,
	    strip: false,
	    noDefaults: false

	    // context: null
	};


	internals.checkOptions = function (options) {

	    var optionType = {
	        abortEarly: 'boolean',
	        convert: 'boolean',
	        allowUnknown: 'boolean',
	        skipFunctions: 'boolean',
	        stripUnknown: 'boolean',
	        language: 'object',
	        presence: ['string', 'required', 'optional', 'forbidden', 'ignore'],
	        raw: 'boolean',
	        context: 'object',
	        strip: 'boolean',
	        noDefaults: 'boolean'
	    };

	    var keys = Object.keys(options);
	    for (var k = 0, kl = keys.length; k < kl; ++k) {
	        var key = keys[k];
	        var opt = optionType[key];
	        var type = opt;
	        var values = null;

	        if (Array.isArray(opt)) {
	            type = opt[0];
	            values = opt.slice(1);
	        }

	        Hoek.assert(type, 'unknown key ' + key);
	        Hoek.assert(typeof options[key] === type, key + ' should be of type ' + type);
	        if (values) {
	            Hoek.assert(values.indexOf(options[key]) >= 0, key + ' should be one of ' + values.join(', '));
	        }
	    }
	};


	module.exports = internals.Any = function () {

	    Cast = Cast || __webpack_require__(193);

	    this.isJoi = true;
	    this._type = 'any';
	    this._settings = null;
	    this._valids = new internals.Set();
	    this._invalids = new internals.Set();
	    this._tests = [];
	    this._refs = [];
	    this._flags = { /*
	        presence: 'optional',                   // optional, required, forbidden, ignore
	        allowOnly: false,
	        allowUnknown: undefined,
	        default: undefined,
	        forbidden: false,
	        encoding: undefined,
	        insensitive: false,
	        trim: false,
	        case: undefined,                        // upper, lower
	        empty: undefined,
	        func: false
	    */ };

	    this._description = null;
	    this._unit = null;
	    this._notes = [];
	    this._tags = [];
	    this._examples = [];
	    this._meta = [];

	    this._inner = {};                           // Hash of arrays of immutable objects
	};


	internals.Any.prototype.isImmutable = true;     // Prevents Hoek from deep cloning schema objects


	internals.Any.prototype.clone = function () {

	    var obj = Object.create(Object.getPrototypeOf(this));

	    obj.isJoi = true;
	    obj._type = this._type;
	    obj._settings = internals.concatSettings(this._settings);
	    obj._valids = Hoek.clone(this._valids);
	    obj._invalids = Hoek.clone(this._invalids);
	    obj._tests = this._tests.slice();
	    obj._refs = this._refs.slice();
	    obj._flags = Hoek.clone(this._flags);

	    obj._description = this._description;
	    obj._unit = this._unit;
	    obj._notes = this._notes.slice();
	    obj._tags = this._tags.slice();
	    obj._examples = this._examples.slice();
	    obj._meta = this._meta.slice();

	    obj._inner = {};
	    var inners = Object.keys(this._inner);
	    for (var i = 0, il = inners.length; i < il; ++i) {
	        var key = inners[i];
	        obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;
	    }

	    return obj;
	};


	internals.Any.prototype.concat = function (schema) {

	    Hoek.assert(schema && schema.isJoi, 'Invalid schema object');
	    Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);

	    var obj = this.clone();

	    if (this._type === 'any' && schema._type !== 'any') {

	        // Reset values as if we were "this"
	        var tmpObj = schema.clone();
	        var keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',
	            '_notes', '_tags', '_examples', '_meta', '_inner'];

	        for (var j = 0, jl = keysToRestore.length; j < jl; ++j) {
	            tmpObj[keysToRestore[j]] = obj[keysToRestore[j]];
	        }

	        obj = tmpObj;
	    }

	    obj._settings = obj._settings ? internals.concatSettings(obj._settings, schema._settings) : schema._settings;
	    obj._valids.merge(schema._valids, schema._invalids);
	    obj._invalids.merge(schema._invalids, schema._valids);
	    obj._tests = obj._tests.concat(schema._tests);
	    obj._refs = obj._refs.concat(schema._refs);
	    Hoek.merge(obj._flags, schema._flags);

	    obj._description = schema._description || obj._description;
	    obj._unit = schema._unit || obj._unit;
	    obj._notes = obj._notes.concat(schema._notes);
	    obj._tags = obj._tags.concat(schema._tags);
	    obj._examples = obj._examples.concat(schema._examples);
	    obj._meta = obj._meta.concat(schema._meta);

	    var inners = Object.keys(schema._inner);
	    var isObject = obj._type === 'object';
	    for (var i = 0, il = inners.length; i < il; ++i) {
	        var key = inners[i];
	        var source = schema._inner[key];
	        if (source) {
	            var target = obj._inner[key];
	            if (target) {
	                if (isObject && key === 'children') {
	                    var keys = {};

	                    for (var k = 0, kl = target.length; k < kl; ++k) {
	                        keys[target[k].key] = k;
	                    }

	                    for (k = 0, kl = source.length; k < kl; ++k) {
	                        var sourceKey = source[k].key;
	                        if (keys[sourceKey] >= 0) {
	                            target[keys[sourceKey]] = {
	                                key: sourceKey,
	                                schema: target[keys[sourceKey]].schema.concat(source[k].schema)
	                            };
	                        }
	                        else {
	                            target.push(source[k]);
	                        }
	                    }
	                }
	                else {
	                    obj._inner[key] = obj._inner[key].concat(source);
	                }
	            }
	            else {
	                obj._inner[key] = source.slice();
	            }
	        }
	    }

	    return obj;
	};


	internals.Any.prototype._test = function (name, arg, func) {

	    Hoek.assert(!this._flags.allowOnly, 'Cannot define rules when valid values specified');

	    var obj = this.clone();
	    obj._tests.push({ func: func, name: name, arg: arg });
	    return obj;
	};


	internals.Any.prototype.options = function (options) {

	    Hoek.assert(!options.context, 'Cannot override context');
	    internals.checkOptions(options);

	    var obj = this.clone();
	    obj._settings = internals.concatSettings(obj._settings, options);
	    return obj;
	};


	internals.Any.prototype.strict = function (isStrict) {

	    var obj = this.clone();
	    obj._settings = obj._settings || {};
	    obj._settings.convert = isStrict === undefined ? false : !isStrict;
	    return obj;
	};


	internals.Any.prototype.raw = function (isRaw) {

	    var obj = this.clone();
	    obj._settings = obj._settings || {};
	    obj._settings.raw = isRaw === undefined ? true : isRaw;
	    return obj;
	};


	internals.Any.prototype._allow = function () {

	    var values = Hoek.flatten(Array.prototype.slice.call(arguments));
	    for (var i = 0, il = values.length; i < il; ++i) {
	        var value = values[i];

	        Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');
	        this._invalids.remove(value);
	        this._valids.add(value, this._refs);
	    }
	};


	internals.Any.prototype.allow = function () {

	    var obj = this.clone();
	    obj._allow.apply(obj, arguments);
	    return obj;
	};


	internals.Any.prototype.valid = internals.Any.prototype.only = internals.Any.prototype.equal = function () {

	    Hoek.assert(!this._tests.length, 'Cannot set valid values when rules specified');

	    var obj = this.allow.apply(this, arguments);
	    obj._flags.allowOnly = true;
	    return obj;
	};


	internals.Any.prototype.invalid = internals.Any.prototype.disallow = internals.Any.prototype.not = function (value) {

	    var obj = this.clone();
	    var values = Hoek.flatten(Array.prototype.slice.call(arguments));
	    for (var i = 0, il = values.length; i < il; ++i) {
	        value = values[i];

	        Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');
	        obj._valids.remove(value);
	        obj._invalids.add(value, this._refs);
	    }

	    return obj;
	};


	internals.Any.prototype.required = internals.Any.prototype.exist = function () {

	    var obj = this.clone();
	    obj._flags.presence = 'required';
	    return obj;
	};


	internals.Any.prototype.optional = function () {

	    var obj = this.clone();
	    obj._flags.presence = 'optional';
	    return obj;
	};


	internals.Any.prototype.forbidden = function () {

	    var obj = this.clone();
	    obj._flags.presence = 'forbidden';
	    return obj;
	};


	internals.Any.prototype.strip = function () {

	    var obj = this.clone();
	    obj._flags.strip = true;
	    return obj;
	};


	internals.Any.prototype.applyFunctionToChildren = function (children, fn, args, root) {

	    children = [].concat(children);

	    if (children.length !== 1 || children[0] !== '') {
	        root = root ? (root + '.') : '';

	        var extraChildren = (children[0] === '' ? children.slice(1) : children).map(function (child) {

	            return root + child;
	        });

	        throw new Error('unknown key(s) ' + extraChildren.join(', '));
	    }

	    return this[fn].apply(this, args);
	};


	internals.Any.prototype.default = function (value, description) {

	    if (typeof value === 'function' &&
	        !Ref.isRef(value)) {

	        if (!value.description &&
	            description) {

	            value.description = description;
	        }

	        if (!this._flags.func) {
	            Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');
	        }
	    }

	    var obj = this.clone();
	    obj._flags.default = value;
	    Ref.push(obj._refs, value);
	    return obj;
	};


	internals.Any.prototype.empty = function (schema) {

	    var obj;
	    if (schema === undefined) {
	        obj = this.clone();
	        obj._flags.empty = undefined;
	    }
	    else {
	        schema = Cast.schema(schema);

	        obj = this.clone();
	        obj._flags.empty = schema;
	    }

	    return obj;
	};


	internals.Any.prototype.when = function (ref, options) {

	    Hoek.assert(options && typeof options === 'object', 'Invalid options');
	    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of "then" or "otherwise"');

	    var then = options.then ? this.concat(Cast.schema(options.then)) : this;
	    var otherwise = options.otherwise ? this.concat(Cast.schema(options.otherwise)) : this;

	    Alternatives = Alternatives || __webpack_require__(311);
	    var obj = Alternatives.when(ref, { is: options.is, then: then, otherwise: otherwise });
	    obj._flags.presence = 'ignore';
	    return obj;
	};


	internals.Any.prototype.description = function (desc) {

	    Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');

	    var obj = this.clone();
	    obj._description = desc;
	    return obj;
	};


	internals.Any.prototype.notes = function (notes) {

	    Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');

	    var obj = this.clone();
	    obj._notes = obj._notes.concat(notes);
	    return obj;
	};


	internals.Any.prototype.tags = function (tags) {

	    Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');

	    var obj = this.clone();
	    obj._tags = obj._tags.concat(tags);
	    return obj;
	};

	internals.Any.prototype.meta = function (meta) {

	    Hoek.assert(meta !== undefined, 'Meta cannot be undefined');

	    var obj = this.clone();
	    obj._meta = obj._meta.concat(meta);
	    return obj;
	};


	internals.Any.prototype.example = function (value) {

	    Hoek.assert(arguments.length, 'Missing example');
	    var result = this._validate(value, null, internals.defaults);
	    Hoek.assert(!result.errors, 'Bad example:', result.errors && Errors.process(result.errors, value));

	    var obj = this.clone();
	    obj._examples = obj._examples.concat(value);
	    return obj;
	};


	internals.Any.prototype.unit = function (name) {

	    Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');

	    var obj = this.clone();
	    obj._unit = name;
	    return obj;
	};


	internals._try = function (fn, arg) {

	    var err;
	    var result;

	    try {
	        result = fn.call(null, arg);
	    } catch (e) {
	        err = e;
	    }

	    return {
	        value: result,
	        error: err
	    };
	};


	internals.Any.prototype._validate = function (value, state, options, reference) {

	    var self = this;
	    var originalValue = value;

	    // Setup state and settings

	    state = state || { key: '', path: '', parent: null, reference: reference };

	    if (this._settings) {
	        options = internals.concatSettings(options, this._settings);
	    }

	    var errors = [];
	    var finish = function () {

	        var finalValue;

	        if (!self._flags.strip) {
	            if (value !== undefined) {
	                finalValue = options.raw ? originalValue : value;
	            }
	            else if (options.noDefaults) {
	                finalValue = originalValue;
	            }
	            else if (Ref.isRef(self._flags.default)) {
	                finalValue = self._flags.default(state.parent, options);
	            }
	            else if (typeof self._flags.default === 'function' &&
	                    !(self._flags.func && !self._flags.default.description)) {

	                var arg;

	                if (state.parent !== null &&
	                    self._flags.default.length > 0) {

	                    arg = Hoek.clone(state.parent);
	                }

	                var defaultValue = internals._try(self._flags.default, arg);
	                finalValue = defaultValue.value;
	                if (defaultValue.error) {
	                    errors.push(Errors.create('any.default', defaultValue.error, state, options));
	                }
	            }
	            else {
	                finalValue = Hoek.clone(self._flags.default);
	            }
	        }

	        return {
	            value: finalValue,
	            errors: errors.length ? errors : null
	        };
	    };

	    // Check presence requirements

	    var presence = this._flags.presence || options.presence;
	    if (presence === 'optional') {
	        if (value === undefined) {
	            var isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;
	            if (isDeepDefault && this._type === 'object') {
	                value = {};
	            }
	            else {
	                return finish();
	            }
	        }
	    }
	    else if (presence === 'required' &&
	            value === undefined) {

	        errors.push(Errors.create('any.required', null, state, options));
	        return finish();
	    }
	    else if (presence === 'forbidden') {
	        if (value === undefined) {
	            return finish();
	        }

	        errors.push(Errors.create('any.unknown', null, state, options));
	        return finish();
	    }

	    if (this._flags.empty && !this._flags.empty._validate(value, null, internals.defaults).errors) {
	        value = undefined;
	        return finish();
	    }

	    // Check allowed and denied values using the original value

	    if (this._valids.has(value, state, options, this._flags.insensitive)) {
	        return finish();
	    }

	    if (this._invalids.has(value, state, options, this._flags.insensitive)) {
	        errors.push(Errors.create(value === '' ? 'any.empty' : 'any.invalid', null, state, options));
	        if (options.abortEarly ||
	            value === undefined) {          // No reason to keep validating missing value

	            return finish();
	        }
	    }

	    // Convert value and validate type

	    if (this._base) {
	        var base = this._base.call(this, value, state, options);
	        if (base.errors) {
	            value = base.value;
	            errors = errors.concat(base.errors);
	            return finish();                            // Base error always aborts early
	        }

	        if (base.value !== value) {
	            value = base.value;

	            // Check allowed and denied values using the converted value

	            if (this._valids.has(value, state, options, this._flags.insensitive)) {
	                return finish();
	            }

	            if (this._invalids.has(value, state, options, this._flags.insensitive)) {
	                errors.push(Errors.create('any.invalid', null, state, options));
	                if (options.abortEarly) {
	                    return finish();
	                }
	            }
	        }
	    }

	    // Required values did not match

	    if (this._flags.allowOnly) {
	        errors.push(Errors.create('any.allowOnly', { valids: this._valids.values({ stripUndefined: true }) }, state, options));
	        if (options.abortEarly) {
	            return finish();
	        }
	    }

	    // Helper.validate tests

	    for (var i = 0, il = this._tests.length; i < il; ++i) {
	        var test = this._tests[i];
	        var err = test.func.call(this, value, state, options);
	        if (err) {
	            errors.push(err);
	            if (options.abortEarly) {
	                return finish();
	            }
	        }
	    }

	    return finish();
	};


	internals.Any.prototype._validateWithOptions = function (value, options, callback) {

	    if (options) {
	        internals.checkOptions(options);
	    }

	    var settings = internals.concatSettings(internals.defaults, options);
	    var result = this._validate(value, null, settings);
	    var errors = Errors.process(result.errors, value);

	    if (callback) {
	        return callback(errors, result.value);
	    }

	    return { error: errors, value: result.value };
	};


	internals.Any.prototype.validate = function (value, callback) {

	    var result = this._validate(value, null, internals.defaults);
	    var errors = Errors.process(result.errors, value);

	    if (callback) {
	        return callback(errors, result.value);
	    }

	    return { error: errors, value: result.value };
	};


	internals.Any.prototype.describe = function () {

	    var description = {
	        type: this._type
	    };

	    var flags = Object.keys(this._flags);
	    if (flags.length) {
	        if (this._flags.empty) {
	            description.flags = {};
	            for (var f = 0, fl = flags.length; f < fl; ++f) {
	                var flag = flags[f];
	                description.flags[flag] = flag === 'empty' ? this._flags[flag].describe() : this._flags[flag];
	            }
	        }
	        else {
	            description.flags = this._flags;
	        }
	    }

	    if (this._description) {
	        description.description = this._description;
	    }

	    if (this._notes.length) {
	        description.notes = this._notes;
	    }

	    if (this._tags.length) {
	        description.tags = this._tags;
	    }

	    if (this._meta.length) {
	        description.meta = this._meta;
	    }

	    if (this._examples.length) {
	        description.examples = this._examples;
	    }

	    if (this._unit) {
	        description.unit = this._unit;
	    }

	    var valids = this._valids.values();
	    if (valids.length) {
	        description.valids = valids;
	    }

	    var invalids = this._invalids.values();
	    if (invalids.length) {
	        description.invalids = invalids;
	    }

	    description.rules = [];

	    for (var i = 0, il = this._tests.length; i < il; ++i) {
	        var validator = this._tests[i];
	        var item = { name: validator.name };
	        if (validator.arg !== void 0) {
	            item.arg = validator.arg;
	        }
	        description.rules.push(item);
	    }

	    if (!description.rules.length) {
	        delete description.rules;
	    }

	    var label = Hoek.reach(this._settings, 'language.label');
	    if (label) {
	        description.label = label;
	    }

	    return description;
	};

	internals.Any.prototype.label = function (name) {

	    Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');

	    var obj = this.clone();
	    var options = { language: { label: name } };

	    // If language.label is set, it should override this label
	    obj._settings = internals.concatSettings(options, obj._settings);
	    return obj;
	};


	// Set

	internals.Set = function () {

	    this._set = [];
	};


	internals.Set.prototype.add = function (value, refs) {

	    Hoek.assert(value === null || value === undefined || value instanceof Date || Buffer.isBuffer(value) || Ref.isRef(value) || (typeof value !== 'function' && typeof value !== 'object'), 'Value cannot be an object or function');

	    if (typeof value !== 'function' &&
	        this.has(value, null, null, false)) {

	        return;
	    }

	    Ref.push(refs, value);
	    this._set.push(value);
	};


	internals.Set.prototype.merge = function (add, remove) {

	    for (var i = 0, il = add._set.length; i < il; ++i) {
	        this.add(add._set[i]);
	    }

	    for (i = 0, il = remove._set.length; i < il; ++i) {
	        this.remove(remove._set[i]);
	    }
	};


	internals.Set.prototype.remove = function (value) {

	    this._set = this._set.filter(function (item) {

	        return value !== item;
	    });
	};


	internals.Set.prototype.has = function (value, state, options, insensitive) {

	    for (var i = 0, il = this._set.length; i < il; ++i) {
	        var items = this._set[i];

	        if (Ref.isRef(items)) {
	            items = items(state.reference || state.parent, options);
	        }

	        if (!Array.isArray(items)) {
	            items = [items];
	        }

	        for (var j = 0, jl = items.length; j < jl; ++j) {
	            var item = items[j];
	            if (typeof value !== typeof item) {
	                continue;
	            }

	            if (value === item ||
	                (value instanceof Date && item instanceof Date && value.getTime() === item.getTime()) ||
	                (insensitive && typeof value === 'string' && value.toLowerCase() === item.toLowerCase()) ||
	                (Buffer.isBuffer(value) && Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary'))) {

	                return true;
	            }
	        }
	    }

	    return false;
	};


	internals.Set.prototype.values = function (options) {

	    if (options && options.stripUndefined) {
	        var values = [];

	        for (var i = 0, il = this._set.length; i < il; ++i) {
	            var item = this._set[i];
	            if (item !== undefined) {
	                values.push(item);
	            }
	        }

	        return values;
	    }

	    return this._set.slice();
	};


	internals.concatSettings = function (target, source) {

	    // Used to avoid cloning context

	    if (!target &&
	        !source) {

	        return null;
	    }

	    var key, obj = {};

	    if (target) {
	        var tKeys = Object.keys(target);
	        for (var i = 0, il = tKeys.length; i < il; ++i) {
	            key = tKeys[i];
	            obj[key] = target[key];
	        }
	    }

	    if (source) {
	        var sKeys = Object.keys(source);
	        for (var j = 0, jl = sKeys.length; j < jl; ++j) {
	            key = sKeys[j];
	            if (key !== 'language' ||
	                !obj.hasOwnProperty(key)) {

	                obj[key] = source[key];
	            }
	            else {
	                obj[key] = Hoek.applyToDefaults(obj[key], source[key]);
	            }
	        }
	    }

	    return obj;
	};


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Crypto = __webpack_require__(172);
	var Path = __webpack_require__(188);
	var Util = __webpack_require__(169);
	var Escape = __webpack_require__(189);


	// Declare internals

	var internals = {};


	// Clone object or array

	exports.clone = function (obj, seen) {

	    if (typeof obj !== 'object' ||
	        obj === null) {

	        return obj;
	    }

	    seen = seen || { orig: [], copy: [] };

	    var lookup = seen.orig.indexOf(obj);
	    if (lookup !== -1) {
	        return seen.copy[lookup];
	    }

	    var newObj;
	    var cloneDeep = false;

	    if (!Array.isArray(obj)) {
	        if (Buffer.isBuffer(obj)) {
	            newObj = new Buffer(obj);
	        }
	        else if (obj instanceof Date) {
	            newObj = new Date(obj.getTime());
	        }
	        else if (obj instanceof RegExp) {
	            newObj = new RegExp(obj);
	        }
	        else {
	            var proto = Object.getPrototypeOf(obj);
	            if (proto &&
	                proto.isImmutable) {

	                newObj = obj;
	            }
	            else {
	                newObj = Object.create(proto);
	                cloneDeep = true;
	            }
	        }
	    }
	    else {
	        newObj = [];
	        cloneDeep = true;
	    }

	    seen.orig.push(obj);
	    seen.copy.push(newObj);

	    if (cloneDeep) {
	        var keys = Object.getOwnPropertyNames(obj);
	        for (var i = 0, il = keys.length; i < il; ++i) {
	            var key = keys[i];
	            var descriptor = Object.getOwnPropertyDescriptor(obj, key);
	            if (descriptor &&
	                (descriptor.get ||
	                 descriptor.set)) {

	                Object.defineProperty(newObj, key, descriptor);
	            }
	            else {
	                newObj[key] = exports.clone(obj[key], seen);
	            }
	        }
	    }

	    return newObj;
	};


	// Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied
	/*eslint-disable */
	exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {
	/*eslint-enable */
	    exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');
	    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

	    if (!source) {
	        return target;
	    }

	    if (Array.isArray(source)) {
	        exports.assert(Array.isArray(target), 'Cannot merge array onto an object');
	        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true
	            target.length = 0;                                                          // Must not change target assignment
	        }

	        for (var i = 0, il = source.length; i < il; ++i) {
	            target.push(exports.clone(source[i]));
	        }

	        return target;
	    }

	    var keys = Object.keys(source);
	    for (var k = 0, kl = keys.length; k < kl; ++k) {
	        var key = keys[k];
	        var value = source[key];
	        if (value &&
	            typeof value === 'object') {

	            if (!target[key] ||
	                typeof target[key] !== 'object' ||
	                (Array.isArray(target[key]) ^ Array.isArray(value)) ||
	                value instanceof Date ||
	                Buffer.isBuffer(value) ||
	                value instanceof RegExp) {

	                target[key] = exports.clone(value);
	            }
	            else {
	                exports.merge(target[key], value, isNullOverride, isMergeArrays);
	            }
	        }
	        else {
	            if (value !== null &&
	                value !== undefined) {                              // Explicit to preserve empty strings

	                target[key] = value;
	            }
	            else if (isNullOverride !== false) {                    // Defaults to true
	                target[key] = value;
	            }
	        }
	    }

	    return target;
	};


	// Apply options to a copy of the defaults

	exports.applyToDefaults = function (defaults, options, isNullOverride) {

	    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
	    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');

	    if (!options) {                                                 // If no options, return null
	        return null;
	    }

	    var copy = exports.clone(defaults);

	    if (options === true) {                                         // If options is set to true, use defaults
	        return copy;
	    }

	    return exports.merge(copy, options, isNullOverride === true, false);
	};


	// Clone an object except for the listed keys which are shallow copied

	exports.cloneWithShallow = function (source, keys) {

	    if (!source ||
	        typeof source !== 'object') {

	        return source;
	    }

	    var storage = internals.store(source, keys);    // Move shallow copy items to storage
	    var copy = exports.clone(source);               // Deep copy the rest
	    internals.restore(copy, source, storage);       // Shallow copy the stored items and restore
	    return copy;
	};


	internals.store = function (source, keys) {

	    var storage = {};
	    for (var i = 0, il = keys.length; i < il; ++i) {
	        var key = keys[i];
	        var value = exports.reach(source, key);
	        if (value !== undefined) {
	            storage[key] = value;
	            internals.reachSet(source, key, undefined);
	        }
	    }

	    return storage;
	};


	internals.restore = function (copy, source, storage) {

	    var keys = Object.keys(storage);
	    for (var i = 0, il = keys.length; i < il; ++i) {
	        var key = keys[i];
	        internals.reachSet(copy, key, storage[key]);
	        internals.reachSet(source, key, storage[key]);
	    }
	};


	internals.reachSet = function (obj, key, value) {

	    var path = key.split('.');
	    var ref = obj;
	    for (var i = 0, il = path.length; i < il; ++i) {
	        var segment = path[i];
	        if (i + 1 === il) {
	            ref[segment] = value;
	        }

	        ref = ref[segment];
	    }
	};


	// Apply options to defaults except for the listed keys which are shallow copied from option without merging

	exports.applyToDefaultsWithShallow = function (defaults, options, keys) {

	    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
	    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');
	    exports.assert(keys && Array.isArray(keys), 'Invalid keys');

	    if (!options) {                                                 // If no options, return null
	        return null;
	    }

	    var copy = exports.cloneWithShallow(defaults, keys);

	    if (options === true) {                                         // If options is set to true, use defaults
	        return copy;
	    }

	    var storage = internals.store(options, keys);   // Move shallow copy items to storage
	    exports.merge(copy, options, false, false);     // Deep copy the rest
	    internals.restore(copy, options, storage);      // Shallow copy the stored items and restore
	    return copy;
	};


	// Deep object or array comparison

	exports.deepEqual = function (obj, ref, options, seen) {

	    options = options || { prototype: true };

	    var type = typeof obj;

	    if (type !== typeof ref) {
	        return false;
	    }

	    if (type !== 'object' ||
	        obj === null ||
	        ref === null) {

	        if (obj === ref) {                                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql
	            return obj !== 0 || 1 / obj === 1 / ref;        // -0 / +0
	        }

	        return obj !== obj && ref !== ref;                  // NaN
	    }

	    seen = seen || [];
	    if (seen.indexOf(obj) !== -1) {
	        return true;                            // If previous comparison failed, it would have stopped execution
	    }

	    seen.push(obj);

	    if (Array.isArray(obj)) {
	        if (!Array.isArray(ref)) {
	            return false;
	        }

	        if (!options.part && obj.length !== ref.length) {
	            return false;
	        }

	        for (var i = 0, il = obj.length; i < il; ++i) {
	            if (options.part) {
	                var found = false;
	                for (var r = 0, rl = ref.length; r < rl; ++r) {
	                    if (exports.deepEqual(obj[i], ref[r], options, seen)) {
	                        found = true;
	                        break;
	                    }
	                }

	                return found;
	            }

	            if (!exports.deepEqual(obj[i], ref[i], options, seen)) {
	                return false;
	            }
	        }

	        return true;
	    }

	    if (Buffer.isBuffer(obj)) {
	        if (!Buffer.isBuffer(ref)) {
	            return false;
	        }

	        if (obj.length !== ref.length) {
	            return false;
	        }

	        for (var j = 0, jl = obj.length; j < jl; ++j) {
	            if (obj[j] !== ref[j]) {
	                return false;
	            }
	        }

	        return true;
	    }

	    if (obj instanceof Date) {
	        return (ref instanceof Date && obj.getTime() === ref.getTime());
	    }

	    if (obj instanceof RegExp) {
	        return (ref instanceof RegExp && obj.toString() === ref.toString());
	    }

	    if (options.prototype) {
	        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
	            return false;
	        }
	    }

	    var keys = Object.getOwnPropertyNames(obj);

	    if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {
	        return false;
	    }

	    for (var k = 0, kl = keys.length; k < kl; ++k) {
	        var key = keys[k];
	        var descriptor = Object.getOwnPropertyDescriptor(obj, key);
	        if (descriptor.get) {
	            if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {
	                return false;
	            }
	        }
	        else if (!exports.deepEqual(obj[key], ref[key], options, seen)) {
	            return false;
	        }
	    }

	    return true;
	};


	// Remove duplicate items from array

	exports.unique = function (array, key) {

	    var index = {};
	    var result = [];

	    for (var i = 0, il = array.length; i < il; ++i) {
	        var id = (key ? array[i][key] : array[i]);
	        if (index[id] !== true) {

	            result.push(array[i]);
	            index[id] = true;
	        }
	    }

	    return result;
	};


	// Convert array into object

	exports.mapToObject = function (array, key) {

	    if (!array) {
	        return null;
	    }

	    var obj = {};
	    for (var i = 0, il = array.length; i < il; ++i) {
	        if (key) {
	            if (array[i][key]) {
	                obj[array[i][key]] = true;
	            }
	        }
	        else {
	            obj[array[i]] = true;
	        }
	    }

	    return obj;
	};


	// Find the common unique items in two arrays

	exports.intersect = function (array1, array2, justFirst) {

	    if (!array1 || !array2) {
	        return [];
	    }

	    var common = [];
	    var hash = (Array.isArray(array1) ? exports.mapToObject(array1) : array1);
	    var found = {};
	    for (var i = 0, il = array2.length; i < il; ++i) {
	        if (hash[array2[i]] && !found[array2[i]]) {
	            if (justFirst) {
	                return array2[i];
	            }

	            common.push(array2[i]);
	            found[array2[i]] = true;
	        }
	    }

	    return (justFirst ? null : common);
	};


	// Test if the reference contains the values

	exports.contain = function (ref, values, options) {

	    /*
	        string -> string(s)
	        array -> item(s)
	        object -> key(s)
	        object -> object (key:value)
	    */

	    var valuePairs = null;
	    if (typeof ref === 'object' &&
	        typeof values === 'object' &&
	        !Array.isArray(ref) &&
	        !Array.isArray(values)) {

	        valuePairs = values;
	        values = Object.keys(values);
	    }
	    else {
	        values = [].concat(values);
	    }

	    options = options || {};            // deep, once, only, part

	    exports.assert(arguments.length >= 2, 'Insufficient arguments');
	    exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');
	    exports.assert(values.length, 'Values array cannot be empty');

	    var compare, compareFlags;
	    if (options.deep) {
	        compare = exports.deepEqual;

	        var hasOnly = options.hasOwnProperty('only'), hasPart = options.hasOwnProperty('part');

	        compareFlags = {
	            prototype: hasOnly ? options.only : hasPart ? !options.part : false,
	            part: hasOnly ? !options.only : hasPart ? options.part : true
	        };
	    }
	    else {
	        compare = function (a, b) {

	            return a === b;
	        };
	    }

	    var misses = false;
	    var matches = new Array(values.length);
	    for (var i = 0, il = matches.length; i < il; ++i) {
	        matches[i] = 0;
	    }

	    if (typeof ref === 'string') {
	        var pattern = '(';
	        for (i = 0, il = values.length; i < il; ++i) {
	            var value = values[i];
	            exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');
	            pattern += (i ? '|' : '') + exports.escapeRegex(value);
	        }

	        var regex = new RegExp(pattern + ')', 'g');
	        var leftovers = ref.replace(regex, function ($0, $1) {

	            var index = values.indexOf($1);
	            ++matches[index];
	            return '';          // Remove from string
	        });

	        misses = !!leftovers;
	    }
	    else if (Array.isArray(ref)) {
	        for (i = 0, il = ref.length; i < il; ++i) {
	            for (var j = 0, jl = values.length, matched = false; j < jl && matched === false; ++j) {
	                matched = compare(values[j], ref[i], compareFlags) && j;
	            }

	            if (matched !== false) {
	                ++matches[matched];
	            }
	            else {
	                misses = true;
	            }
	        }
	    }
	    else {
	        var keys = Object.keys(ref);
	        for (i = 0, il = keys.length; i < il; ++i) {
	            var key = keys[i];
	            var pos = values.indexOf(key);
	            if (pos !== -1) {
	                if (valuePairs &&
	                    !compare(valuePairs[key], ref[key], compareFlags)) {

	                    return false;
	                }

	                ++matches[pos];
	            }
	            else {
	                misses = true;
	            }
	        }
	    }

	    var result = false;
	    for (i = 0, il = matches.length; i < il; ++i) {
	        result = result || !!matches[i];
	        if ((options.once && matches[i] > 1) ||
	            (!options.part && !matches[i])) {

	            return false;
	        }
	    }

	    if (options.only &&
	        misses) {

	        return false;
	    }

	    return result;
	};


	// Flatten array

	exports.flatten = function (array, target) {

	    var result = target || [];

	    for (var i = 0, il = array.length; i < il; ++i) {
	        if (Array.isArray(array[i])) {
	            exports.flatten(array[i], result);
	        }
	        else {
	            result.push(array[i]);
	        }
	    }

	    return result;
	};


	// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])

	exports.reach = function (obj, chain, options) {

	    if (chain === false ||
	        chain === null ||
	        typeof chain === 'undefined') {

	        return obj;
	    }

	    options = options || {};
	    if (typeof options === 'string') {
	        options = { separator: options };
	    }

	    var path = chain.split(options.separator || '.');
	    var ref = obj;
	    for (var i = 0, il = path.length; i < il; ++i) {
	        var key = path[i];
	        if (key[0] === '-' && Array.isArray(ref)) {
	            key = key.slice(1, key.length);
	            key = ref.length - key;
	        }

	        if (!ref ||
	            !ref.hasOwnProperty(key) ||
	            (typeof ref !== 'object' && options.functions === false)) {         // Only object and function can have properties

	            exports.assert(!options.strict || i + 1 === il, 'Missing segment', key, 'in reach path ', chain);
	            exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);
	            ref = options.default;
	            break;
	        }

	        ref = ref[key];
	    }

	    return ref;
	};


	exports.reachTemplate = function (obj, template, options) {

	    return template.replace(/{([^}]+)}/g, function ($0, chain) {

	        var value = exports.reach(obj, chain, options);
	        return (value === undefined || value === null ? '' : value);
	    });
	};


	exports.formatStack = function (stack) {

	    var trace = [];
	    for (var i = 0, il = stack.length; i < il; ++i) {
	        var item = stack[i];
	        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
	    }

	    return trace;
	};


	exports.formatTrace = function (trace) {

	    var display = [];

	    for (var i = 0, il = trace.length; i < il; ++i) {
	        var row = trace[i];
	        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
	    }

	    return display;
	};


	exports.callStack = function (slice) {

	    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi

	    var v8 = Error.prepareStackTrace;
	    Error.prepareStackTrace = function (err, stack) {

	        return stack;
	    };

	    var capture = {};
	    Error.captureStackTrace(capture, arguments.callee);     /*eslint no-caller:0 */
	    var stack = capture.stack;

	    Error.prepareStackTrace = v8;

	    var trace = exports.formatStack(stack);

	    if (slice) {
	        return trace.slice(slice);
	    }

	    return trace;
	};


	exports.displayStack = function (slice) {

	    var trace = exports.callStack(slice === undefined ? 1 : slice + 1);

	    return exports.formatTrace(trace);
	};


	exports.abortThrow = false;


	exports.abort = function (message, hideStack) {

	    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {
	        throw new Error(message || 'Unknown error');
	    }

	    var stack = '';
	    if (!hideStack) {
	        stack = exports.displayStack(1).join('\n\t');
	    }
	    console.log('ABORT: ' + message + '\n\t' + stack);
	    process.exit(1);
	};


	exports.assert = function (condition /*, msg1, msg2, msg3 */) {

	    if (condition) {
	        return;
	    }

	    if (arguments.length === 2 && arguments[1] instanceof Error) {
	        throw arguments[1];
	    }

	    var msgs = [];
	    for (var i = 1, il = arguments.length; i < il; ++i) {
	        if (arguments[i] !== '') {
	            msgs.push(arguments[i]);            // Avoids Array.slice arguments leak, allowing for V8 optimizations
	        }
	    }

	    msgs = msgs.map(function (msg) {

	        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : exports.stringify(msg);
	    });
	    throw new Error(msgs.join(' ') || 'Unknown error');
	};


	exports.Timer = function () {

	    this.ts = 0;
	    this.reset();
	};


	exports.Timer.prototype.reset = function () {

	    this.ts = Date.now();
	};


	exports.Timer.prototype.elapsed = function () {

	    return Date.now() - this.ts;
	};


	exports.Bench = function () {

	    this.ts = 0;
	    this.reset();
	};


	exports.Bench.prototype.reset = function () {

	    this.ts = exports.Bench.now();
	};


	exports.Bench.prototype.elapsed = function () {

	    return exports.Bench.now() - this.ts;
	};


	exports.Bench.now = function () {

	    var ts = process.hrtime();
	    return (ts[0] * 1e3) + (ts[1] / 1e6);
	};


	// Escape string for Regex construction

	exports.escapeRegex = function (string) {

	    // Escape ^$.*+-?=!:|\/()[]{},
	    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
	};


	// Base64url (RFC 4648) encode

	exports.base64urlEncode = function (value, encoding) {

	    var buf = (Buffer.isBuffer(value) ? value : new Buffer(value, encoding || 'binary'));
	    return buf.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
	};


	// Base64url (RFC 4648) decode

	exports.base64urlDecode = function (value, encoding) {

	    if (value &&
	        !/^[\w\-]*$/.test(value)) {

	        return new Error('Invalid character');
	    }

	    try {
	        var buf = new Buffer(value, 'base64');
	        return (encoding === 'buffer' ? buf : buf.toString(encoding || 'binary'));
	    }
	    catch (err) {
	        return err;
	    }
	};


	// Escape attribute value for use in HTTP header

	exports.escapeHeaderAttribute = function (attribute) {

	    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

	    exports.assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');

	    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
	};


	exports.escapeHtml = function (string) {

	    return Escape.escapeHtml(string);
	};


	exports.escapeJavaScript = function (string) {

	    return Escape.escapeJavaScript(string);
	};


	exports.nextTick = function (callback) {

	    return function () {

	        var args = arguments;
	        process.nextTick(function () {

	            callback.apply(null, args);
	        });
	    };
	};


	exports.once = function (method) {

	    if (method._hoekOnce) {
	        return method;
	    }

	    var once = false;
	    var wrapped = function () {

	        if (!once) {
	            once = true;
	            method.apply(null, arguments);
	        }
	    };

	    wrapped._hoekOnce = true;

	    return wrapped;
	};


	exports.isAbsolutePath = function (path, platform) {

	    if (!path) {
	        return false;
	    }

	    if (Path.isAbsolute) {                      // node >= 0.11
	        return Path.isAbsolute(path);
	    }

	    platform = platform || process.platform;

	    // Unix

	    if (platform !== 'win32') {
	        return path[0] === '/';
	    }

	    // Windows

	    return !!/^(?:[a-zA-Z]:[\\\/])|(?:[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/])/.test(path);        // C:\ or \\something\something
	};


	exports.isInteger = function (value) {

	    return (typeof value === 'number' &&
	            parseFloat(value) === parseInt(value, 10) &&
	            !isNaN(value));
	};


	exports.ignore = function () { };


	exports.inherits = Util.inherits;


	exports.format = Util.format;


	exports.transform = function (source, transform, options) {

	    exports.assert(source === null || source === undefined || typeof source === 'object' || Array.isArray(source), 'Invalid source object: must be null, undefined, an object, or an array');

	    if (Array.isArray(source)) {
	        var results = [];
	        for (var i = 0, il = source.length; i < il; ++i) {
	            results.push(exports.transform(source[i], transform, options));
	        }
	        return results;
	    }

	    var result = {};
	    var keys = Object.keys(transform);

	    for (var k = 0, kl = keys.length; k < kl; ++k) {
	        var key = keys[k];
	        var path = key.split('.');
	        var sourcePath = transform[key];

	        exports.assert(typeof sourcePath === 'string', 'All mappings must be "." delineated strings');

	        var segment;
	        var res = result;

	        while (path.length > 1) {
	            segment = path.shift();
	            if (!res[segment]) {
	                res[segment] = {};
	            }
	            res = res[segment];
	        }
	        segment = path.shift();
	        res[segment] = exports.reach(source, sourcePath, options);
	    }

	    return result;
	};


	exports.uniqueFilename = function (path, extension) {

	    if (extension) {
	        extension = extension[0] !== '.' ? '.' + extension : extension;
	    }
	    else {
	        extension = '';
	    }

	    path = Path.resolve(path);
	    var name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;
	    return Path.join(path, name);
	};


	exports.stringify = function () {

	    try {
	        return JSON.stringify.apply(null, arguments);
	    }
	    catch (err) {
	        return '[Cannot display object: ' + err.message + ']';
	    }
	};


	exports.shallow = function (source) {

	    var target = {};
	    var keys = Object.keys(source);
	    for (var i = 0, il = keys.length; i < il; ++i) {
	        var key = keys[i];
	        target[key] = source[key];
	    }

	    return target;
	};


/***/ },
/* 188 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 189 */
/***/ function(module, exports) {

	// Declare internals

	var internals = {};


	exports.escapeJavaScript = function (input) {

	    if (!input) {
	        return '';
	    }

	    var escaped = '';

	    for (var i = 0, il = input.length; i < il; ++i) {

	        var charCode = input.charCodeAt(i);

	        if (internals.isSafe(charCode)) {
	            escaped += input[i];
	        }
	        else {
	            escaped += internals.escapeJavaScriptChar(charCode);
	        }
	    }

	    return escaped;
	};


	exports.escapeHtml = function (input) {

	    if (!input) {
	        return '';
	    }

	    var escaped = '';

	    for (var i = 0, il = input.length; i < il; ++i) {

	        var charCode = input.charCodeAt(i);

	        if (internals.isSafe(charCode)) {
	            escaped += input[i];
	        }
	        else {
	            escaped += internals.escapeHtmlChar(charCode);
	        }
	    }

	    return escaped;
	};


	internals.escapeJavaScriptChar = function (charCode) {

	    if (charCode >= 256) {
	        return '\\u' + internals.padLeft('' + charCode, 4);
	    }

	    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
	    return '\\x' + internals.padLeft(hexValue, 2);
	};


	internals.escapeHtmlChar = function (charCode) {

	    var namedEscape = internals.namedHtml[charCode];
	    if (typeof namedEscape !== 'undefined') {
	        return namedEscape;
	    }

	    if (charCode >= 256) {
	        return '&#' + charCode + ';';
	    }

	    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
	    return '&#x' + internals.padLeft(hexValue, 2) + ';';
	};


	internals.padLeft = function (str, len) {

	    while (str.length < len) {
	        str = '0' + str;
	    }

	    return str;
	};


	internals.isSafe = function (charCode) {

	    return (typeof internals.safeCharCodes[charCode] !== 'undefined');
	};


	internals.namedHtml = {
	    '38': '&amp;',
	    '60': '&lt;',
	    '62': '&gt;',
	    '34': '&quot;',
	    '160': '&nbsp;',
	    '162': '&cent;',
	    '163': '&pound;',
	    '164': '&curren;',
	    '169': '&copy;',
	    '174': '&reg;'
	};


	internals.safeCharCodes = (function () {

	    var safe = {};

	    for (var i = 32; i < 123; ++i) {

	        if ((i >= 97) ||                    // a-z
	            (i >= 65 && i <= 90) ||         // A-Z
	            (i >= 48 && i <= 57) ||         // 0-9
	            i === 32 ||                     // space
	            i === 46 ||                     // .
	            i === 44 ||                     // ,
	            i === 45 ||                     // -
	            i === 58 ||                     // :
	            i === 95) {                     // _

	            safe[i] = null;
	        }
	    }

	    return safe;
	}());


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Hoek = __webpack_require__(187);


	// Declare internals

	var internals = {};


	exports.create = function (key, options) {

	    Hoek.assert(typeof key === 'string', 'Invalid reference key:', key);

	    var settings = Hoek.clone(options);         // options can be reused and modified

	    var ref = function (value, validationOptions) {

	        return Hoek.reach(ref.isContext ? validationOptions.context : value, ref.key, settings);
	    };

	    ref.isContext = (key[0] === ((settings && settings.contextPrefix) || '$'));
	    ref.key = (ref.isContext ? key.slice(1) : key);
	    ref.path = ref.key.split((settings && settings.separator) || '.');
	    ref.depth = ref.path.length;
	    ref.root = ref.path[0];
	    ref.isJoi = true;

	    ref.toString = function () {

	        return (ref.isContext ? 'context:' : 'ref:') + ref.key;
	    };

	    return ref;
	};


	exports.isRef = function (ref) {

	    return typeof ref === 'function' && ref.isJoi;
	};


	exports.push = function (array, ref) {

	    if (exports.isRef(ref) &&
	        !ref.isContext) {

	        array.push(ref.root);
	    }
	};


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Hoek = __webpack_require__(187);
	var Language = __webpack_require__(192);


	// Declare internals

	var internals = {};

	internals.stringify = function (value, wrapArrays) {

	    var type = typeof value;

	    if (value === null) {
	        return 'null';
	    }

	    if (type === 'string') {
	        return value;
	    }

	    if (value instanceof internals.Err || type === 'function') {
	        return value.toString();
	    }

	    if (type === 'object') {
	        if (Array.isArray(value)) {
	            var partial = '';

	            for (var i = 0, il = value.length; i < il; ++i) {
	                partial += (partial.length ? ', ' : '') + internals.stringify(value[i], wrapArrays);
	            }

	            return wrapArrays ? '[' + partial + ']' : partial;
	        }

	        return value.toString();
	    }

	    return JSON.stringify(value);
	};

	internals.Err = function (type, context, state, options) {

	    this.type = type;
	    this.context = context || {};
	    this.context.key = state.key;
	    this.path = state.path;
	    this.options = options;
	};


	internals.Err.prototype.toString = function () {

	    var self = this;

	    var localized = this.options.language;

	    if (localized.label) {
	        this.context.key = localized.label;
	    }
	    else if (this.context.key === '' || this.context.key === null) {
	        this.context.key = localized.root || Language.errors.root;
	    }

	    var format = Hoek.reach(localized, this.type) || Hoek.reach(Language.errors, this.type);
	    var hasKey = /\{\{\!?key\}\}/.test(format);
	    var skipKey = format.length > 2 && format[0] === '!' && format[1] === '!';

	    if (skipKey) {
	        format = format.slice(2);
	    }

	    if (!hasKey && !skipKey) {
	        format = (Hoek.reach(localized, 'key') || Hoek.reach(Language.errors, 'key')) + format;
	    }

	    var wrapArrays = Hoek.reach(localized, 'messages.wrapArrays');
	    if (typeof wrapArrays !== 'boolean') {
	        wrapArrays = Language.errors.messages.wrapArrays;
	    }

	    var message = format.replace(/\{\{(\!?)([^}]+)\}\}/g, function ($0, isSecure, name) {

	        var value = Hoek.reach(self.context, name);
	        var normalized = internals.stringify(value, wrapArrays);
	        return (isSecure ? Hoek.escapeHtml(normalized) : normalized);
	    });

	    return message;
	};


	exports.create = function (type, context, state, options) {

	    return new internals.Err(type, context, state, options);
	};


	exports.process = function (errors, object) {

	    if (!errors || !errors.length) {
	        return null;
	    }

	    // Construct error

	    var message = '';
	    var details = [];

	    var processErrors = function (localErrors, parent) {

	        for (var i = 0, il = localErrors.length; i < il; ++i) {
	            var item = localErrors[i];

	            var detail = {
	                message: item.toString(),
	                path: internals.getPath(item),
	                type: item.type,
	                context: item.context
	            };

	            if (!parent) {
	                message += (message ? '. ' : '') + detail.message;
	            }

	            // Do not push intermediate errors, we're only interested in leafs
	            if (item.context.reason && item.context.reason.length) {
	                processErrors(item.context.reason, item.path);
	            }
	            else {
	                details.push(detail);
	            }
	        }
	    };

	    processErrors(errors);

	    var error = new Error(message);
	    error.name = 'ValidationError';
	    error.details = details;
	    error._object = object;
	    error.annotate = internals.annotate;
	    return error;
	};


	internals.getPath = function (item) {

	    var recursePath = function (it) {

	        var reachedItem = Hoek.reach(it, 'context.reason.0');
	        if (reachedItem && reachedItem.context) {
	            return recursePath(reachedItem);
	        }

	        return it.path;
	    };

	    return recursePath(item) || item.context.key;
	};


	// Inspired by json-stringify-safe
	internals.safeStringify = function (obj, spaces) {

	    return JSON.stringify(obj, internals.serializer(), spaces);
	};

	internals.serializer = function () {

	    var cycleReplacer = function (key, value) {

	        if (stack[0] === value) {
	            return '[Circular ~]';
	        }

	        return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';
	    };

	    var keys = [], stack = [];

	    return function (key, value) {

	        if (stack.length > 0) {
	            var thisPos = stack.indexOf(this);
	            if (~thisPos) {
	                stack.length = thisPos + 1;
	                keys.length = thisPos + 1;
	                keys[thisPos] = key;
	            }
	            else {
	                stack.push(this);
	                keys.push(key);
	            }

	            if (~stack.indexOf(value)) {
	                value = cycleReplacer.call(this, key, value);
	            }
	        }
	        else {
	            stack.push(value);
	        }

	        if (Array.isArray(value) && value.placeholders) {
	            var placeholders = value.placeholders;
	            var arrWithPlaceholders = [];
	            for (var i = 0, il = value.length; i < il; ++i) {
	                if (placeholders[i]) {
	                    arrWithPlaceholders.push(placeholders[i]);
	                }
	                arrWithPlaceholders.push(value[i]);
	            }

	            value = arrWithPlaceholders;
	        }

	        return value;
	    };
	};


	internals.annotate = function () {

	    var obj = Hoek.clone(this._object || {});

	    var lookup = {};
	    var el = this.details.length;
	    for (var e = el - 1; e >= 0; --e) {        // Reverse order to process deepest child first
	        var pos = el - e;
	        var error = this.details[e];
	        var path = error.path.split('.');
	        var ref = obj;
	        for (var i = 0, il = path.length; i < il && ref; ++i) {
	            var seg = path[i];
	            if (i + 1 < il) {
	                ref = ref[seg];
	            }
	            else {
	                var value = ref[seg];
	                if (Array.isArray(ref)) {
	                    var arrayLabel = '_$idx$_' + (e + 1) + '_$end$_';
	                    if (!ref.placeholders) {
	                        ref.placeholders = {};
	                    }

	                    if (ref.placeholders[seg]) {
	                        ref.placeholders[seg] = ref.placeholders[seg].replace('_$end$_', ', ' + (e + 1) + '_$end$_');
	                    }
	                    else {
	                        ref.placeholders[seg] = arrayLabel;
	                    }
	                } else {
	                    if (value !== undefined) {
	                        delete ref[seg];
	                        var objectLabel = seg + '_$key$_' + pos + '_$end$_';
	                        ref[objectLabel] = value;
	                        lookup[error.path] = objectLabel;
	                    }
	                    else if (lookup[error.path]) {
	                        var replacement = lookup[error.path];
	                        var appended = replacement.replace('_$end$_', ', ' + pos + '_$end$_');
	                        ref[appended] = ref[replacement];
	                        lookup[error.path] = appended;
	                        delete ref[replacement];
	                    }
	                    else {
	                        ref['_$miss$_' + seg + '|' + pos + '_$end$_'] = '__missing__';
	                    }
	                }
	            }
	        }
	    }

	    var message = internals.safeStringify(obj, 2)
	        .replace(/_\$key\$_([, \d]+)_\$end\$_\"/g, function ($0, $1) {

	            return '" \u001b[31m[' + $1 + ']\u001b[0m';
	        }).replace(/\"_\$miss\$_([^\|]+)\|(\d+)_\$end\$_\"\: \"__missing__\"/g, function ($0, $1, $2) {

	            return '\u001b[41m"' + $1 + '"\u001b[0m\u001b[31m [' + $2 + ']: -- missing --\u001b[0m';
	        }).replace(/\s*\"_\$idx\$_([, \d]+)_\$end\$_\",?\n(.*)/g, function ($0, $1, $2) {

	            return '\n' + $2 + ' \u001b[31m[' + $1 + ']\u001b[0m';
	        });

	    message += '\n\u001b[31m';

	    for (e = 0; e < el; ++e) {
	        message += '\n[' + (e + 1) + '] ' + this.details[e].message;
	    }

	    message += '\u001b[0m';

	    return message;
	};


/***/ },
/* 192 */
/***/ function(module, exports) {

	// Load modules


	// Declare internals

	var internals = {};


	exports.errors = {
	    root: 'value',
	    key: '"{{!key}}" ',
	    messages: {
	        wrapArrays: true
	    },
	    any: {
	        unknown: 'is not allowed',
	        invalid: 'contains an invalid value',
	        empty: 'is not allowed to be empty',
	        required: 'is required',
	        allowOnly: 'must be one of {{valids}}',
	        default: 'threw an error when running default method'
	    },
	    alternatives: {
	        base: 'not matching any of the allowed alternatives'
	    },
	    array: {
	        base: 'must be an array',
	        includes: 'at position {{pos}} does not match any of the allowed types',
	        includesSingle: 'single value of "{{!key}}" does not match any of the allowed types',
	        includesOne: 'at position {{pos}} fails because {{reason}}',
	        includesOneSingle: 'single value of "{{!key}}" fails because {{reason}}',
	        includesRequiredUnknowns: 'does not contain {{unknownMisses}} required value(s)',
	        includesRequiredKnowns: 'does not contain {{knownMisses}}',
	        includesRequiredBoth: 'does not contain {{knownMisses}} and {{unknownMisses}} other required value(s)',
	        excludes: 'at position {{pos}} contains an excluded value',
	        excludesSingle: 'single value of "{{!key}}" contains an excluded value',
	        min: 'must contain at least {{limit}} items',
	        max: 'must contain less than or equal to {{limit}} items',
	        length: 'must contain {{limit}} items',
	        ordered: 'at position {{pos}} fails because {{reason}}',
	        orderedLength: 'at position {{pos}} fails because array must contain at most {{limit}} items',
	        sparse: 'must not be a sparse array',
	        unique: 'position {{pos}} contains a duplicate value'
	    },
	    boolean: {
	        base: 'must be a boolean'
	    },
	    binary: {
	        base: 'must be a buffer or a string',
	        min: 'must be at least {{limit}} bytes',
	        max: 'must be less than or equal to {{limit}} bytes',
	        length: 'must be {{limit}} bytes'
	    },
	    date: {
	        base: 'must be a number of milliseconds or valid date string',
	        min: 'must be larger than or equal to "{{limit}}"',
	        max: 'must be less than or equal to "{{limit}}"',
	        isoDate: 'must be a valid ISO 8601 date',
	        ref: 'references "{{ref}}" which is not a date'
	    },
	    function: {
	        base: 'must be a Function'
	    },
	    object: {
	        base: 'must be an object',
	        child: 'child "{{!key}}" fails because {{reason}}',
	        min: 'must have at least {{limit}} children',
	        max: 'must have less than or equal to {{limit}} children',
	        length: 'must have {{limit}} children',
	        allowUnknown: 'is not allowed',
	        with: 'missing required peer "{{peer}}"',
	        without: 'conflict with forbidden peer "{{peer}}"',
	        missing: 'must contain at least one of {{peers}}',
	        xor: 'contains a conflict between exclusive peers {{peers}}',
	        or: 'must contain at least one of {{peers}}',
	        and: 'contains {{present}} without its required peers {{missing}}',
	        nand: '!!"{{main}}" must not exist simultaneously with {{peers}}',
	        assert: '!!"{{ref}}" validation failed because "{{ref}}" failed to {{message}}',
	        rename: {
	            multiple: 'cannot rename child "{{from}}" because multiple renames are disabled and another key was already renamed to "{{to}}"',
	            override: 'cannot rename child "{{from}}" because override is disabled and target "{{to}}" exists'
	        },
	        type: 'must be an instance of "{{type}}"'
	    },
	    number: {
	        base: 'must be a number',
	        min: 'must be larger than or equal to {{limit}}',
	        max: 'must be less than or equal to {{limit}}',
	        less: 'must be less than {{limit}}',
	        greater: 'must be greater than {{limit}}',
	        float: 'must be a float or double',
	        integer: 'must be an integer',
	        negative: 'must be a negative number',
	        positive: 'must be a positive number',
	        precision: 'must have no more than {{limit}} decimal places',
	        ref: 'references "{{ref}}" which is not a number',
	        multiple: 'must be a multiple of {{multiple}}'
	    },
	    string: {
	        base: 'must be a string',
	        min: 'length must be at least {{limit}} characters long',
	        max: 'length must be less than or equal to {{limit}} characters long',
	        length: 'length must be {{limit}} characters long',
	        alphanum: 'must only contain alpha-numeric characters',
	        token: 'must only contain alpha-numeric and underscore characters',
	        regex: {
	            base: 'with value "{{!value}}" fails to match the required pattern: {{pattern}}',
	            name: 'with value "{{!value}}" fails to match the {{name}} pattern'
	        },
	        email: 'must be a valid email',
	        uri: 'must be a valid uri',
	        uriCustomScheme: 'must be a valid uri with a scheme matching the {{scheme}} pattern',
	        isoDate: 'must be a valid ISO 8601 date',
	        guid: 'must be a valid GUID',
	        hex: 'must only contain hexadecimal characters',
	        hostname: 'must be a valid hostname',
	        lowercase: 'must only contain lowercase characters',
	        uppercase: 'must only contain uppercase characters',
	        trim: 'must not have leading or trailing whitespace',
	        creditCard: 'must be a credit card',
	        ref: 'references "{{ref}}" which is not a number',
	        ip: 'must be a valid ip address with a {{cidr}} CIDR',
	        ipVersion: 'must be a valid ip address of one of the following versions {{version}} with a {{cidr}} CIDR'
	    }
	};


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Hoek = __webpack_require__(187);
	var Ref = __webpack_require__(190);

	// Type modules are delay-loaded to prevent circular dependencies


	// Declare internals

	var internals = {
	    any: null,
	    date: __webpack_require__(194),
	    string: __webpack_require__(301),
	    number: __webpack_require__(309),
	    boolean: __webpack_require__(310),
	    alt: null,
	    object: null
	};


	exports.schema = function (config) {

	    internals.any = internals.any || new (__webpack_require__(186))();
	    internals.alt = internals.alt || __webpack_require__(311);
	    internals.object = internals.object || __webpack_require__(312);

	    if (config &&
	        typeof config === 'object') {

	        if (config.isJoi) {
	            return config;
	        }

	        if (Array.isArray(config)) {
	            return internals.alt.try(config);
	        }

	        if (config instanceof RegExp) {
	            return internals.string.regex(config);
	        }

	        if (config instanceof Date) {
	            return internals.date.valid(config);
	        }

	        return internals.object.keys(config);
	    }

	    if (typeof config === 'string') {
	        return internals.string.valid(config);
	    }

	    if (typeof config === 'number') {
	        return internals.number.valid(config);
	    }

	    if (typeof config === 'boolean') {
	        return internals.boolean.valid(config);
	    }

	    if (Ref.isRef(config)) {
	        return internals.any.valid(config);
	    }

	    Hoek.assert(config === null, 'Invalid schema content:', config);

	    return internals.any.valid(null);
	};


	exports.ref = function (id) {

	    return Ref.isRef(id) ? id : Ref.create(id);
	};


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Any = __webpack_require__(186);
	var Errors = __webpack_require__(191);
	var Ref = __webpack_require__(190);
	var Hoek = __webpack_require__(187);
	var Moment = __webpack_require__(195);


	// Declare internals

	var internals = {};

	internals.isoDate = /^(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/;
	internals.invalidDate = new Date('');
	internals.isIsoDate = (function () {

	    var isoString = internals.isoDate.toString();

	    return function (date) {

	        return date && (date.toString() === isoString);
	    };
	})();

	internals.Date = function () {

	    Any.call(this);
	    this._type = 'date';
	};

	Hoek.inherits(internals.Date, Any);


	internals.Date.prototype._base = function (value, state, options) {

	    var result = {
	        value: (options.convert && internals.toDate(value, this._flags.format)) || value
	    };

	    if (result.value instanceof Date && !isNaN(result.value.getTime())) {
	        result.errors = null;
	    }
	    else {
	        result.errors = Errors.create(internals.isIsoDate(this._flags.format) ? 'date.isoDate' : 'date.base', null, state, options);
	    }

	    return result;
	};


	internals.toDate = function (value, format) {

	    if (value instanceof Date) {
	        return value;
	    }

	    if (typeof value === 'string' ||
	        Hoek.isInteger(value)) {

	        if (typeof value === 'string' &&
	            /^[+-]?\d+$/.test(value)) {

	            value = parseInt(value, 10);
	        }

	        var date;
	        if (format) {
	            if (internals.isIsoDate(format)) {
	                date = format.test(value) ? new Date(value) : internals.invalidDate;
	            }
	            else {
	                date = Moment(value, format, true);
	                date = date.isValid() ? date.toDate() : internals.invalidDate;
	            }
	        }
	        else {
	            date = new Date(value);
	        }

	        if (!isNaN(date.getTime())) {
	            return date;
	        }
	    }

	    return null;
	};


	internals.compare = function (type, compare) {

	    return function (date) {

	        var isNow = date === 'now';
	        var isRef = Ref.isRef(date);

	        if (!isNow && !isRef) {
	            date = internals.toDate(date);
	        }

	        Hoek.assert(date, 'Invalid date format');

	        return this._test(type, date, function (value, state, options) {

	            var compareTo;
	            if (isNow) {
	                compareTo = Date.now();
	            }
	            else if (isRef) {
	                compareTo = internals.toDate(date(state.parent, options));

	                if (!compareTo) {
	                    return Errors.create('date.ref', { ref: date.key }, state, options);
	                }

	                compareTo = compareTo.getTime();
	            }
	            else {
	                compareTo = date.getTime();
	            }

	            if (compare(value.getTime(), compareTo)) {
	                return null;
	            }

	            return Errors.create('date.' + type, { limit: new Date(compareTo) }, state, options);
	        });
	    };
	};


	internals.Date.prototype.min = internals.compare('min', function (value, date) {

	    return value >= date;
	});


	internals.Date.prototype.max = internals.compare('max', function (value, date) {

	    return value <= date;
	});


	internals.Date.prototype.format = function (format) {

	    Hoek.assert(typeof format === 'string' || (Array.isArray(format) && format.every(function (f) {

	        return typeof f === 'string';
	    })), 'Invalid format.');

	    var obj = this.clone();
	    obj._flags.format = format;
	    return obj;
	};

	internals.Date.prototype.iso = function () {

	    var obj = this.clone();
	    obj._flags.format = internals.isoDate;
	    return obj;
	};

	internals.Date.prototype._isIsoDate = function (value) {

	    return internals.isoDate.test(value);
	};

	module.exports = new internals.Date();


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {//! moment.js
	//! version : 2.15.1
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com

	;(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    global.moment = factory()
	}(this, function () { 'use strict';

	    var hookCallback;

	    function utils_hooks__hooks () {
	        return hookCallback.apply(null, arguments);
	    }

	    // This is done to register the method called with moment()
	    // without creating circular dependencies.
	    function setHookCallback (callback) {
	        hookCallback = callback;
	    }

	    function isArray(input) {
	        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
	    }

	    function isObject(input) {
	        // IE8 will treat undefined and null as object if it wasn't for
	        // input != null
	        return input != null && Object.prototype.toString.call(input) === '[object Object]';
	    }

	    function isObjectEmpty(obj) {
	        var k;
	        for (k in obj) {
	            // even if its not own property I'd still call it non-empty
	            return false;
	        }
	        return true;
	    }

	    function isDate(input) {
	        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	    }

	    function map(arr, fn) {
	        var res = [], i;
	        for (i = 0; i < arr.length; ++i) {
	            res.push(fn(arr[i], i));
	        }
	        return res;
	    }

	    function hasOwnProp(a, b) {
	        return Object.prototype.hasOwnProperty.call(a, b);
	    }

	    function extend(a, b) {
	        for (var i in b) {
	            if (hasOwnProp(b, i)) {
	                a[i] = b[i];
	            }
	        }

	        if (hasOwnProp(b, 'toString')) {
	            a.toString = b.toString;
	        }

	        if (hasOwnProp(b, 'valueOf')) {
	            a.valueOf = b.valueOf;
	        }

	        return a;
	    }

	    function create_utc__createUTC (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, true).utc();
	    }

	    function defaultParsingFlags() {
	        // We need to deep clone this object.
	        return {
	            empty           : false,
	            unusedTokens    : [],
	            unusedInput     : [],
	            overflow        : -2,
	            charsLeftOver   : 0,
	            nullInput       : false,
	            invalidMonth    : null,
	            invalidFormat   : false,
	            userInvalidated : false,
	            iso             : false,
	            parsedDateParts : [],
	            meridiem        : null
	        };
	    }

	    function getParsingFlags(m) {
	        if (m._pf == null) {
	            m._pf = defaultParsingFlags();
	        }
	        return m._pf;
	    }

	    var some;
	    if (Array.prototype.some) {
	        some = Array.prototype.some;
	    } else {
	        some = function (fun) {
	            var t = Object(this);
	            var len = t.length >>> 0;

	            for (var i = 0; i < len; i++) {
	                if (i in t && fun.call(this, t[i], i, t)) {
	                    return true;
	                }
	            }

	            return false;
	        };
	    }

	    function valid__isValid(m) {
	        if (m._isValid == null) {
	            var flags = getParsingFlags(m);
	            var parsedParts = some.call(flags.parsedDateParts, function (i) {
	                return i != null;
	            });
	            var isNowValid = !isNaN(m._d.getTime()) &&
	                flags.overflow < 0 &&
	                !flags.empty &&
	                !flags.invalidMonth &&
	                !flags.invalidWeekday &&
	                !flags.nullInput &&
	                !flags.invalidFormat &&
	                !flags.userInvalidated &&
	                (!flags.meridiem || (flags.meridiem && parsedParts));

	            if (m._strict) {
	                isNowValid = isNowValid &&
	                    flags.charsLeftOver === 0 &&
	                    flags.unusedTokens.length === 0 &&
	                    flags.bigHour === undefined;
	            }

	            if (Object.isFrozen == null || !Object.isFrozen(m)) {
	                m._isValid = isNowValid;
	            }
	            else {
	                return isNowValid;
	            }
	        }
	        return m._isValid;
	    }

	    function valid__createInvalid (flags) {
	        var m = create_utc__createUTC(NaN);
	        if (flags != null) {
	            extend(getParsingFlags(m), flags);
	        }
	        else {
	            getParsingFlags(m).userInvalidated = true;
	        }

	        return m;
	    }

	    function isUndefined(input) {
	        return input === void 0;
	    }

	    // Plugins that add properties should also add the key here (null value),
	    // so we can properly clone ourselves.
	    var momentProperties = utils_hooks__hooks.momentProperties = [];

	    function copyConfig(to, from) {
	        var i, prop, val;

	        if (!isUndefined(from._isAMomentObject)) {
	            to._isAMomentObject = from._isAMomentObject;
	        }
	        if (!isUndefined(from._i)) {
	            to._i = from._i;
	        }
	        if (!isUndefined(from._f)) {
	            to._f = from._f;
	        }
	        if (!isUndefined(from._l)) {
	            to._l = from._l;
	        }
	        if (!isUndefined(from._strict)) {
	            to._strict = from._strict;
	        }
	        if (!isUndefined(from._tzm)) {
	            to._tzm = from._tzm;
	        }
	        if (!isUndefined(from._isUTC)) {
	            to._isUTC = from._isUTC;
	        }
	        if (!isUndefined(from._offset)) {
	            to._offset = from._offset;
	        }
	        if (!isUndefined(from._pf)) {
	            to._pf = getParsingFlags(from);
	        }
	        if (!isUndefined(from._locale)) {
	            to._locale = from._locale;
	        }

	        if (momentProperties.length > 0) {
	            for (i in momentProperties) {
	                prop = momentProperties[i];
	                val = from[prop];
	                if (!isUndefined(val)) {
	                    to[prop] = val;
	                }
	            }
	        }

	        return to;
	    }

	    var updateInProgress = false;

	    // Moment prototype object
	    function Moment(config) {
	        copyConfig(this, config);
	        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	        // Prevent infinite loop in case updateOffset creates new moment
	        // objects.
	        if (updateInProgress === false) {
	            updateInProgress = true;
	            utils_hooks__hooks.updateOffset(this);
	            updateInProgress = false;
	        }
	    }

	    function isMoment (obj) {
	        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
	    }

	    function absFloor (number) {
	        if (number < 0) {
	            // -0 -> 0
	            return Math.ceil(number) || 0;
	        } else {
	            return Math.floor(number);
	        }
	    }

	    function toInt(argumentForCoercion) {
	        var coercedNumber = +argumentForCoercion,
	            value = 0;

	        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	            value = absFloor(coercedNumber);
	        }

	        return value;
	    }

	    // compare two arrays, return the number of differences
	    function compareArrays(array1, array2, dontConvert) {
	        var len = Math.min(array1.length, array2.length),
	            lengthDiff = Math.abs(array1.length - array2.length),
	            diffs = 0,
	            i;
	        for (i = 0; i < len; i++) {
	            if ((dontConvert && array1[i] !== array2[i]) ||
	                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	                diffs++;
	            }
	        }
	        return diffs + lengthDiff;
	    }

	    function warn(msg) {
	        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
	                (typeof console !==  'undefined') && console.warn) {
	            console.warn('Deprecation warning: ' + msg);
	        }
	    }

	    function deprecate(msg, fn) {
	        var firstTime = true;

	        return extend(function () {
	            if (utils_hooks__hooks.deprecationHandler != null) {
	                utils_hooks__hooks.deprecationHandler(null, msg);
	            }
	            if (firstTime) {
	                var args = [];
	                var arg;
	                for (var i = 0; i < arguments.length; i++) {
	                    arg = '';
	                    if (typeof arguments[i] === 'object') {
	                        arg += '\n[' + i + '] ';
	                        for (var key in arguments[0]) {
	                            arg += key + ': ' + arguments[0][key] + ', ';
	                        }
	                        arg = arg.slice(0, -2); // Remove trailing comma and space
	                    } else {
	                        arg = arguments[i];
	                    }
	                    args.push(arg);
	                }
	                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
	                firstTime = false;
	            }
	            return fn.apply(this, arguments);
	        }, fn);
	    }

	    var deprecations = {};

	    function deprecateSimple(name, msg) {
	        if (utils_hooks__hooks.deprecationHandler != null) {
	            utils_hooks__hooks.deprecationHandler(name, msg);
	        }
	        if (!deprecations[name]) {
	            warn(msg);
	            deprecations[name] = true;
	        }
	    }

	    utils_hooks__hooks.suppressDeprecationWarnings = false;
	    utils_hooks__hooks.deprecationHandler = null;

	    function isFunction(input) {
	        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	    }

	    function locale_set__set (config) {
	        var prop, i;
	        for (i in config) {
	            prop = config[i];
	            if (isFunction(prop)) {
	                this[i] = prop;
	            } else {
	                this['_' + i] = prop;
	            }
	        }
	        this._config = config;
	        // Lenient ordinal parsing accepts just a number in addition to
	        // number + (possibly) stuff coming from _ordinalParseLenient.
	        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
	    }

	    function mergeConfigs(parentConfig, childConfig) {
	        var res = extend({}, parentConfig), prop;
	        for (prop in childConfig) {
	            if (hasOwnProp(childConfig, prop)) {
	                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
	                    res[prop] = {};
	                    extend(res[prop], parentConfig[prop]);
	                    extend(res[prop], childConfig[prop]);
	                } else if (childConfig[prop] != null) {
	                    res[prop] = childConfig[prop];
	                } else {
	                    delete res[prop];
	                }
	            }
	        }
	        for (prop in parentConfig) {
	            if (hasOwnProp(parentConfig, prop) &&
	                    !hasOwnProp(childConfig, prop) &&
	                    isObject(parentConfig[prop])) {
	                // make sure changes to properties don't modify parent config
	                res[prop] = extend({}, res[prop]);
	            }
	        }
	        return res;
	    }

	    function Locale(config) {
	        if (config != null) {
	            this.set(config);
	        }
	    }

	    var keys;

	    if (Object.keys) {
	        keys = Object.keys;
	    } else {
	        keys = function (obj) {
	            var i, res = [];
	            for (i in obj) {
	                if (hasOwnProp(obj, i)) {
	                    res.push(i);
	                }
	            }
	            return res;
	        };
	    }

	    var defaultCalendar = {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    };

	    function locale_calendar__calendar (key, mom, now) {
	        var output = this._calendar[key] || this._calendar['sameElse'];
	        return isFunction(output) ? output.call(mom, now) : output;
	    }

	    var defaultLongDateFormat = {
	        LTS  : 'h:mm:ss A',
	        LT   : 'h:mm A',
	        L    : 'MM/DD/YYYY',
	        LL   : 'MMMM D, YYYY',
	        LLL  : 'MMMM D, YYYY h:mm A',
	        LLLL : 'dddd, MMMM D, YYYY h:mm A'
	    };

	    function longDateFormat (key) {
	        var format = this._longDateFormat[key],
	            formatUpper = this._longDateFormat[key.toUpperCase()];

	        if (format || !formatUpper) {
	            return format;
	        }

	        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	            return val.slice(1);
	        });

	        return this._longDateFormat[key];
	    }

	    var defaultInvalidDate = 'Invalid date';

	    function invalidDate () {
	        return this._invalidDate;
	    }

	    var defaultOrdinal = '%d';
	    var defaultOrdinalParse = /\d{1,2}/;

	    function ordinal (number) {
	        return this._ordinal.replace('%d', number);
	    }

	    var defaultRelativeTime = {
	        future : 'in %s',
	        past   : '%s ago',
	        s  : 'a few seconds',
	        m  : 'a minute',
	        mm : '%d minutes',
	        h  : 'an hour',
	        hh : '%d hours',
	        d  : 'a day',
	        dd : '%d days',
	        M  : 'a month',
	        MM : '%d months',
	        y  : 'a year',
	        yy : '%d years'
	    };

	    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
	        var output = this._relativeTime[string];
	        return (isFunction(output)) ?
	            output(number, withoutSuffix, string, isFuture) :
	            output.replace(/%d/i, number);
	    }

	    function pastFuture (diff, output) {
	        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	    }

	    var aliases = {};

	    function addUnitAlias (unit, shorthand) {
	        var lowerCase = unit.toLowerCase();
	        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	    }

	    function normalizeUnits(units) {
	        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	    }

	    function normalizeObjectUnits(inputObject) {
	        var normalizedInput = {},
	            normalizedProp,
	            prop;

	        for (prop in inputObject) {
	            if (hasOwnProp(inputObject, prop)) {
	                normalizedProp = normalizeUnits(prop);
	                if (normalizedProp) {
	                    normalizedInput[normalizedProp] = inputObject[prop];
	                }
	            }
	        }

	        return normalizedInput;
	    }

	    var priorities = {};

	    function addUnitPriority(unit, priority) {
	        priorities[unit] = priority;
	    }

	    function getPrioritizedUnits(unitsObj) {
	        var units = [];
	        for (var u in unitsObj) {
	            units.push({unit: u, priority: priorities[u]});
	        }
	        units.sort(function (a, b) {
	            return a.priority - b.priority;
	        });
	        return units;
	    }

	    function makeGetSet (unit, keepTime) {
	        return function (value) {
	            if (value != null) {
	                get_set__set(this, unit, value);
	                utils_hooks__hooks.updateOffset(this, keepTime);
	                return this;
	            } else {
	                return get_set__get(this, unit);
	            }
	        };
	    }

	    function get_set__get (mom, unit) {
	        return mom.isValid() ?
	            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
	    }

	    function get_set__set (mom, unit, value) {
	        if (mom.isValid()) {
	            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	        }
	    }

	    // MOMENTS

	    function stringGet (units) {
	        units = normalizeUnits(units);
	        if (isFunction(this[units])) {
	            return this[units]();
	        }
	        return this;
	    }


	    function stringSet (units, value) {
	        if (typeof units === 'object') {
	            units = normalizeObjectUnits(units);
	            var prioritized = getPrioritizedUnits(units);
	            for (var i = 0; i < prioritized.length; i++) {
	                this[prioritized[i].unit](units[prioritized[i].unit]);
	            }
	        } else {
	            units = normalizeUnits(units);
	            if (isFunction(this[units])) {
	                return this[units](value);
	            }
	        }
	        return this;
	    }

	    function zeroFill(number, targetLength, forceSign) {
	        var absNumber = '' + Math.abs(number),
	            zerosToFill = targetLength - absNumber.length,
	            sign = number >= 0;
	        return (sign ? (forceSign ? '+' : '') : '-') +
	            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	    }

	    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

	    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

	    var formatFunctions = {};

	    var formatTokenFunctions = {};

	    // token:    'M'
	    // padded:   ['MM', 2]
	    // ordinal:  'Mo'
	    // callback: function () { this.month() + 1 }
	    function addFormatToken (token, padded, ordinal, callback) {
	        var func = callback;
	        if (typeof callback === 'string') {
	            func = function () {
	                return this[callback]();
	            };
	        }
	        if (token) {
	            formatTokenFunctions[token] = func;
	        }
	        if (padded) {
	            formatTokenFunctions[padded[0]] = function () {
	                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	            };
	        }
	        if (ordinal) {
	            formatTokenFunctions[ordinal] = function () {
	                return this.localeData().ordinal(func.apply(this, arguments), token);
	            };
	        }
	    }

	    function removeFormattingTokens(input) {
	        if (input.match(/\[[\s\S]/)) {
	            return input.replace(/^\[|\]$/g, '');
	        }
	        return input.replace(/\\/g, '');
	    }

	    function makeFormatFunction(format) {
	        var array = format.match(formattingTokens), i, length;

	        for (i = 0, length = array.length; i < length; i++) {
	            if (formatTokenFunctions[array[i]]) {
	                array[i] = formatTokenFunctions[array[i]];
	            } else {
	                array[i] = removeFormattingTokens(array[i]);
	            }
	        }

	        return function (mom) {
	            var output = '', i;
	            for (i = 0; i < length; i++) {
	                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
	            }
	            return output;
	        };
	    }

	    // format date using native date object
	    function formatMoment(m, format) {
	        if (!m.isValid()) {
	            return m.localeData().invalidDate();
	        }

	        format = expandFormat(format, m.localeData());
	        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

	        return formatFunctions[format](m);
	    }

	    function expandFormat(format, locale) {
	        var i = 5;

	        function replaceLongDateFormatTokens(input) {
	            return locale.longDateFormat(input) || input;
	        }

	        localFormattingTokens.lastIndex = 0;
	        while (i >= 0 && localFormattingTokens.test(format)) {
	            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	            localFormattingTokens.lastIndex = 0;
	            i -= 1;
	        }

	        return format;
	    }

	    var match1         = /\d/;            //       0 - 9
	    var match2         = /\d\d/;          //      00 - 99
	    var match3         = /\d{3}/;         //     000 - 999
	    var match4         = /\d{4}/;         //    0000 - 9999
	    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
	    var match1to2      = /\d\d?/;         //       0 - 99
	    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
	    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
	    var match1to3      = /\d{1,3}/;       //       0 - 999
	    var match1to4      = /\d{1,4}/;       //       0 - 9999
	    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

	    var matchUnsigned  = /\d+/;           //       0 - inf
	    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

	    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
	    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

	    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

	    // any word (or two) characters or numbers including two/three word month in arabic.
	    // includes scottish gaelic two word and hyphenated months
	    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


	    var regexes = {};

	    function addRegexToken (token, regex, strictRegex) {
	        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
	            return (isStrict && strictRegex) ? strictRegex : regex;
	        };
	    }

	    function getParseRegexForToken (token, config) {
	        if (!hasOwnProp(regexes, token)) {
	            return new RegExp(unescapeFormat(token));
	        }

	        return regexes[token](config._strict, config._locale);
	    }

	    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	    function unescapeFormat(s) {
	        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	            return p1 || p2 || p3 || p4;
	        }));
	    }

	    function regexEscape(s) {
	        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }

	    var tokens = {};

	    function addParseToken (token, callback) {
	        var i, func = callback;
	        if (typeof token === 'string') {
	            token = [token];
	        }
	        if (typeof callback === 'number') {
	            func = function (input, array) {
	                array[callback] = toInt(input);
	            };
	        }
	        for (i = 0; i < token.length; i++) {
	            tokens[token[i]] = func;
	        }
	    }

	    function addWeekParseToken (token, callback) {
	        addParseToken(token, function (input, array, config, token) {
	            config._w = config._w || {};
	            callback(input, config._w, config, token);
	        });
	    }

	    function addTimeToArrayFromToken(token, input, config) {
	        if (input != null && hasOwnProp(tokens, token)) {
	            tokens[token](input, config._a, config, token);
	        }
	    }

	    var YEAR = 0;
	    var MONTH = 1;
	    var DATE = 2;
	    var HOUR = 3;
	    var MINUTE = 4;
	    var SECOND = 5;
	    var MILLISECOND = 6;
	    var WEEK = 7;
	    var WEEKDAY = 8;

	    var indexOf;

	    if (Array.prototype.indexOf) {
	        indexOf = Array.prototype.indexOf;
	    } else {
	        indexOf = function (o) {
	            // I know
	            var i;
	            for (i = 0; i < this.length; ++i) {
	                if (this[i] === o) {
	                    return i;
	                }
	            }
	            return -1;
	        };
	    }

	    function daysInMonth(year, month) {
	        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	    }

	    // FORMATTING

	    addFormatToken('M', ['MM', 2], 'Mo', function () {
	        return this.month() + 1;
	    });

	    addFormatToken('MMM', 0, 0, function (format) {
	        return this.localeData().monthsShort(this, format);
	    });

	    addFormatToken('MMMM', 0, 0, function (format) {
	        return this.localeData().months(this, format);
	    });

	    // ALIASES

	    addUnitAlias('month', 'M');

	    // PRIORITY

	    addUnitPriority('month', 8);

	    // PARSING

	    addRegexToken('M',    match1to2);
	    addRegexToken('MM',   match1to2, match2);
	    addRegexToken('MMM',  function (isStrict, locale) {
	        return locale.monthsShortRegex(isStrict);
	    });
	    addRegexToken('MMMM', function (isStrict, locale) {
	        return locale.monthsRegex(isStrict);
	    });

	    addParseToken(['M', 'MM'], function (input, array) {
	        array[MONTH] = toInt(input) - 1;
	    });

	    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	        var month = config._locale.monthsParse(input, token, config._strict);
	        // if we didn't find a month name, mark the date as invalid.
	        if (month != null) {
	            array[MONTH] = month;
	        } else {
	            getParsingFlags(config).invalidMonth = input;
	        }
	    });

	    // LOCALES

	    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
	    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
	    function localeMonths (m, format) {
	        if (!m) {
	            return this._months;
	        }
	        return isArray(this._months) ? this._months[m.month()] :
	            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
	    }

	    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
	    function localeMonthsShort (m, format) {
	        if (!m) {
	            return this._monthsShort;
	        }
	        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
	            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	    }

	    function units_month__handleStrictParse(monthName, format, strict) {
	        var i, ii, mom, llc = monthName.toLocaleLowerCase();
	        if (!this._monthsParse) {
	            // this is not used
	            this._monthsParse = [];
	            this._longMonthsParse = [];
	            this._shortMonthsParse = [];
	            for (i = 0; i < 12; ++i) {
	                mom = create_utc__createUTC([2000, i]);
	                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
	                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
	            }
	        }

	        if (strict) {
	            if (format === 'MMM') {
	                ii = indexOf.call(this._shortMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._longMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        } else {
	            if (format === 'MMM') {
	                ii = indexOf.call(this._shortMonthsParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._longMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._longMonthsParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._shortMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        }
	    }

	    function localeMonthsParse (monthName, format, strict) {
	        var i, mom, regex;

	        if (this._monthsParseExact) {
	            return units_month__handleStrictParse.call(this, monthName, format, strict);
	        }

	        if (!this._monthsParse) {
	            this._monthsParse = [];
	            this._longMonthsParse = [];
	            this._shortMonthsParse = [];
	        }

	        // TODO: add sorting
	        // Sorting makes sure if one month (or abbr) is a prefix of another
	        // see sorting in computeMonthsParse
	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = create_utc__createUTC([2000, i]);
	            if (strict && !this._longMonthsParse[i]) {
	                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	            }
	            if (!strict && !this._monthsParse[i]) {
	                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (!strict && this._monthsParse[i].test(monthName)) {
	                return i;
	            }
	        }
	    }

	    // MOMENTS

	    function setMonth (mom, value) {
	        var dayOfMonth;

	        if (!mom.isValid()) {
	            // No op
	            return mom;
	        }

	        if (typeof value === 'string') {
	            if (/^\d+$/.test(value)) {
	                value = toInt(value);
	            } else {
	                value = mom.localeData().monthsParse(value);
	                // TODO: Another silent failure?
	                if (typeof value !== 'number') {
	                    return mom;
	                }
	            }
	        }

	        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	        return mom;
	    }

	    function getSetMonth (value) {
	        if (value != null) {
	            setMonth(this, value);
	            utils_hooks__hooks.updateOffset(this, true);
	            return this;
	        } else {
	            return get_set__get(this, 'Month');
	        }
	    }

	    function getDaysInMonth () {
	        return daysInMonth(this.year(), this.month());
	    }

	    var defaultMonthsShortRegex = matchWord;
	    function monthsShortRegex (isStrict) {
	        if (this._monthsParseExact) {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                computeMonthsParse.call(this);
	            }
	            if (isStrict) {
	                return this._monthsShortStrictRegex;
	            } else {
	                return this._monthsShortRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_monthsShortRegex')) {
	                this._monthsShortRegex = defaultMonthsShortRegex;
	            }
	            return this._monthsShortStrictRegex && isStrict ?
	                this._monthsShortStrictRegex : this._monthsShortRegex;
	        }
	    }

	    var defaultMonthsRegex = matchWord;
	    function monthsRegex (isStrict) {
	        if (this._monthsParseExact) {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                computeMonthsParse.call(this);
	            }
	            if (isStrict) {
	                return this._monthsStrictRegex;
	            } else {
	                return this._monthsRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                this._monthsRegex = defaultMonthsRegex;
	            }
	            return this._monthsStrictRegex && isStrict ?
	                this._monthsStrictRegex : this._monthsRegex;
	        }
	    }

	    function computeMonthsParse () {
	        function cmpLenRev(a, b) {
	            return b.length - a.length;
	        }

	        var shortPieces = [], longPieces = [], mixedPieces = [],
	            i, mom;
	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = create_utc__createUTC([2000, i]);
	            shortPieces.push(this.monthsShort(mom, ''));
	            longPieces.push(this.months(mom, ''));
	            mixedPieces.push(this.months(mom, ''));
	            mixedPieces.push(this.monthsShort(mom, ''));
	        }
	        // Sorting makes sure if one month (or abbr) is a prefix of another it
	        // will match the longer piece.
	        shortPieces.sort(cmpLenRev);
	        longPieces.sort(cmpLenRev);
	        mixedPieces.sort(cmpLenRev);
	        for (i = 0; i < 12; i++) {
	            shortPieces[i] = regexEscape(shortPieces[i]);
	            longPieces[i] = regexEscape(longPieces[i]);
	        }
	        for (i = 0; i < 24; i++) {
	            mixedPieces[i] = regexEscape(mixedPieces[i]);
	        }

	        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	        this._monthsShortRegex = this._monthsRegex;
	        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	    }

	    // FORMATTING

	    addFormatToken('Y', 0, 0, function () {
	        var y = this.year();
	        return y <= 9999 ? '' + y : '+' + y;
	    });

	    addFormatToken(0, ['YY', 2], 0, function () {
	        return this.year() % 100;
	    });

	    addFormatToken(0, ['YYYY',   4],       0, 'year');
	    addFormatToken(0, ['YYYYY',  5],       0, 'year');
	    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

	    // ALIASES

	    addUnitAlias('year', 'y');

	    // PRIORITIES

	    addUnitPriority('year', 1);

	    // PARSING

	    addRegexToken('Y',      matchSigned);
	    addRegexToken('YY',     match1to2, match2);
	    addRegexToken('YYYY',   match1to4, match4);
	    addRegexToken('YYYYY',  match1to6, match6);
	    addRegexToken('YYYYYY', match1to6, match6);

	    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	    addParseToken('YYYY', function (input, array) {
	        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
	    });
	    addParseToken('YY', function (input, array) {
	        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
	    });
	    addParseToken('Y', function (input, array) {
	        array[YEAR] = parseInt(input, 10);
	    });

	    // HELPERS

	    function daysInYear(year) {
	        return isLeapYear(year) ? 366 : 365;
	    }

	    function isLeapYear(year) {
	        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	    }

	    // HOOKS

	    utils_hooks__hooks.parseTwoDigitYear = function (input) {
	        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	    };

	    // MOMENTS

	    var getSetYear = makeGetSet('FullYear', true);

	    function getIsLeapYear () {
	        return isLeapYear(this.year());
	    }

	    function createDate (y, m, d, h, M, s, ms) {
	        //can't just apply() to create a date:
	        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
	        var date = new Date(y, m, d, h, M, s, ms);

	        //the date constructor remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
	            date.setFullYear(y);
	        }
	        return date;
	    }

	    function createUTCDate (y) {
	        var date = new Date(Date.UTC.apply(null, arguments));

	        //the Date.UTC function remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
	            date.setUTCFullYear(y);
	        }
	        return date;
	    }

	    // start-of-first-week - start-of-year
	    function firstWeekOffset(year, dow, doy) {
	        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	            fwd = 7 + dow - doy,
	            // first-week day local weekday -- which local weekday is fwd
	            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

	        return -fwdlw + fwd - 1;
	    }

	    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	        var localWeekday = (7 + weekday - dow) % 7,
	            weekOffset = firstWeekOffset(year, dow, doy),
	            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
	            resYear, resDayOfYear;

	        if (dayOfYear <= 0) {
	            resYear = year - 1;
	            resDayOfYear = daysInYear(resYear) + dayOfYear;
	        } else if (dayOfYear > daysInYear(year)) {
	            resYear = year + 1;
	            resDayOfYear = dayOfYear - daysInYear(year);
	        } else {
	            resYear = year;
	            resDayOfYear = dayOfYear;
	        }

	        return {
	            year: resYear,
	            dayOfYear: resDayOfYear
	        };
	    }

	    function weekOfYear(mom, dow, doy) {
	        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
	            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	            resWeek, resYear;

	        if (week < 1) {
	            resYear = mom.year() - 1;
	            resWeek = week + weeksInYear(resYear, dow, doy);
	        } else if (week > weeksInYear(mom.year(), dow, doy)) {
	            resWeek = week - weeksInYear(mom.year(), dow, doy);
	            resYear = mom.year() + 1;
	        } else {
	            resYear = mom.year();
	            resWeek = week;
	        }

	        return {
	            week: resWeek,
	            year: resYear
	        };
	    }

	    function weeksInYear(year, dow, doy) {
	        var weekOffset = firstWeekOffset(year, dow, doy),
	            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
	        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	    }

	    // FORMATTING

	    addFormatToken('w', ['ww', 2], 'wo', 'week');
	    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

	    // ALIASES

	    addUnitAlias('week', 'w');
	    addUnitAlias('isoWeek', 'W');

	    // PRIORITIES

	    addUnitPriority('week', 5);
	    addUnitPriority('isoWeek', 5);

	    // PARSING

	    addRegexToken('w',  match1to2);
	    addRegexToken('ww', match1to2, match2);
	    addRegexToken('W',  match1to2);
	    addRegexToken('WW', match1to2, match2);

	    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
	        week[token.substr(0, 1)] = toInt(input);
	    });

	    // HELPERS

	    // LOCALES

	    function localeWeek (mom) {
	        return weekOfYear(mom, this._week.dow, this._week.doy).week;
	    }

	    var defaultLocaleWeek = {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    };

	    function localeFirstDayOfWeek () {
	        return this._week.dow;
	    }

	    function localeFirstDayOfYear () {
	        return this._week.doy;
	    }

	    // MOMENTS

	    function getSetWeek (input) {
	        var week = this.localeData().week(this);
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }

	    function getSetISOWeek (input) {
	        var week = weekOfYear(this, 1, 4).week;
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }

	    // FORMATTING

	    addFormatToken('d', 0, 'do', 'day');

	    addFormatToken('dd', 0, 0, function (format) {
	        return this.localeData().weekdaysMin(this, format);
	    });

	    addFormatToken('ddd', 0, 0, function (format) {
	        return this.localeData().weekdaysShort(this, format);
	    });

	    addFormatToken('dddd', 0, 0, function (format) {
	        return this.localeData().weekdays(this, format);
	    });

	    addFormatToken('e', 0, 0, 'weekday');
	    addFormatToken('E', 0, 0, 'isoWeekday');

	    // ALIASES

	    addUnitAlias('day', 'd');
	    addUnitAlias('weekday', 'e');
	    addUnitAlias('isoWeekday', 'E');

	    // PRIORITY
	    addUnitPriority('day', 11);
	    addUnitPriority('weekday', 11);
	    addUnitPriority('isoWeekday', 11);

	    // PARSING

	    addRegexToken('d',    match1to2);
	    addRegexToken('e',    match1to2);
	    addRegexToken('E',    match1to2);
	    addRegexToken('dd',   function (isStrict, locale) {
	        return locale.weekdaysMinRegex(isStrict);
	    });
	    addRegexToken('ddd',   function (isStrict, locale) {
	        return locale.weekdaysShortRegex(isStrict);
	    });
	    addRegexToken('dddd',   function (isStrict, locale) {
	        return locale.weekdaysRegex(isStrict);
	    });

	    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
	        var weekday = config._locale.weekdaysParse(input, token, config._strict);
	        // if we didn't get a weekday name, mark the date as invalid
	        if (weekday != null) {
	            week.d = weekday;
	        } else {
	            getParsingFlags(config).invalidWeekday = input;
	        }
	    });

	    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	        week[token] = toInt(input);
	    });

	    // HELPERS

	    function parseWeekday(input, locale) {
	        if (typeof input !== 'string') {
	            return input;
	        }

	        if (!isNaN(input)) {
	            return parseInt(input, 10);
	        }

	        input = locale.weekdaysParse(input);
	        if (typeof input === 'number') {
	            return input;
	        }

	        return null;
	    }

	    function parseIsoWeekday(input, locale) {
	        if (typeof input === 'string') {
	            return locale.weekdaysParse(input) % 7 || 7;
	        }
	        return isNaN(input) ? null : input;
	    }

	    // LOCALES

	    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
	    function localeWeekdays (m, format) {
	        if (!m) {
	            return this._weekdays;
	        }
	        return isArray(this._weekdays) ? this._weekdays[m.day()] :
	            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
	    }

	    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
	    function localeWeekdaysShort (m) {
	        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
	    }

	    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
	    function localeWeekdaysMin (m) {
	        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
	    }

	    function day_of_week__handleStrictParse(weekdayName, format, strict) {
	        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
	        if (!this._weekdaysParse) {
	            this._weekdaysParse = [];
	            this._shortWeekdaysParse = [];
	            this._minWeekdaysParse = [];

	            for (i = 0; i < 7; ++i) {
	                mom = create_utc__createUTC([2000, 1]).day(i);
	                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
	                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
	                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
	            }
	        }

	        if (strict) {
	            if (format === 'dddd') {
	                ii = indexOf.call(this._weekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else if (format === 'ddd') {
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        } else {
	            if (format === 'dddd') {
	                ii = indexOf.call(this._weekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else if (format === 'ddd') {
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._weekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._weekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        }
	    }

	    function localeWeekdaysParse (weekdayName, format, strict) {
	        var i, mom, regex;

	        if (this._weekdaysParseExact) {
	            return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
	        }

	        if (!this._weekdaysParse) {
	            this._weekdaysParse = [];
	            this._minWeekdaysParse = [];
	            this._shortWeekdaysParse = [];
	            this._fullWeekdaysParse = [];
	        }

	        for (i = 0; i < 7; i++) {
	            // make the regex if we don't have it already

	            mom = create_utc__createUTC([2000, 1]).day(i);
	            if (strict && !this._fullWeekdaysParse[i]) {
	                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
	                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
	                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
	            }
	            if (!this._weekdaysParse[i]) {
	                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
	                return i;
	            }
	        }
	    }

	    // MOMENTS

	    function getSetDayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	        if (input != null) {
	            input = parseWeekday(input, this.localeData());
	            return this.add(input - day, 'd');
	        } else {
	            return day;
	        }
	    }

	    function getSetLocaleDayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	        return input == null ? weekday : this.add(input - weekday, 'd');
	    }

	    function getSetISODayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }

	        // behaves the same as moment#day except
	        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	        // as a setter, sunday should belong to the previous week.

	        if (input != null) {
	            var weekday = parseIsoWeekday(input, this.localeData());
	            return this.day(this.day() % 7 ? weekday : weekday - 7);
	        } else {
	            return this.day() || 7;
	        }
	    }

	    var defaultWeekdaysRegex = matchWord;
	    function weekdaysRegex (isStrict) {
	        if (this._weekdaysParseExact) {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                computeWeekdaysParse.call(this);
	            }
	            if (isStrict) {
	                return this._weekdaysStrictRegex;
	            } else {
	                return this._weekdaysRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                this._weekdaysRegex = defaultWeekdaysRegex;
	            }
	            return this._weekdaysStrictRegex && isStrict ?
	                this._weekdaysStrictRegex : this._weekdaysRegex;
	        }
	    }

	    var defaultWeekdaysShortRegex = matchWord;
	    function weekdaysShortRegex (isStrict) {
	        if (this._weekdaysParseExact) {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                computeWeekdaysParse.call(this);
	            }
	            if (isStrict) {
	                return this._weekdaysShortStrictRegex;
	            } else {
	                return this._weekdaysShortRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
	                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
	            }
	            return this._weekdaysShortStrictRegex && isStrict ?
	                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
	        }
	    }

	    var defaultWeekdaysMinRegex = matchWord;
	    function weekdaysMinRegex (isStrict) {
	        if (this._weekdaysParseExact) {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                computeWeekdaysParse.call(this);
	            }
	            if (isStrict) {
	                return this._weekdaysMinStrictRegex;
	            } else {
	                return this._weekdaysMinRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
	                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
	            }
	            return this._weekdaysMinStrictRegex && isStrict ?
	                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
	        }
	    }


	    function computeWeekdaysParse () {
	        function cmpLenRev(a, b) {
	            return b.length - a.length;
	        }

	        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
	            i, mom, minp, shortp, longp;
	        for (i = 0; i < 7; i++) {
	            // make the regex if we don't have it already
	            mom = create_utc__createUTC([2000, 1]).day(i);
	            minp = this.weekdaysMin(mom, '');
	            shortp = this.weekdaysShort(mom, '');
	            longp = this.weekdays(mom, '');
	            minPieces.push(minp);
	            shortPieces.push(shortp);
	            longPieces.push(longp);
	            mixedPieces.push(minp);
	            mixedPieces.push(shortp);
	            mixedPieces.push(longp);
	        }
	        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
	        // will match the longer piece.
	        minPieces.sort(cmpLenRev);
	        shortPieces.sort(cmpLenRev);
	        longPieces.sort(cmpLenRev);
	        mixedPieces.sort(cmpLenRev);
	        for (i = 0; i < 7; i++) {
	            shortPieces[i] = regexEscape(shortPieces[i]);
	            longPieces[i] = regexEscape(longPieces[i]);
	            mixedPieces[i] = regexEscape(mixedPieces[i]);
	        }

	        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	        this._weekdaysShortRegex = this._weekdaysRegex;
	        this._weekdaysMinRegex = this._weekdaysRegex;

	        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
	    }

	    // FORMATTING

	    function hFormat() {
	        return this.hours() % 12 || 12;
	    }

	    function kFormat() {
	        return this.hours() || 24;
	    }

	    addFormatToken('H', ['HH', 2], 0, 'hour');
	    addFormatToken('h', ['hh', 2], 0, hFormat);
	    addFormatToken('k', ['kk', 2], 0, kFormat);

	    addFormatToken('hmm', 0, 0, function () {
	        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	    });

	    addFormatToken('hmmss', 0, 0, function () {
	        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
	            zeroFill(this.seconds(), 2);
	    });

	    addFormatToken('Hmm', 0, 0, function () {
	        return '' + this.hours() + zeroFill(this.minutes(), 2);
	    });

	    addFormatToken('Hmmss', 0, 0, function () {
	        return '' + this.hours() + zeroFill(this.minutes(), 2) +
	            zeroFill(this.seconds(), 2);
	    });

	    function meridiem (token, lowercase) {
	        addFormatToken(token, 0, 0, function () {
	            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	        });
	    }

	    meridiem('a', true);
	    meridiem('A', false);

	    // ALIASES

	    addUnitAlias('hour', 'h');

	    // PRIORITY
	    addUnitPriority('hour', 13);

	    // PARSING

	    function matchMeridiem (isStrict, locale) {
	        return locale._meridiemParse;
	    }

	    addRegexToken('a',  matchMeridiem);
	    addRegexToken('A',  matchMeridiem);
	    addRegexToken('H',  match1to2);
	    addRegexToken('h',  match1to2);
	    addRegexToken('HH', match1to2, match2);
	    addRegexToken('hh', match1to2, match2);

	    addRegexToken('hmm', match3to4);
	    addRegexToken('hmmss', match5to6);
	    addRegexToken('Hmm', match3to4);
	    addRegexToken('Hmmss', match5to6);

	    addParseToken(['H', 'HH'], HOUR);
	    addParseToken(['a', 'A'], function (input, array, config) {
	        config._isPm = config._locale.isPM(input);
	        config._meridiem = input;
	    });
	    addParseToken(['h', 'hh'], function (input, array, config) {
	        array[HOUR] = toInt(input);
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmm', function (input, array, config) {
	        var pos = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos));
	        array[MINUTE] = toInt(input.substr(pos));
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmmss', function (input, array, config) {
	        var pos1 = input.length - 4;
	        var pos2 = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos1));
	        array[MINUTE] = toInt(input.substr(pos1, 2));
	        array[SECOND] = toInt(input.substr(pos2));
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('Hmm', function (input, array, config) {
	        var pos = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos));
	        array[MINUTE] = toInt(input.substr(pos));
	    });
	    addParseToken('Hmmss', function (input, array, config) {
	        var pos1 = input.length - 4;
	        var pos2 = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos1));
	        array[MINUTE] = toInt(input.substr(pos1, 2));
	        array[SECOND] = toInt(input.substr(pos2));
	    });

	    // LOCALES

	    function localeIsPM (input) {
	        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	        // Using charAt should be more compatible.
	        return ((input + '').toLowerCase().charAt(0) === 'p');
	    }

	    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	    function localeMeridiem (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'pm' : 'PM';
	        } else {
	            return isLower ? 'am' : 'AM';
	        }
	    }


	    // MOMENTS

	    // Setting the hour should keep the time, because the user explicitly
	    // specified which hour he wants. So trying to maintain the same hour (in
	    // a new timezone) makes sense. Adding/subtracting hours does not follow
	    // this rule.
	    var getSetHour = makeGetSet('Hours', true);

	    var baseConfig = {
	        calendar: defaultCalendar,
	        longDateFormat: defaultLongDateFormat,
	        invalidDate: defaultInvalidDate,
	        ordinal: defaultOrdinal,
	        ordinalParse: defaultOrdinalParse,
	        relativeTime: defaultRelativeTime,

	        months: defaultLocaleMonths,
	        monthsShort: defaultLocaleMonthsShort,

	        week: defaultLocaleWeek,

	        weekdays: defaultLocaleWeekdays,
	        weekdaysMin: defaultLocaleWeekdaysMin,
	        weekdaysShort: defaultLocaleWeekdaysShort,

	        meridiemParse: defaultLocaleMeridiemParse
	    };

	    // internal storage for locale config files
	    var locales = {};
	    var globalLocale;

	    function normalizeLocale(key) {
	        return key ? key.toLowerCase().replace('_', '-') : key;
	    }

	    // pick the locale from the array
	    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	    function chooseLocale(names) {
	        var i = 0, j, next, locale, split;

	        while (i < names.length) {
	            split = normalizeLocale(names[i]).split('-');
	            j = split.length;
	            next = normalizeLocale(names[i + 1]);
	            next = next ? next.split('-') : null;
	            while (j > 0) {
	                locale = loadLocale(split.slice(0, j).join('-'));
	                if (locale) {
	                    return locale;
	                }
	                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                    //the next array item is better than a shallower substring of this one
	                    break;
	                }
	                j--;
	            }
	            i++;
	        }
	        return null;
	    }

	    function loadLocale(name) {
	        var oldLocale = null;
	        // TODO: Find a better way to register and load all the locales in Node
	        if (!locales[name] && (typeof module !== 'undefined') &&
	                module && module.exports) {
	            try {
	                oldLocale = globalLocale._abbr;
	                __webpack_require__(196)("./" + name);
	                // because defineLocale currently also sets the global locale, we
	                // want to undo that for lazy loaded locales
	                locale_locales__getSetGlobalLocale(oldLocale);
	            } catch (e) { }
	        }
	        return locales[name];
	    }

	    // This function will load locale and then set the global locale.  If
	    // no arguments are passed in, it will simply return the current global
	    // locale key.
	    function locale_locales__getSetGlobalLocale (key, values) {
	        var data;
	        if (key) {
	            if (isUndefined(values)) {
	                data = locale_locales__getLocale(key);
	            }
	            else {
	                data = defineLocale(key, values);
	            }

	            if (data) {
	                // moment.duration._locale = moment._locale = data;
	                globalLocale = data;
	            }
	        }

	        return globalLocale._abbr;
	    }

	    function defineLocale (name, config) {
	        if (config !== null) {
	            var parentConfig = baseConfig;
	            config.abbr = name;
	            if (locales[name] != null) {
	                deprecateSimple('defineLocaleOverride',
	                        'use moment.updateLocale(localeName, config) to change ' +
	                        'an existing locale. moment.defineLocale(localeName, ' +
	                        'config) should only be used for creating a new locale ' +
	                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
	                parentConfig = locales[name]._config;
	            } else if (config.parentLocale != null) {
	                if (locales[config.parentLocale] != null) {
	                    parentConfig = locales[config.parentLocale]._config;
	                } else {
	                    // treat as if there is no base config
	                    deprecateSimple('parentLocaleUndefined',
	                            'specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/');
	                }
	            }
	            locales[name] = new Locale(mergeConfigs(parentConfig, config));

	            // backwards compat for now: also set the locale
	            locale_locales__getSetGlobalLocale(name);

	            return locales[name];
	        } else {
	            // useful for testing
	            delete locales[name];
	            return null;
	        }
	    }

	    function updateLocale(name, config) {
	        if (config != null) {
	            var locale, parentConfig = baseConfig;
	            // MERGE
	            if (locales[name] != null) {
	                parentConfig = locales[name]._config;
	            }
	            config = mergeConfigs(parentConfig, config);
	            locale = new Locale(config);
	            locale.parentLocale = locales[name];
	            locales[name] = locale;

	            // backwards compat for now: also set the locale
	            locale_locales__getSetGlobalLocale(name);
	        } else {
	            // pass null for config to unupdate, useful for tests
	            if (locales[name] != null) {
	                if (locales[name].parentLocale != null) {
	                    locales[name] = locales[name].parentLocale;
	                } else if (locales[name] != null) {
	                    delete locales[name];
	                }
	            }
	        }
	        return locales[name];
	    }

	    // returns locale data
	    function locale_locales__getLocale (key) {
	        var locale;

	        if (key && key._locale && key._locale._abbr) {
	            key = key._locale._abbr;
	        }

	        if (!key) {
	            return globalLocale;
	        }

	        if (!isArray(key)) {
	            //short-circuit everything else
	            locale = loadLocale(key);
	            if (locale) {
	                return locale;
	            }
	            key = [key];
	        }

	        return chooseLocale(key);
	    }

	    function locale_locales__listLocales() {
	        return keys(locales);
	    }

	    function checkOverflow (m) {
	        var overflow;
	        var a = m._a;

	        if (a && getParsingFlags(m).overflow === -2) {
	            overflow =
	                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
	                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
	                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
	                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
	                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
	                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
	                -1;

	            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	                overflow = DATE;
	            }
	            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
	                overflow = WEEK;
	            }
	            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
	                overflow = WEEKDAY;
	            }

	            getParsingFlags(m).overflow = overflow;
	        }

	        return m;
	    }

	    // iso 8601 regex
	    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
	    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

	    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

	    var isoDates = [
	        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
	        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
	        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
	        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
	        ['YYYY-DDD', /\d{4}-\d{3}/],
	        ['YYYY-MM', /\d{4}-\d\d/, false],
	        ['YYYYYYMMDD', /[+-]\d{10}/],
	        ['YYYYMMDD', /\d{8}/],
	        // YYYYMM is NOT allowed by the standard
	        ['GGGG[W]WWE', /\d{4}W\d{3}/],
	        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
	        ['YYYYDDD', /\d{7}/]
	    ];

	    // iso time formats and regexes
	    var isoTimes = [
	        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
	        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
	        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
	        ['HH:mm', /\d\d:\d\d/],
	        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
	        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
	        ['HHmmss', /\d\d\d\d\d\d/],
	        ['HHmm', /\d\d\d\d/],
	        ['HH', /\d\d/]
	    ];

	    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

	    // date from iso format
	    function configFromISO(config) {
	        var i, l,
	            string = config._i,
	            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	            allowTime, dateFormat, timeFormat, tzFormat;

	        if (match) {
	            getParsingFlags(config).iso = true;

	            for (i = 0, l = isoDates.length; i < l; i++) {
	                if (isoDates[i][1].exec(match[1])) {
	                    dateFormat = isoDates[i][0];
	                    allowTime = isoDates[i][2] !== false;
	                    break;
	                }
	            }
	            if (dateFormat == null) {
	                config._isValid = false;
	                return;
	            }
	            if (match[3]) {
	                for (i = 0, l = isoTimes.length; i < l; i++) {
	                    if (isoTimes[i][1].exec(match[3])) {
	                        // match[2] should be 'T' or space
	                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
	                        break;
	                    }
	                }
	                if (timeFormat == null) {
	                    config._isValid = false;
	                    return;
	                }
	            }
	            if (!allowTime && timeFormat != null) {
	                config._isValid = false;
	                return;
	            }
	            if (match[4]) {
	                if (tzRegex.exec(match[4])) {
	                    tzFormat = 'Z';
	                } else {
	                    config._isValid = false;
	                    return;
	                }
	            }
	            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
	            configFromStringAndFormat(config);
	        } else {
	            config._isValid = false;
	        }
	    }

	    // date from iso format or fallback
	    function configFromString(config) {
	        var matched = aspNetJsonRegex.exec(config._i);

	        if (matched !== null) {
	            config._d = new Date(+matched[1]);
	            return;
	        }

	        configFromISO(config);
	        if (config._isValid === false) {
	            delete config._isValid;
	            utils_hooks__hooks.createFromInputFallback(config);
	        }
	    }

	    utils_hooks__hooks.createFromInputFallback = deprecate(
	        'value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' +
	        'which is not reliable across all browsers and versions. Non ISO date formats are ' +
	        'discouraged and will be removed in an upcoming major release. Please refer to ' +
	        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
	        function (config) {
	            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	        }
	    );

	    // Pick the first defined of two or three arguments.
	    function defaults(a, b, c) {
	        if (a != null) {
	            return a;
	        }
	        if (b != null) {
	            return b;
	        }
	        return c;
	    }

	    function currentDateArray(config) {
	        // hooks is actually the exported moment object
	        var nowValue = new Date(utils_hooks__hooks.now());
	        if (config._useUTC) {
	            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
	        }
	        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	    }

	    // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]
	    function configFromArray (config) {
	        var i, date, input = [], currentDate, yearToUse;

	        if (config._d) {
	            return;
	        }

	        currentDate = currentDateArray(config);

	        //compute day of the year from weeks and weekdays
	        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	            dayOfYearFromWeekInfo(config);
	        }

	        //if the day of the year is set, figure out what it is
	        if (config._dayOfYear) {
	            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

	            if (config._dayOfYear > daysInYear(yearToUse)) {
	                getParsingFlags(config)._overflowDayOfYear = true;
	            }

	            date = createUTCDate(yearToUse, 0, config._dayOfYear);
	            config._a[MONTH] = date.getUTCMonth();
	            config._a[DATE] = date.getUTCDate();
	        }

	        // Default to current date.
	        // * if no year, month, day of month are given, default to today
	        // * if day of month is given, default month and year
	        // * if month is given, default only year
	        // * if year is given, don't default anything
	        for (i = 0; i < 3 && config._a[i] == null; ++i) {
	            config._a[i] = input[i] = currentDate[i];
	        }

	        // Zero out whatever was not defaulted, including time
	        for (; i < 7; i++) {
	            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	        }

	        // Check for 24:00:00.000
	        if (config._a[HOUR] === 24 &&
	                config._a[MINUTE] === 0 &&
	                config._a[SECOND] === 0 &&
	                config._a[MILLISECOND] === 0) {
	            config._nextDay = true;
	            config._a[HOUR] = 0;
	        }

	        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	        // Apply timezone offset from input. The actual utcOffset can be changed
	        // with parseZone.
	        if (config._tzm != null) {
	            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	        }

	        if (config._nextDay) {
	            config._a[HOUR] = 24;
	        }
	    }

	    function dayOfYearFromWeekInfo(config) {
	        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

	        w = config._w;
	        if (w.GG != null || w.W != null || w.E != null) {
	            dow = 1;
	            doy = 4;

	            // TODO: We need to take the current isoWeekYear, but that depends on
	            // how we interpret now (local, utc, fixed offset). So create
	            // a now version of current config (take local/utc/offset flags, and
	            // create now).
	            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
	            week = defaults(w.W, 1);
	            weekday = defaults(w.E, 1);
	            if (weekday < 1 || weekday > 7) {
	                weekdayOverflow = true;
	            }
	        } else {
	            dow = config._locale._week.dow;
	            doy = config._locale._week.doy;

	            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
	            week = defaults(w.w, 1);

	            if (w.d != null) {
	                // weekday -- low day numbers are considered next week
	                weekday = w.d;
	                if (weekday < 0 || weekday > 6) {
	                    weekdayOverflow = true;
	                }
	            } else if (w.e != null) {
	                // local weekday -- counting starts from begining of week
	                weekday = w.e + dow;
	                if (w.e < 0 || w.e > 6) {
	                    weekdayOverflow = true;
	                }
	            } else {
	                // default to begining of week
	                weekday = dow;
	            }
	        }
	        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
	            getParsingFlags(config)._overflowWeeks = true;
	        } else if (weekdayOverflow != null) {
	            getParsingFlags(config)._overflowWeekday = true;
	        } else {
	            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	            config._a[YEAR] = temp.year;
	            config._dayOfYear = temp.dayOfYear;
	        }
	    }

	    // constant that refers to the ISO standard
	    utils_hooks__hooks.ISO_8601 = function () {};

	    // date from string and format string
	    function configFromStringAndFormat(config) {
	        // TODO: Move this to another part of the creation flow to prevent circular deps
	        if (config._f === utils_hooks__hooks.ISO_8601) {
	            configFromISO(config);
	            return;
	        }

	        config._a = [];
	        getParsingFlags(config).empty = true;

	        // This array is used to make a Date, either with `new Date` or `Date.UTC`
	        var string = '' + config._i,
	            i, parsedInput, tokens, token, skipped,
	            stringLength = string.length,
	            totalParsedInputLength = 0;

	        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

	        for (i = 0; i < tokens.length; i++) {
	            token = tokens[i];
	            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	            // console.log('token', token, 'parsedInput', parsedInput,
	            //         'regex', getParseRegexForToken(token, config));
	            if (parsedInput) {
	                skipped = string.substr(0, string.indexOf(parsedInput));
	                if (skipped.length > 0) {
	                    getParsingFlags(config).unusedInput.push(skipped);
	                }
	                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	                totalParsedInputLength += parsedInput.length;
	            }
	            // don't parse if it's not a known token
	            if (formatTokenFunctions[token]) {
	                if (parsedInput) {
	                    getParsingFlags(config).empty = false;
	                }
	                else {
	                    getParsingFlags(config).unusedTokens.push(token);
	                }
	                addTimeToArrayFromToken(token, parsedInput, config);
	            }
	            else if (config._strict && !parsedInput) {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	        }

	        // add remaining unparsed input length to the string
	        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
	        if (string.length > 0) {
	            getParsingFlags(config).unusedInput.push(string);
	        }

	        // clear _12h flag if hour is <= 12
	        if (config._a[HOUR] <= 12 &&
	            getParsingFlags(config).bigHour === true &&
	            config._a[HOUR] > 0) {
	            getParsingFlags(config).bigHour = undefined;
	        }

	        getParsingFlags(config).parsedDateParts = config._a.slice(0);
	        getParsingFlags(config).meridiem = config._meridiem;
	        // handle meridiem
	        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

	        configFromArray(config);
	        checkOverflow(config);
	    }


	    function meridiemFixWrap (locale, hour, meridiem) {
	        var isPm;

	        if (meridiem == null) {
	            // nothing to do
	            return hour;
	        }
	        if (locale.meridiemHour != null) {
	            return locale.meridiemHour(hour, meridiem);
	        } else if (locale.isPM != null) {
	            // Fallback
	            isPm = locale.isPM(meridiem);
	            if (isPm && hour < 12) {
	                hour += 12;
	            }
	            if (!isPm && hour === 12) {
	                hour = 0;
	            }
	            return hour;
	        } else {
	            // this is not supposed to happen
	            return hour;
	        }
	    }

	    // date from string and array of format strings
	    function configFromStringAndArray(config) {
	        var tempConfig,
	            bestMoment,

	            scoreToBeat,
	            i,
	            currentScore;

	        if (config._f.length === 0) {
	            getParsingFlags(config).invalidFormat = true;
	            config._d = new Date(NaN);
	            return;
	        }

	        for (i = 0; i < config._f.length; i++) {
	            currentScore = 0;
	            tempConfig = copyConfig({}, config);
	            if (config._useUTC != null) {
	                tempConfig._useUTC = config._useUTC;
	            }
	            tempConfig._f = config._f[i];
	            configFromStringAndFormat(tempConfig);

	            if (!valid__isValid(tempConfig)) {
	                continue;
	            }

	            // if there is any input that was not parsed add a penalty for that format
	            currentScore += getParsingFlags(tempConfig).charsLeftOver;

	            //or tokens
	            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

	            getParsingFlags(tempConfig).score = currentScore;

	            if (scoreToBeat == null || currentScore < scoreToBeat) {
	                scoreToBeat = currentScore;
	                bestMoment = tempConfig;
	            }
	        }

	        extend(config, bestMoment || tempConfig);
	    }

	    function configFromObject(config) {
	        if (config._d) {
	            return;
	        }

	        var i = normalizeObjectUnits(config._i);
	        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
	            return obj && parseInt(obj, 10);
	        });

	        configFromArray(config);
	    }

	    function createFromConfig (config) {
	        var res = new Moment(checkOverflow(prepareConfig(config)));
	        if (res._nextDay) {
	            // Adding is smart enough around DST
	            res.add(1, 'd');
	            res._nextDay = undefined;
	        }

	        return res;
	    }

	    function prepareConfig (config) {
	        var input = config._i,
	            format = config._f;

	        config._locale = config._locale || locale_locales__getLocale(config._l);

	        if (input === null || (format === undefined && input === '')) {
	            return valid__createInvalid({nullInput: true});
	        }

	        if (typeof input === 'string') {
	            config._i = input = config._locale.preparse(input);
	        }

	        if (isMoment(input)) {
	            return new Moment(checkOverflow(input));
	        } else if (isArray(format)) {
	            configFromStringAndArray(config);
	        } else if (isDate(input)) {
	            config._d = input;
	        } else if (format) {
	            configFromStringAndFormat(config);
	        }  else {
	            configFromInput(config);
	        }

	        if (!valid__isValid(config)) {
	            config._d = null;
	        }

	        return config;
	    }

	    function configFromInput(config) {
	        var input = config._i;
	        if (input === undefined) {
	            config._d = new Date(utils_hooks__hooks.now());
	        } else if (isDate(input)) {
	            config._d = new Date(input.valueOf());
	        } else if (typeof input === 'string') {
	            configFromString(config);
	        } else if (isArray(input)) {
	            config._a = map(input.slice(0), function (obj) {
	                return parseInt(obj, 10);
	            });
	            configFromArray(config);
	        } else if (typeof(input) === 'object') {
	            configFromObject(config);
	        } else if (typeof(input) === 'number') {
	            // from milliseconds
	            config._d = new Date(input);
	        } else {
	            utils_hooks__hooks.createFromInputFallback(config);
	        }
	    }

	    function createLocalOrUTC (input, format, locale, strict, isUTC) {
	        var c = {};

	        if (typeof(locale) === 'boolean') {
	            strict = locale;
	            locale = undefined;
	        }

	        if ((isObject(input) && isObjectEmpty(input)) ||
	                (isArray(input) && input.length === 0)) {
	            input = undefined;
	        }
	        // object construction must be done this way.
	        // https://github.com/moment/moment/issues/1423
	        c._isAMomentObject = true;
	        c._useUTC = c._isUTC = isUTC;
	        c._l = locale;
	        c._i = input;
	        c._f = format;
	        c._strict = strict;

	        return createFromConfig(c);
	    }

	    function local__createLocal (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, false);
	    }

	    var prototypeMin = deprecate(
	        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
	        function () {
	            var other = local__createLocal.apply(null, arguments);
	            if (this.isValid() && other.isValid()) {
	                return other < this ? this : other;
	            } else {
	                return valid__createInvalid();
	            }
	        }
	    );

	    var prototypeMax = deprecate(
	        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
	        function () {
	            var other = local__createLocal.apply(null, arguments);
	            if (this.isValid() && other.isValid()) {
	                return other > this ? this : other;
	            } else {
	                return valid__createInvalid();
	            }
	        }
	    );

	    // Pick a moment m from moments so that m[fn](other) is true for all
	    // other. This relies on the function fn to be transitive.
	    //
	    // moments should either be an array of moment objects or an array, whose
	    // first element is an array of moment objects.
	    function pickBy(fn, moments) {
	        var res, i;
	        if (moments.length === 1 && isArray(moments[0])) {
	            moments = moments[0];
	        }
	        if (!moments.length) {
	            return local__createLocal();
	        }
	        res = moments[0];
	        for (i = 1; i < moments.length; ++i) {
	            if (!moments[i].isValid() || moments[i][fn](res)) {
	                res = moments[i];
	            }
	        }
	        return res;
	    }

	    // TODO: Use [].sort instead?
	    function min () {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isBefore', args);
	    }

	    function max () {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isAfter', args);
	    }

	    var now = function () {
	        return Date.now ? Date.now() : +(new Date());
	    };

	    function Duration (duration) {
	        var normalizedInput = normalizeObjectUnits(duration),
	            years = normalizedInput.year || 0,
	            quarters = normalizedInput.quarter || 0,
	            months = normalizedInput.month || 0,
	            weeks = normalizedInput.week || 0,
	            days = normalizedInput.day || 0,
	            hours = normalizedInput.hour || 0,
	            minutes = normalizedInput.minute || 0,
	            seconds = normalizedInput.second || 0,
	            milliseconds = normalizedInput.millisecond || 0;

	        // representation for dateAddRemove
	        this._milliseconds = +milliseconds +
	            seconds * 1e3 + // 1000
	            minutes * 6e4 + // 1000 * 60
	            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
	        // Because of dateAddRemove treats 24 hours as different from a
	        // day when working around DST, we need to store them separately
	        this._days = +days +
	            weeks * 7;
	        // It is impossible translate months into days without knowing
	        // which months you are are talking about, so we have to store
	        // it separately.
	        this._months = +months +
	            quarters * 3 +
	            years * 12;

	        this._data = {};

	        this._locale = locale_locales__getLocale();

	        this._bubble();
	    }

	    function isDuration (obj) {
	        return obj instanceof Duration;
	    }

	    function absRound (number) {
	        if (number < 0) {
	            return Math.round(-1 * number) * -1;
	        } else {
	            return Math.round(number);
	        }
	    }

	    // FORMATTING

	    function offset (token, separator) {
	        addFormatToken(token, 0, 0, function () {
	            var offset = this.utcOffset();
	            var sign = '+';
	            if (offset < 0) {
	                offset = -offset;
	                sign = '-';
	            }
	            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
	        });
	    }

	    offset('Z', ':');
	    offset('ZZ', '');

	    // PARSING

	    addRegexToken('Z',  matchShortOffset);
	    addRegexToken('ZZ', matchShortOffset);
	    addParseToken(['Z', 'ZZ'], function (input, array, config) {
	        config._useUTC = true;
	        config._tzm = offsetFromString(matchShortOffset, input);
	    });

	    // HELPERS

	    // timezone chunker
	    // '+10:00' > ['10',  '00']
	    // '-1530'  > ['-15', '30']
	    var chunkOffset = /([\+\-]|\d\d)/gi;

	    function offsetFromString(matcher, string) {
	        var matches = ((string || '').match(matcher) || []);
	        var chunk   = matches[matches.length - 1] || [];
	        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	        var minutes = +(parts[1] * 60) + toInt(parts[2]);

	        return parts[0] === '+' ? minutes : -minutes;
	    }

	    // Return a moment from input, that is local/utc/zone equivalent to model.
	    function cloneWithOffset(input, model) {
	        var res, diff;
	        if (model._isUTC) {
	            res = model.clone();
	            diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
	            // Use low-level api, because this fn is low-level api.
	            res._d.setTime(res._d.valueOf() + diff);
	            utils_hooks__hooks.updateOffset(res, false);
	            return res;
	        } else {
	            return local__createLocal(input).local();
	        }
	    }

	    function getDateOffset (m) {
	        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	        // https://github.com/moment/moment/pull/1871
	        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	    }

	    // HOOKS

	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.
	    utils_hooks__hooks.updateOffset = function () {};

	    // MOMENTS

	    // keepLocalTime = true means only change the timezone, without
	    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	    // +0200, so we adjust the time as needed, to be valid.
	    //
	    // Keeping the time actually adds/subtracts (one hour)
	    // from the actual represented time. That is why we call updateOffset
	    // a second time. In case it wants us to change the offset again
	    // _changeInProgress == true case, then we have to adjust, because
	    // there is no such time in the given timezone.
	    function getSetOffset (input, keepLocalTime) {
	        var offset = this._offset || 0,
	            localAdjust;
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        if (input != null) {
	            if (typeof input === 'string') {
	                input = offsetFromString(matchShortOffset, input);
	            } else if (Math.abs(input) < 16) {
	                input = input * 60;
	            }
	            if (!this._isUTC && keepLocalTime) {
	                localAdjust = getDateOffset(this);
	            }
	            this._offset = input;
	            this._isUTC = true;
	            if (localAdjust != null) {
	                this.add(localAdjust, 'm');
	            }
	            if (offset !== input) {
	                if (!keepLocalTime || this._changeInProgress) {
	                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
	                } else if (!this._changeInProgress) {
	                    this._changeInProgress = true;
	                    utils_hooks__hooks.updateOffset(this, true);
	                    this._changeInProgress = null;
	                }
	            }
	            return this;
	        } else {
	            return this._isUTC ? offset : getDateOffset(this);
	        }
	    }

	    function getSetZone (input, keepLocalTime) {
	        if (input != null) {
	            if (typeof input !== 'string') {
	                input = -input;
	            }

	            this.utcOffset(input, keepLocalTime);

	            return this;
	        } else {
	            return -this.utcOffset();
	        }
	    }

	    function setOffsetToUTC (keepLocalTime) {
	        return this.utcOffset(0, keepLocalTime);
	    }

	    function setOffsetToLocal (keepLocalTime) {
	        if (this._isUTC) {
	            this.utcOffset(0, keepLocalTime);
	            this._isUTC = false;

	            if (keepLocalTime) {
	                this.subtract(getDateOffset(this), 'm');
	            }
	        }
	        return this;
	    }

	    function setOffsetToParsedOffset () {
	        if (this._tzm) {
	            this.utcOffset(this._tzm);
	        } else if (typeof this._i === 'string') {
	            var tZone = offsetFromString(matchOffset, this._i);

	            if (tZone === 0) {
	                this.utcOffset(0, true);
	            } else {
	                this.utcOffset(offsetFromString(matchOffset, this._i));
	            }
	        }
	        return this;
	    }

	    function hasAlignedHourOffset (input) {
	        if (!this.isValid()) {
	            return false;
	        }
	        input = input ? local__createLocal(input).utcOffset() : 0;

	        return (this.utcOffset() - input) % 60 === 0;
	    }

	    function isDaylightSavingTime () {
	        return (
	            this.utcOffset() > this.clone().month(0).utcOffset() ||
	            this.utcOffset() > this.clone().month(5).utcOffset()
	        );
	    }

	    function isDaylightSavingTimeShifted () {
	        if (!isUndefined(this._isDSTShifted)) {
	            return this._isDSTShifted;
	        }

	        var c = {};

	        copyConfig(c, this);
	        c = prepareConfig(c);

	        if (c._a) {
	            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
	            this._isDSTShifted = this.isValid() &&
	                compareArrays(c._a, other.toArray()) > 0;
	        } else {
	            this._isDSTShifted = false;
	        }

	        return this._isDSTShifted;
	    }

	    function isLocal () {
	        return this.isValid() ? !this._isUTC : false;
	    }

	    function isUtcOffset () {
	        return this.isValid() ? this._isUTC : false;
	    }

	    function isUtc () {
	        return this.isValid() ? this._isUTC && this._offset === 0 : false;
	    }

	    // ASP.NET json date format regex
	    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

	    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	    // and further modified to allow for strings containing both week and day
	    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

	    function create__createDuration (input, key) {
	        var duration = input,
	            // matching against regexp is expensive, do it on demand
	            match = null,
	            sign,
	            ret,
	            diffRes;

	        if (isDuration(input)) {
	            duration = {
	                ms : input._milliseconds,
	                d  : input._days,
	                M  : input._months
	            };
	        } else if (typeof input === 'number') {
	            duration = {};
	            if (key) {
	                duration[key] = input;
	            } else {
	                duration.milliseconds = input;
	            }
	        } else if (!!(match = aspNetRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y  : 0,
	                d  : toInt(match[DATE])                         * sign,
	                h  : toInt(match[HOUR])                         * sign,
	                m  : toInt(match[MINUTE])                       * sign,
	                s  : toInt(match[SECOND])                       * sign,
	                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
	            };
	        } else if (!!(match = isoRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y : parseIso(match[2], sign),
	                M : parseIso(match[3], sign),
	                w : parseIso(match[4], sign),
	                d : parseIso(match[5], sign),
	                h : parseIso(match[6], sign),
	                m : parseIso(match[7], sign),
	                s : parseIso(match[8], sign)
	            };
	        } else if (duration == null) {// checks for null or undefined
	            duration = {};
	        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
	            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

	            duration = {};
	            duration.ms = diffRes.milliseconds;
	            duration.M = diffRes.months;
	        }

	        ret = new Duration(duration);

	        if (isDuration(input) && hasOwnProp(input, '_locale')) {
	            ret._locale = input._locale;
	        }

	        return ret;
	    }

	    create__createDuration.fn = Duration.prototype;

	    function parseIso (inp, sign) {
	        // We'd normally use ~~inp for this, but unfortunately it also
	        // converts floats to ints.
	        // inp may be undefined, so careful calling replace on it.
	        var res = inp && parseFloat(inp.replace(',', '.'));
	        // apply sign while we're at it
	        return (isNaN(res) ? 0 : res) * sign;
	    }

	    function positiveMomentsDifference(base, other) {
	        var res = {milliseconds: 0, months: 0};

	        res.months = other.month() - base.month() +
	            (other.year() - base.year()) * 12;
	        if (base.clone().add(res.months, 'M').isAfter(other)) {
	            --res.months;
	        }

	        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

	        return res;
	    }

	    function momentsDifference(base, other) {
	        var res;
	        if (!(base.isValid() && other.isValid())) {
	            return {milliseconds: 0, months: 0};
	        }

	        other = cloneWithOffset(other, base);
	        if (base.isBefore(other)) {
	            res = positiveMomentsDifference(base, other);
	        } else {
	            res = positiveMomentsDifference(other, base);
	            res.milliseconds = -res.milliseconds;
	            res.months = -res.months;
	        }

	        return res;
	    }

	    // TODO: remove 'name' arg after deprecation is removed
	    function createAdder(direction, name) {
	        return function (val, period) {
	            var dur, tmp;
	            //invert the arguments, but complain about it
	            if (period !== null && !isNaN(+period)) {
	                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
	                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
	                tmp = val; val = period; period = tmp;
	            }

	            val = typeof val === 'string' ? +val : val;
	            dur = create__createDuration(val, period);
	            add_subtract__addSubtract(this, dur, direction);
	            return this;
	        };
	    }

	    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
	        var milliseconds = duration._milliseconds,
	            days = absRound(duration._days),
	            months = absRound(duration._months);

	        if (!mom.isValid()) {
	            // No op
	            return;
	        }

	        updateOffset = updateOffset == null ? true : updateOffset;

	        if (milliseconds) {
	            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
	        }
	        if (days) {
	            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
	        }
	        if (months) {
	            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
	        }
	        if (updateOffset) {
	            utils_hooks__hooks.updateOffset(mom, days || months);
	        }
	    }

	    var add_subtract__add      = createAdder(1, 'add');
	    var add_subtract__subtract = createAdder(-1, 'subtract');

	    function getCalendarFormat(myMoment, now) {
	        var diff = myMoment.diff(now, 'days', true);
	        return diff < -6 ? 'sameElse' :
	                diff < -1 ? 'lastWeek' :
	                diff < 0 ? 'lastDay' :
	                diff < 1 ? 'sameDay' :
	                diff < 2 ? 'nextDay' :
	                diff < 7 ? 'nextWeek' : 'sameElse';
	    }

	    function moment_calendar__calendar (time, formats) {
	        // We want to compare the start of today, vs this.
	        // Getting start-of-today depends on whether we're local/utc/offset or not.
	        var now = time || local__createLocal(),
	            sod = cloneWithOffset(now, this).startOf('day'),
	            format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';

	        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

	        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
	    }

	    function clone () {
	        return new Moment(this);
	    }

	    function isAfter (input, units) {
	        var localInput = isMoment(input) ? input : local__createLocal(input);
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	        if (units === 'millisecond') {
	            return this.valueOf() > localInput.valueOf();
	        } else {
	            return localInput.valueOf() < this.clone().startOf(units).valueOf();
	        }
	    }

	    function isBefore (input, units) {
	        var localInput = isMoment(input) ? input : local__createLocal(input);
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	        if (units === 'millisecond') {
	            return this.valueOf() < localInput.valueOf();
	        } else {
	            return this.clone().endOf(units).valueOf() < localInput.valueOf();
	        }
	    }

	    function isBetween (from, to, units, inclusivity) {
	        inclusivity = inclusivity || '()';
	        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
	            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
	    }

	    function isSame (input, units) {
	        var localInput = isMoment(input) ? input : local__createLocal(input),
	            inputMs;
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(units || 'millisecond');
	        if (units === 'millisecond') {
	            return this.valueOf() === localInput.valueOf();
	        } else {
	            inputMs = localInput.valueOf();
	            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
	        }
	    }

	    function isSameOrAfter (input, units) {
	        return this.isSame(input, units) || this.isAfter(input,units);
	    }

	    function isSameOrBefore (input, units) {
	        return this.isSame(input, units) || this.isBefore(input,units);
	    }

	    function diff (input, units, asFloat) {
	        var that,
	            zoneDelta,
	            delta, output;

	        if (!this.isValid()) {
	            return NaN;
	        }

	        that = cloneWithOffset(input, this);

	        if (!that.isValid()) {
	            return NaN;
	        }

	        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

	        units = normalizeUnits(units);

	        if (units === 'year' || units === 'month' || units === 'quarter') {
	            output = monthDiff(this, that);
	            if (units === 'quarter') {
	                output = output / 3;
	            } else if (units === 'year') {
	                output = output / 12;
	            }
	        } else {
	            delta = this - that;
	            output = units === 'second' ? delta / 1e3 : // 1000
	                units === 'minute' ? delta / 6e4 : // 1000 * 60
	                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
	                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	                delta;
	        }
	        return asFloat ? output : absFloor(output);
	    }

	    function monthDiff (a, b) {
	        // difference in months
	        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	            // b is in (anchor - 1 month, anchor + 1 month)
	            anchor = a.clone().add(wholeMonthDiff, 'months'),
	            anchor2, adjust;

	        if (b - anchor < 0) {
	            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor - anchor2);
	        } else {
	            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor2 - anchor);
	        }

	        //check for negative zero, return zero if negative zero
	        return -(wholeMonthDiff + adjust) || 0;
	    }

	    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
	    utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

	    function toString () {
	        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	    }

	    function moment_format__toISOString () {
	        var m = this.clone().utc();
	        if (0 < m.year() && m.year() <= 9999) {
	            if (isFunction(Date.prototype.toISOString)) {
	                // native implementation is ~50x faster, use it when we can
	                return this.toDate().toISOString();
	            } else {
	                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	            }
	        } else {
	            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	        }
	    }

	    function format (inputString) {
	        if (!inputString) {
	            inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
	        }
	        var output = formatMoment(this, inputString);
	        return this.localeData().postformat(output);
	    }

	    function from (time, withoutSuffix) {
	        if (this.isValid() &&
	                ((isMoment(time) && time.isValid()) ||
	                 local__createLocal(time).isValid())) {
	            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	        } else {
	            return this.localeData().invalidDate();
	        }
	    }

	    function fromNow (withoutSuffix) {
	        return this.from(local__createLocal(), withoutSuffix);
	    }

	    function to (time, withoutSuffix) {
	        if (this.isValid() &&
	                ((isMoment(time) && time.isValid()) ||
	                 local__createLocal(time).isValid())) {
	            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
	        } else {
	            return this.localeData().invalidDate();
	        }
	    }

	    function toNow (withoutSuffix) {
	        return this.to(local__createLocal(), withoutSuffix);
	    }

	    // If passed a locale key, it will set the locale for this
	    // instance.  Otherwise, it will return the locale configuration
	    // variables for this instance.
	    function locale (key) {
	        var newLocaleData;

	        if (key === undefined) {
	            return this._locale._abbr;
	        } else {
	            newLocaleData = locale_locales__getLocale(key);
	            if (newLocaleData != null) {
	                this._locale = newLocaleData;
	            }
	            return this;
	        }
	    }

	    var lang = deprecate(
	        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	        function (key) {
	            if (key === undefined) {
	                return this.localeData();
	            } else {
	                return this.locale(key);
	            }
	        }
	    );

	    function localeData () {
	        return this._locale;
	    }

	    function startOf (units) {
	        units = normalizeUnits(units);
	        // the following switch intentionally omits break keywords
	        // to utilize falling through the cases.
	        switch (units) {
	            case 'year':
	                this.month(0);
	                /* falls through */
	            case 'quarter':
	            case 'month':
	                this.date(1);
	                /* falls through */
	            case 'week':
	            case 'isoWeek':
	            case 'day':
	            case 'date':
	                this.hours(0);
	                /* falls through */
	            case 'hour':
	                this.minutes(0);
	                /* falls through */
	            case 'minute':
	                this.seconds(0);
	                /* falls through */
	            case 'second':
	                this.milliseconds(0);
	        }

	        // weeks are a special case
	        if (units === 'week') {
	            this.weekday(0);
	        }
	        if (units === 'isoWeek') {
	            this.isoWeekday(1);
	        }

	        // quarters are also special
	        if (units === 'quarter') {
	            this.month(Math.floor(this.month() / 3) * 3);
	        }

	        return this;
	    }

	    function endOf (units) {
	        units = normalizeUnits(units);
	        if (units === undefined || units === 'millisecond') {
	            return this;
	        }

	        // 'date' is an alias for 'day', so it should be considered as such.
	        if (units === 'date') {
	            units = 'day';
	        }

	        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
	    }

	    function to_type__valueOf () {
	        return this._d.valueOf() - ((this._offset || 0) * 60000);
	    }

	    function unix () {
	        return Math.floor(this.valueOf() / 1000);
	    }

	    function toDate () {
	        return new Date(this.valueOf());
	    }

	    function toArray () {
	        var m = this;
	        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	    }

	    function toObject () {
	        var m = this;
	        return {
	            years: m.year(),
	            months: m.month(),
	            date: m.date(),
	            hours: m.hours(),
	            minutes: m.minutes(),
	            seconds: m.seconds(),
	            milliseconds: m.milliseconds()
	        };
	    }

	    function toJSON () {
	        // new Date(NaN).toJSON() === null
	        return this.isValid() ? this.toISOString() : null;
	    }

	    function moment_valid__isValid () {
	        return valid__isValid(this);
	    }

	    function parsingFlags () {
	        return extend({}, getParsingFlags(this));
	    }

	    function invalidAt () {
	        return getParsingFlags(this).overflow;
	    }

	    function creationData() {
	        return {
	            input: this._i,
	            format: this._f,
	            locale: this._locale,
	            isUTC: this._isUTC,
	            strict: this._strict
	        };
	    }

	    // FORMATTING

	    addFormatToken(0, ['gg', 2], 0, function () {
	        return this.weekYear() % 100;
	    });

	    addFormatToken(0, ['GG', 2], 0, function () {
	        return this.isoWeekYear() % 100;
	    });

	    function addWeekYearFormatToken (token, getter) {
	        addFormatToken(0, [token, token.length], 0, getter);
	    }

	    addWeekYearFormatToken('gggg',     'weekYear');
	    addWeekYearFormatToken('ggggg',    'weekYear');
	    addWeekYearFormatToken('GGGG',  'isoWeekYear');
	    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

	    // ALIASES

	    addUnitAlias('weekYear', 'gg');
	    addUnitAlias('isoWeekYear', 'GG');

	    // PRIORITY

	    addUnitPriority('weekYear', 1);
	    addUnitPriority('isoWeekYear', 1);


	    // PARSING

	    addRegexToken('G',      matchSigned);
	    addRegexToken('g',      matchSigned);
	    addRegexToken('GG',     match1to2, match2);
	    addRegexToken('gg',     match1to2, match2);
	    addRegexToken('GGGG',   match1to4, match4);
	    addRegexToken('gggg',   match1to4, match4);
	    addRegexToken('GGGGG',  match1to6, match6);
	    addRegexToken('ggggg',  match1to6, match6);

	    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
	        week[token.substr(0, 2)] = toInt(input);
	    });

	    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
	    });

	    // MOMENTS

	    function getSetWeekYear (input) {
	        return getSetWeekYearHelper.call(this,
	                input,
	                this.week(),
	                this.weekday(),
	                this.localeData()._week.dow,
	                this.localeData()._week.doy);
	    }

	    function getSetISOWeekYear (input) {
	        return getSetWeekYearHelper.call(this,
	                input, this.isoWeek(), this.isoWeekday(), 1, 4);
	    }

	    function getISOWeeksInYear () {
	        return weeksInYear(this.year(), 1, 4);
	    }

	    function getWeeksInYear () {
	        var weekInfo = this.localeData()._week;
	        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	    }

	    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	        var weeksTarget;
	        if (input == null) {
	            return weekOfYear(this, dow, doy).year;
	        } else {
	            weeksTarget = weeksInYear(input, dow, doy);
	            if (week > weeksTarget) {
	                week = weeksTarget;
	            }
	            return setWeekAll.call(this, input, week, weekday, dow, doy);
	        }
	    }

	    function setWeekAll(weekYear, week, weekday, dow, doy) {
	        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

	        this.year(date.getUTCFullYear());
	        this.month(date.getUTCMonth());
	        this.date(date.getUTCDate());
	        return this;
	    }

	    // FORMATTING

	    addFormatToken('Q', 0, 'Qo', 'quarter');

	    // ALIASES

	    addUnitAlias('quarter', 'Q');

	    // PRIORITY

	    addUnitPriority('quarter', 7);

	    // PARSING

	    addRegexToken('Q', match1);
	    addParseToken('Q', function (input, array) {
	        array[MONTH] = (toInt(input) - 1) * 3;
	    });

	    // MOMENTS

	    function getSetQuarter (input) {
	        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	    }

	    // FORMATTING

	    addFormatToken('D', ['DD', 2], 'Do', 'date');

	    // ALIASES

	    addUnitAlias('date', 'D');

	    // PRIOROITY
	    addUnitPriority('date', 9);

	    // PARSING

	    addRegexToken('D',  match1to2);
	    addRegexToken('DD', match1to2, match2);
	    addRegexToken('Do', function (isStrict, locale) {
	        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
	    });

	    addParseToken(['D', 'DD'], DATE);
	    addParseToken('Do', function (input, array) {
	        array[DATE] = toInt(input.match(match1to2)[0], 10);
	    });

	    // MOMENTS

	    var getSetDayOfMonth = makeGetSet('Date', true);

	    // FORMATTING

	    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

	    // ALIASES

	    addUnitAlias('dayOfYear', 'DDD');

	    // PRIORITY
	    addUnitPriority('dayOfYear', 4);

	    // PARSING

	    addRegexToken('DDD',  match1to3);
	    addRegexToken('DDDD', match3);
	    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	        config._dayOfYear = toInt(input);
	    });

	    // HELPERS

	    // MOMENTS

	    function getSetDayOfYear (input) {
	        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
	        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	    }

	    // FORMATTING

	    addFormatToken('m', ['mm', 2], 0, 'minute');

	    // ALIASES

	    addUnitAlias('minute', 'm');

	    // PRIORITY

	    addUnitPriority('minute', 14);

	    // PARSING

	    addRegexToken('m',  match1to2);
	    addRegexToken('mm', match1to2, match2);
	    addParseToken(['m', 'mm'], MINUTE);

	    // MOMENTS

	    var getSetMinute = makeGetSet('Minutes', false);

	    // FORMATTING

	    addFormatToken('s', ['ss', 2], 0, 'second');

	    // ALIASES

	    addUnitAlias('second', 's');

	    // PRIORITY

	    addUnitPriority('second', 15);

	    // PARSING

	    addRegexToken('s',  match1to2);
	    addRegexToken('ss', match1to2, match2);
	    addParseToken(['s', 'ss'], SECOND);

	    // MOMENTS

	    var getSetSecond = makeGetSet('Seconds', false);

	    // FORMATTING

	    addFormatToken('S', 0, 0, function () {
	        return ~~(this.millisecond() / 100);
	    });

	    addFormatToken(0, ['SS', 2], 0, function () {
	        return ~~(this.millisecond() / 10);
	    });

	    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	    addFormatToken(0, ['SSSS', 4], 0, function () {
	        return this.millisecond() * 10;
	    });
	    addFormatToken(0, ['SSSSS', 5], 0, function () {
	        return this.millisecond() * 100;
	    });
	    addFormatToken(0, ['SSSSSS', 6], 0, function () {
	        return this.millisecond() * 1000;
	    });
	    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	        return this.millisecond() * 10000;
	    });
	    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	        return this.millisecond() * 100000;
	    });
	    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	        return this.millisecond() * 1000000;
	    });


	    // ALIASES

	    addUnitAlias('millisecond', 'ms');

	    // PRIORITY

	    addUnitPriority('millisecond', 16);

	    // PARSING

	    addRegexToken('S',    match1to3, match1);
	    addRegexToken('SS',   match1to3, match2);
	    addRegexToken('SSS',  match1to3, match3);

	    var token;
	    for (token = 'SSSS'; token.length <= 9; token += 'S') {
	        addRegexToken(token, matchUnsigned);
	    }

	    function parseMs(input, array) {
	        array[MILLISECOND] = toInt(('0.' + input) * 1000);
	    }

	    for (token = 'S'; token.length <= 9; token += 'S') {
	        addParseToken(token, parseMs);
	    }
	    // MOMENTS

	    var getSetMillisecond = makeGetSet('Milliseconds', false);

	    // FORMATTING

	    addFormatToken('z',  0, 0, 'zoneAbbr');
	    addFormatToken('zz', 0, 0, 'zoneName');

	    // MOMENTS

	    function getZoneAbbr () {
	        return this._isUTC ? 'UTC' : '';
	    }

	    function getZoneName () {
	        return this._isUTC ? 'Coordinated Universal Time' : '';
	    }

	    var momentPrototype__proto = Moment.prototype;

	    momentPrototype__proto.add               = add_subtract__add;
	    momentPrototype__proto.calendar          = moment_calendar__calendar;
	    momentPrototype__proto.clone             = clone;
	    momentPrototype__proto.diff              = diff;
	    momentPrototype__proto.endOf             = endOf;
	    momentPrototype__proto.format            = format;
	    momentPrototype__proto.from              = from;
	    momentPrototype__proto.fromNow           = fromNow;
	    momentPrototype__proto.to                = to;
	    momentPrototype__proto.toNow             = toNow;
	    momentPrototype__proto.get               = stringGet;
	    momentPrototype__proto.invalidAt         = invalidAt;
	    momentPrototype__proto.isAfter           = isAfter;
	    momentPrototype__proto.isBefore          = isBefore;
	    momentPrototype__proto.isBetween         = isBetween;
	    momentPrototype__proto.isSame            = isSame;
	    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
	    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
	    momentPrototype__proto.isValid           = moment_valid__isValid;
	    momentPrototype__proto.lang              = lang;
	    momentPrototype__proto.locale            = locale;
	    momentPrototype__proto.localeData        = localeData;
	    momentPrototype__proto.max               = prototypeMax;
	    momentPrototype__proto.min               = prototypeMin;
	    momentPrototype__proto.parsingFlags      = parsingFlags;
	    momentPrototype__proto.set               = stringSet;
	    momentPrototype__proto.startOf           = startOf;
	    momentPrototype__proto.subtract          = add_subtract__subtract;
	    momentPrototype__proto.toArray           = toArray;
	    momentPrototype__proto.toObject          = toObject;
	    momentPrototype__proto.toDate            = toDate;
	    momentPrototype__proto.toISOString       = moment_format__toISOString;
	    momentPrototype__proto.toJSON            = toJSON;
	    momentPrototype__proto.toString          = toString;
	    momentPrototype__proto.unix              = unix;
	    momentPrototype__proto.valueOf           = to_type__valueOf;
	    momentPrototype__proto.creationData      = creationData;

	    // Year
	    momentPrototype__proto.year       = getSetYear;
	    momentPrototype__proto.isLeapYear = getIsLeapYear;

	    // Week Year
	    momentPrototype__proto.weekYear    = getSetWeekYear;
	    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

	    // Quarter
	    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

	    // Month
	    momentPrototype__proto.month       = getSetMonth;
	    momentPrototype__proto.daysInMonth = getDaysInMonth;

	    // Week
	    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
	    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
	    momentPrototype__proto.weeksInYear    = getWeeksInYear;
	    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

	    // Day
	    momentPrototype__proto.date       = getSetDayOfMonth;
	    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
	    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
	    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
	    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

	    // Hour
	    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

	    // Minute
	    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

	    // Second
	    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

	    // Millisecond
	    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

	    // Offset
	    momentPrototype__proto.utcOffset            = getSetOffset;
	    momentPrototype__proto.utc                  = setOffsetToUTC;
	    momentPrototype__proto.local                = setOffsetToLocal;
	    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
	    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
	    momentPrototype__proto.isDST                = isDaylightSavingTime;
	    momentPrototype__proto.isLocal              = isLocal;
	    momentPrototype__proto.isUtcOffset          = isUtcOffset;
	    momentPrototype__proto.isUtc                = isUtc;
	    momentPrototype__proto.isUTC                = isUtc;

	    // Timezone
	    momentPrototype__proto.zoneAbbr = getZoneAbbr;
	    momentPrototype__proto.zoneName = getZoneName;

	    // Deprecations
	    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
	    momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

	    var momentPrototype = momentPrototype__proto;

	    function moment__createUnix (input) {
	        return local__createLocal(input * 1000);
	    }

	    function moment__createInZone () {
	        return local__createLocal.apply(null, arguments).parseZone();
	    }

	    function preParsePostFormat (string) {
	        return string;
	    }

	    var prototype__proto = Locale.prototype;

	    prototype__proto.calendar        = locale_calendar__calendar;
	    prototype__proto.longDateFormat  = longDateFormat;
	    prototype__proto.invalidDate     = invalidDate;
	    prototype__proto.ordinal         = ordinal;
	    prototype__proto.preparse        = preParsePostFormat;
	    prototype__proto.postformat      = preParsePostFormat;
	    prototype__proto.relativeTime    = relative__relativeTime;
	    prototype__proto.pastFuture      = pastFuture;
	    prototype__proto.set             = locale_set__set;

	    // Month
	    prototype__proto.months            =        localeMonths;
	    prototype__proto.monthsShort       =        localeMonthsShort;
	    prototype__proto.monthsParse       =        localeMonthsParse;
	    prototype__proto.monthsRegex       = monthsRegex;
	    prototype__proto.monthsShortRegex  = monthsShortRegex;

	    // Week
	    prototype__proto.week = localeWeek;
	    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
	    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

	    // Day of Week
	    prototype__proto.weekdays       =        localeWeekdays;
	    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
	    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
	    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

	    prototype__proto.weekdaysRegex       =        weekdaysRegex;
	    prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;
	    prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;

	    // Hours
	    prototype__proto.isPM = localeIsPM;
	    prototype__proto.meridiem = localeMeridiem;

	    function lists__get (format, index, field, setter) {
	        var locale = locale_locales__getLocale();
	        var utc = create_utc__createUTC().set(setter, index);
	        return locale[field](utc, format);
	    }

	    function listMonthsImpl (format, index, field) {
	        if (typeof format === 'number') {
	            index = format;
	            format = undefined;
	        }

	        format = format || '';

	        if (index != null) {
	            return lists__get(format, index, field, 'month');
	        }

	        var i;
	        var out = [];
	        for (i = 0; i < 12; i++) {
	            out[i] = lists__get(format, i, field, 'month');
	        }
	        return out;
	    }

	    // ()
	    // (5)
	    // (fmt, 5)
	    // (fmt)
	    // (true)
	    // (true, 5)
	    // (true, fmt, 5)
	    // (true, fmt)
	    function listWeekdaysImpl (localeSorted, format, index, field) {
	        if (typeof localeSorted === 'boolean') {
	            if (typeof format === 'number') {
	                index = format;
	                format = undefined;
	            }

	            format = format || '';
	        } else {
	            format = localeSorted;
	            index = format;
	            localeSorted = false;

	            if (typeof format === 'number') {
	                index = format;
	                format = undefined;
	            }

	            format = format || '';
	        }

	        var locale = locale_locales__getLocale(),
	            shift = localeSorted ? locale._week.dow : 0;

	        if (index != null) {
	            return lists__get(format, (index + shift) % 7, field, 'day');
	        }

	        var i;
	        var out = [];
	        for (i = 0; i < 7; i++) {
	            out[i] = lists__get(format, (i + shift) % 7, field, 'day');
	        }
	        return out;
	    }

	    function lists__listMonths (format, index) {
	        return listMonthsImpl(format, index, 'months');
	    }

	    function lists__listMonthsShort (format, index) {
	        return listMonthsImpl(format, index, 'monthsShort');
	    }

	    function lists__listWeekdays (localeSorted, format, index) {
	        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
	    }

	    function lists__listWeekdaysShort (localeSorted, format, index) {
	        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
	    }

	    function lists__listWeekdaysMin (localeSorted, format, index) {
	        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
	    }

	    locale_locales__getSetGlobalLocale('en', {
	        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (toInt(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });

	    // Side effect imports
	    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
	    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

	    var mathAbs = Math.abs;

	    function duration_abs__abs () {
	        var data           = this._data;

	        this._milliseconds = mathAbs(this._milliseconds);
	        this._days         = mathAbs(this._days);
	        this._months       = mathAbs(this._months);

	        data.milliseconds  = mathAbs(data.milliseconds);
	        data.seconds       = mathAbs(data.seconds);
	        data.minutes       = mathAbs(data.minutes);
	        data.hours         = mathAbs(data.hours);
	        data.months        = mathAbs(data.months);
	        data.years         = mathAbs(data.years);

	        return this;
	    }

	    function duration_add_subtract__addSubtract (duration, input, value, direction) {
	        var other = create__createDuration(input, value);

	        duration._milliseconds += direction * other._milliseconds;
	        duration._days         += direction * other._days;
	        duration._months       += direction * other._months;

	        return duration._bubble();
	    }

	    // supports only 2.0-style add(1, 's') or add(duration)
	    function duration_add_subtract__add (input, value) {
	        return duration_add_subtract__addSubtract(this, input, value, 1);
	    }

	    // supports only 2.0-style subtract(1, 's') or subtract(duration)
	    function duration_add_subtract__subtract (input, value) {
	        return duration_add_subtract__addSubtract(this, input, value, -1);
	    }

	    function absCeil (number) {
	        if (number < 0) {
	            return Math.floor(number);
	        } else {
	            return Math.ceil(number);
	        }
	    }

	    function bubble () {
	        var milliseconds = this._milliseconds;
	        var days         = this._days;
	        var months       = this._months;
	        var data         = this._data;
	        var seconds, minutes, hours, years, monthsFromDays;

	        // if we have a mix of positive and negative values, bubble down first
	        // check: https://github.com/moment/moment/issues/2166
	        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
	                (milliseconds <= 0 && days <= 0 && months <= 0))) {
	            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	            days = 0;
	            months = 0;
	        }

	        // The following code bubbles up values, see the tests for
	        // examples of what that means.
	        data.milliseconds = milliseconds % 1000;

	        seconds           = absFloor(milliseconds / 1000);
	        data.seconds      = seconds % 60;

	        minutes           = absFloor(seconds / 60);
	        data.minutes      = minutes % 60;

	        hours             = absFloor(minutes / 60);
	        data.hours        = hours % 24;

	        days += absFloor(hours / 24);

	        // convert days to months
	        monthsFromDays = absFloor(daysToMonths(days));
	        months += monthsFromDays;
	        days -= absCeil(monthsToDays(monthsFromDays));

	        // 12 months -> 1 year
	        years = absFloor(months / 12);
	        months %= 12;

	        data.days   = days;
	        data.months = months;
	        data.years  = years;

	        return this;
	    }

	    function daysToMonths (days) {
	        // 400 years have 146097 days (taking into account leap year rules)
	        // 400 years have 12 months === 4800
	        return days * 4800 / 146097;
	    }

	    function monthsToDays (months) {
	        // the reverse of daysToMonths
	        return months * 146097 / 4800;
	    }

	    function as (units) {
	        var days;
	        var months;
	        var milliseconds = this._milliseconds;

	        units = normalizeUnits(units);

	        if (units === 'month' || units === 'year') {
	            days   = this._days   + milliseconds / 864e5;
	            months = this._months + daysToMonths(days);
	            return units === 'month' ? months : months / 12;
	        } else {
	            // handle milliseconds separately because of floating point math errors (issue #1867)
	            days = this._days + Math.round(monthsToDays(this._months));
	            switch (units) {
	                case 'week'   : return days / 7     + milliseconds / 6048e5;
	                case 'day'    : return days         + milliseconds / 864e5;
	                case 'hour'   : return days * 24    + milliseconds / 36e5;
	                case 'minute' : return days * 1440  + milliseconds / 6e4;
	                case 'second' : return days * 86400 + milliseconds / 1000;
	                // Math.floor prevents floating point math errors here
	                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
	                default: throw new Error('Unknown unit ' + units);
	            }
	        }
	    }

	    // TODO: Use this.as('ms')?
	    function duration_as__valueOf () {
	        return (
	            this._milliseconds +
	            this._days * 864e5 +
	            (this._months % 12) * 2592e6 +
	            toInt(this._months / 12) * 31536e6
	        );
	    }

	    function makeAs (alias) {
	        return function () {
	            return this.as(alias);
	        };
	    }

	    var asMilliseconds = makeAs('ms');
	    var asSeconds      = makeAs('s');
	    var asMinutes      = makeAs('m');
	    var asHours        = makeAs('h');
	    var asDays         = makeAs('d');
	    var asWeeks        = makeAs('w');
	    var asMonths       = makeAs('M');
	    var asYears        = makeAs('y');

	    function duration_get__get (units) {
	        units = normalizeUnits(units);
	        return this[units + 's']();
	    }

	    function makeGetter(name) {
	        return function () {
	            return this._data[name];
	        };
	    }

	    var milliseconds = makeGetter('milliseconds');
	    var seconds      = makeGetter('seconds');
	    var minutes      = makeGetter('minutes');
	    var hours        = makeGetter('hours');
	    var days         = makeGetter('days');
	    var months       = makeGetter('months');
	    var years        = makeGetter('years');

	    function weeks () {
	        return absFloor(this.days() / 7);
	    }

	    var round = Math.round;
	    var thresholds = {
	        s: 45,  // seconds to minute
	        m: 45,  // minutes to hour
	        h: 22,  // hours to day
	        d: 26,  // days to month
	        M: 11   // months to year
	    };

	    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }

	    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
	        var duration = create__createDuration(posNegDuration).abs();
	        var seconds  = round(duration.as('s'));
	        var minutes  = round(duration.as('m'));
	        var hours    = round(duration.as('h'));
	        var days     = round(duration.as('d'));
	        var months   = round(duration.as('M'));
	        var years    = round(duration.as('y'));

	        var a = seconds < thresholds.s && ['s', seconds]  ||
	                minutes <= 1           && ['m']           ||
	                minutes < thresholds.m && ['mm', minutes] ||
	                hours   <= 1           && ['h']           ||
	                hours   < thresholds.h && ['hh', hours]   ||
	                days    <= 1           && ['d']           ||
	                days    < thresholds.d && ['dd', days]    ||
	                months  <= 1           && ['M']           ||
	                months  < thresholds.M && ['MM', months]  ||
	                years   <= 1           && ['y']           || ['yy', years];

	        a[2] = withoutSuffix;
	        a[3] = +posNegDuration > 0;
	        a[4] = locale;
	        return substituteTimeAgo.apply(null, a);
	    }

	    // This function allows you to set the rounding function for relative time strings
	    function duration_humanize__getSetRelativeTimeRounding (roundingFunction) {
	        if (roundingFunction === undefined) {
	            return round;
	        }
	        if (typeof(roundingFunction) === 'function') {
	            round = roundingFunction;
	            return true;
	        }
	        return false;
	    }

	    // This function allows you to set a threshold for relative time strings
	    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
	        if (thresholds[threshold] === undefined) {
	            return false;
	        }
	        if (limit === undefined) {
	            return thresholds[threshold];
	        }
	        thresholds[threshold] = limit;
	        return true;
	    }

	    function humanize (withSuffix) {
	        var locale = this.localeData();
	        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

	        if (withSuffix) {
	            output = locale.pastFuture(+this, output);
	        }

	        return locale.postformat(output);
	    }

	    var iso_string__abs = Math.abs;

	    function iso_string__toISOString() {
	        // for ISO strings we do not use the normal bubbling rules:
	        //  * milliseconds bubble up until they become hours
	        //  * days do not bubble at all
	        //  * months bubble up until they become years
	        // This is because there is no context-free conversion between hours and days
	        // (think of clock changes)
	        // and also not between days and months (28-31 days per month)
	        var seconds = iso_string__abs(this._milliseconds) / 1000;
	        var days         = iso_string__abs(this._days);
	        var months       = iso_string__abs(this._months);
	        var minutes, hours, years;

	        // 3600 seconds -> 60 minutes -> 1 hour
	        minutes           = absFloor(seconds / 60);
	        hours             = absFloor(minutes / 60);
	        seconds %= 60;
	        minutes %= 60;

	        // 12 months -> 1 year
	        years  = absFloor(months / 12);
	        months %= 12;


	        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	        var Y = years;
	        var M = months;
	        var D = days;
	        var h = hours;
	        var m = minutes;
	        var s = seconds;
	        var total = this.asSeconds();

	        if (!total) {
	            // this is the same as C#'s (Noda) and python (isodate)...
	            // but not other JS (goog.date)
	            return 'P0D';
	        }

	        return (total < 0 ? '-' : '') +
	            'P' +
	            (Y ? Y + 'Y' : '') +
	            (M ? M + 'M' : '') +
	            (D ? D + 'D' : '') +
	            ((h || m || s) ? 'T' : '') +
	            (h ? h + 'H' : '') +
	            (m ? m + 'M' : '') +
	            (s ? s + 'S' : '');
	    }

	    var duration_prototype__proto = Duration.prototype;

	    duration_prototype__proto.abs            = duration_abs__abs;
	    duration_prototype__proto.add            = duration_add_subtract__add;
	    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
	    duration_prototype__proto.as             = as;
	    duration_prototype__proto.asMilliseconds = asMilliseconds;
	    duration_prototype__proto.asSeconds      = asSeconds;
	    duration_prototype__proto.asMinutes      = asMinutes;
	    duration_prototype__proto.asHours        = asHours;
	    duration_prototype__proto.asDays         = asDays;
	    duration_prototype__proto.asWeeks        = asWeeks;
	    duration_prototype__proto.asMonths       = asMonths;
	    duration_prototype__proto.asYears        = asYears;
	    duration_prototype__proto.valueOf        = duration_as__valueOf;
	    duration_prototype__proto._bubble        = bubble;
	    duration_prototype__proto.get            = duration_get__get;
	    duration_prototype__proto.milliseconds   = milliseconds;
	    duration_prototype__proto.seconds        = seconds;
	    duration_prototype__proto.minutes        = minutes;
	    duration_prototype__proto.hours          = hours;
	    duration_prototype__proto.days           = days;
	    duration_prototype__proto.weeks          = weeks;
	    duration_prototype__proto.months         = months;
	    duration_prototype__proto.years          = years;
	    duration_prototype__proto.humanize       = humanize;
	    duration_prototype__proto.toISOString    = iso_string__toISOString;
	    duration_prototype__proto.toString       = iso_string__toISOString;
	    duration_prototype__proto.toJSON         = iso_string__toISOString;
	    duration_prototype__proto.locale         = locale;
	    duration_prototype__proto.localeData     = localeData;

	    // Deprecations
	    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
	    duration_prototype__proto.lang = lang;

	    // Side effect imports

	    // FORMATTING

	    addFormatToken('X', 0, 0, 'unix');
	    addFormatToken('x', 0, 0, 'valueOf');

	    // PARSING

	    addRegexToken('x', matchSigned);
	    addRegexToken('X', matchTimestamp);
	    addParseToken('X', function (input, array, config) {
	        config._d = new Date(parseFloat(input, 10) * 1000);
	    });
	    addParseToken('x', function (input, array, config) {
	        config._d = new Date(toInt(input));
	    });

	    // Side effect imports


	    utils_hooks__hooks.version = '2.15.1';

	    setHookCallback(local__createLocal);

	    utils_hooks__hooks.fn                    = momentPrototype;
	    utils_hooks__hooks.min                   = min;
	    utils_hooks__hooks.max                   = max;
	    utils_hooks__hooks.now                   = now;
	    utils_hooks__hooks.utc                   = create_utc__createUTC;
	    utils_hooks__hooks.unix                  = moment__createUnix;
	    utils_hooks__hooks.months                = lists__listMonths;
	    utils_hooks__hooks.isDate                = isDate;
	    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
	    utils_hooks__hooks.invalid               = valid__createInvalid;
	    utils_hooks__hooks.duration              = create__createDuration;
	    utils_hooks__hooks.isMoment              = isMoment;
	    utils_hooks__hooks.weekdays              = lists__listWeekdays;
	    utils_hooks__hooks.parseZone             = moment__createInZone;
	    utils_hooks__hooks.localeData            = locale_locales__getLocale;
	    utils_hooks__hooks.isDuration            = isDuration;
	    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
	    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
	    utils_hooks__hooks.defineLocale          = defineLocale;
	    utils_hooks__hooks.updateLocale          = updateLocale;
	    utils_hooks__hooks.locales               = locale_locales__listLocales;
	    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
	    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
	    utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;
	    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
	    utils_hooks__hooks.calendarFormat        = getCalendarFormat;
	    utils_hooks__hooks.prototype             = momentPrototype;

	    var _moment = utils_hooks__hooks;

	    return _moment;

	}));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)(module)))

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./af": 197,
		"./af.js": 197,
		"./ar": 198,
		"./ar-ly": 199,
		"./ar-ly.js": 199,
		"./ar-ma": 200,
		"./ar-ma.js": 200,
		"./ar-sa": 201,
		"./ar-sa.js": 201,
		"./ar-tn": 202,
		"./ar-tn.js": 202,
		"./ar.js": 198,
		"./az": 203,
		"./az.js": 203,
		"./be": 204,
		"./be.js": 204,
		"./bg": 205,
		"./bg.js": 205,
		"./bn": 206,
		"./bn.js": 206,
		"./bo": 207,
		"./bo.js": 207,
		"./br": 208,
		"./br.js": 208,
		"./bs": 209,
		"./bs.js": 209,
		"./ca": 210,
		"./ca.js": 210,
		"./cs": 211,
		"./cs.js": 211,
		"./cv": 212,
		"./cv.js": 212,
		"./cy": 213,
		"./cy.js": 213,
		"./da": 214,
		"./da.js": 214,
		"./de": 215,
		"./de-at": 216,
		"./de-at.js": 216,
		"./de.js": 215,
		"./dv": 217,
		"./dv.js": 217,
		"./el": 218,
		"./el.js": 218,
		"./en-au": 219,
		"./en-au.js": 219,
		"./en-ca": 220,
		"./en-ca.js": 220,
		"./en-gb": 221,
		"./en-gb.js": 221,
		"./en-ie": 222,
		"./en-ie.js": 222,
		"./en-nz": 223,
		"./en-nz.js": 223,
		"./eo": 224,
		"./eo.js": 224,
		"./es": 225,
		"./es-do": 226,
		"./es-do.js": 226,
		"./es.js": 225,
		"./et": 227,
		"./et.js": 227,
		"./eu": 228,
		"./eu.js": 228,
		"./fa": 229,
		"./fa.js": 229,
		"./fi": 230,
		"./fi.js": 230,
		"./fo": 231,
		"./fo.js": 231,
		"./fr": 232,
		"./fr-ca": 233,
		"./fr-ca.js": 233,
		"./fr-ch": 234,
		"./fr-ch.js": 234,
		"./fr.js": 232,
		"./fy": 235,
		"./fy.js": 235,
		"./gd": 236,
		"./gd.js": 236,
		"./gl": 237,
		"./gl.js": 237,
		"./he": 238,
		"./he.js": 238,
		"./hi": 239,
		"./hi.js": 239,
		"./hr": 240,
		"./hr.js": 240,
		"./hu": 241,
		"./hu.js": 241,
		"./hy-am": 242,
		"./hy-am.js": 242,
		"./id": 243,
		"./id.js": 243,
		"./is": 244,
		"./is.js": 244,
		"./it": 245,
		"./it.js": 245,
		"./ja": 246,
		"./ja.js": 246,
		"./jv": 247,
		"./jv.js": 247,
		"./ka": 248,
		"./ka.js": 248,
		"./kk": 249,
		"./kk.js": 249,
		"./km": 250,
		"./km.js": 250,
		"./ko": 251,
		"./ko.js": 251,
		"./ky": 252,
		"./ky.js": 252,
		"./lb": 253,
		"./lb.js": 253,
		"./lo": 254,
		"./lo.js": 254,
		"./lt": 255,
		"./lt.js": 255,
		"./lv": 256,
		"./lv.js": 256,
		"./me": 257,
		"./me.js": 257,
		"./mi": 258,
		"./mi.js": 258,
		"./mk": 259,
		"./mk.js": 259,
		"./ml": 260,
		"./ml.js": 260,
		"./mr": 261,
		"./mr.js": 261,
		"./ms": 262,
		"./ms-my": 263,
		"./ms-my.js": 263,
		"./ms.js": 262,
		"./my": 264,
		"./my.js": 264,
		"./nb": 265,
		"./nb.js": 265,
		"./ne": 266,
		"./ne.js": 266,
		"./nl": 267,
		"./nl.js": 267,
		"./nn": 268,
		"./nn.js": 268,
		"./pa-in": 269,
		"./pa-in.js": 269,
		"./pl": 270,
		"./pl.js": 270,
		"./pt": 271,
		"./pt-br": 272,
		"./pt-br.js": 272,
		"./pt.js": 271,
		"./ro": 273,
		"./ro.js": 273,
		"./ru": 274,
		"./ru.js": 274,
		"./se": 275,
		"./se.js": 275,
		"./si": 276,
		"./si.js": 276,
		"./sk": 277,
		"./sk.js": 277,
		"./sl": 278,
		"./sl.js": 278,
		"./sq": 279,
		"./sq.js": 279,
		"./sr": 280,
		"./sr-cyrl": 281,
		"./sr-cyrl.js": 281,
		"./sr.js": 280,
		"./ss": 282,
		"./ss.js": 282,
		"./sv": 283,
		"./sv.js": 283,
		"./sw": 284,
		"./sw.js": 284,
		"./ta": 285,
		"./ta.js": 285,
		"./te": 286,
		"./te.js": 286,
		"./th": 287,
		"./th.js": 287,
		"./tl-ph": 288,
		"./tl-ph.js": 288,
		"./tlh": 289,
		"./tlh.js": 289,
		"./tr": 290,
		"./tr.js": 290,
		"./tzl": 291,
		"./tzl.js": 291,
		"./tzm": 292,
		"./tzm-latn": 293,
		"./tzm-latn.js": 293,
		"./tzm.js": 292,
		"./uk": 294,
		"./uk.js": 294,
		"./uz": 295,
		"./uz.js": 295,
		"./vi": 296,
		"./vi.js": 296,
		"./x-pseudo": 297,
		"./x-pseudo.js": 297,
		"./zh-cn": 298,
		"./zh-cn.js": 298,
		"./zh-hk": 299,
		"./zh-hk.js": 299,
		"./zh-tw": 300,
		"./zh-tw.js": 300
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 196;


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Afrikaans [af]
	//! author : Werner Mollentze : https://github.com/wernerm

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var af = moment.defineLocale('af', {
	        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
	        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
	        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
	        meridiemParse: /vm|nm/i,
	        isPM : function (input) {
	            return /^nm$/i.test(input);
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower ? 'vm' : 'VM';
	            } else {
	                return isLower ? 'nm' : 'NM';
	            }
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Vandag om] LT',
	            nextDay : '[Môre om] LT',
	            nextWeek : 'dddd [om] LT',
	            lastDay : '[Gister om] LT',
	            lastWeek : '[Laas] dddd [om] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'oor %s',
	            past : '%s gelede',
	            s : '\'n paar sekondes',
	            m : '\'n minuut',
	            mm : '%d minute',
	            h : '\'n uur',
	            hh : '%d ure',
	            d : '\'n dag',
	            dd : '%d dae',
	            M : '\'n maand',
	            MM : '%d maande',
	            y : '\'n jaar',
	            yy : '%d jaar'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Röling : https://github.com/jjupiter
	        },
	        week : {
	            dow : 1, // Maandag is die eerste dag van die week.
	            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
	        }
	    });

	    return af;

	}));

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic [ar]
	//! author : Abdel Said: https://github.com/abdelsaid
	//! author : Ahmed Elkhatib
	//! author : forabi https://github.com/forabi

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '١',
	        '2': '٢',
	        '3': '٣',
	        '4': '٤',
	        '5': '٥',
	        '6': '٦',
	        '7': '٧',
	        '8': '٨',
	        '9': '٩',
	        '0': '٠'
	    }, numberMap = {
	        '١': '1',
	        '٢': '2',
	        '٣': '3',
	        '٤': '4',
	        '٥': '5',
	        '٦': '6',
	        '٧': '7',
	        '٨': '8',
	        '٩': '9',
	        '٠': '0'
	    }, pluralForm = function (n) {
	        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	    }, plurals = {
	        s : ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
	        m : ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
	        h : ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
	        d : ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
	        M : ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
	        y : ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
	    }, pluralize = function (u) {
	        return function (number, withoutSuffix, string, isFuture) {
	            var f = pluralForm(number),
	                str = plurals[u][pluralForm(number)];
	            if (f === 2) {
	                str = str[withoutSuffix ? 0 : 1];
	            }
	            return str.replace(/%d/i, number);
	        };
	    }, months = [
	        'كانون الثاني يناير',
	        'شباط فبراير',
	        'آذار مارس',
	        'نيسان أبريل',
	        'أيار مايو',
	        'حزيران يونيو',
	        'تموز يوليو',
	        'آب أغسطس',
	        'أيلول سبتمبر',
	        'تشرين الأول أكتوبر',
	        'تشرين الثاني نوفمبر',
	        'كانون الأول ديسمبر'
	    ];

	    var ar = moment.defineLocale('ar', {
	        months : months,
	        monthsShort : months,
	        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'D/\u200FM/\u200FYYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /ص|م/,
	        isPM : function (input) {
	            return 'م' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ص';
	            } else {
	                return 'م';
	            }
	        },
	        calendar : {
	            sameDay: '[اليوم عند الساعة] LT',
	            nextDay: '[غدًا عند الساعة] LT',
	            nextWeek: 'dddd [عند الساعة] LT',
	            lastDay: '[أمس عند الساعة] LT',
	            lastWeek: 'dddd [عند الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'بعد %s',
	            past : 'منذ %s',
	            s : pluralize('s'),
	            m : pluralize('m'),
	            mm : pluralize('m'),
	            h : pluralize('h'),
	            hh : pluralize('h'),
	            d : pluralize('d'),
	            dd : pluralize('d'),
	            M : pluralize('M'),
	            MM : pluralize('M'),
	            y : pluralize('y'),
	            yy : pluralize('y')
	        },
	        preparse: function (string) {
	            return string.replace(/\u200f/g, '').replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
	                return numberMap[match];
	            }).replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '،');
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ar;

	}));

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Lybia) [ar-ly]
	//! author : Ali Hmer: https://github.com/kikoanis

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '1',
	        '2': '2',
	        '3': '3',
	        '4': '4',
	        '5': '5',
	        '6': '6',
	        '7': '7',
	        '8': '8',
	        '9': '9',
	        '0': '0'
	    }, pluralForm = function (n) {
	        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	    }, plurals = {
	        s : ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
	        m : ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
	        h : ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
	        d : ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
	        M : ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
	        y : ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
	    }, pluralize = function (u) {
	        return function (number, withoutSuffix, string, isFuture) {
	            var f = pluralForm(number),
	                str = plurals[u][pluralForm(number)];
	            if (f === 2) {
	                str = str[withoutSuffix ? 0 : 1];
	            }
	            return str.replace(/%d/i, number);
	        };
	    }, months = [
	        'يناير',
	        'فبراير',
	        'مارس',
	        'أبريل',
	        'مايو',
	        'يونيو',
	        'يوليو',
	        'أغسطس',
	        'سبتمبر',
	        'أكتوبر',
	        'نوفمبر',
	        'ديسمبر'
	    ];

	    var ar_ly = moment.defineLocale('ar-ly', {
	        months : months,
	        monthsShort : months,
	        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'D/\u200FM/\u200FYYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /ص|م/,
	        isPM : function (input) {
	            return 'م' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ص';
	            } else {
	                return 'م';
	            }
	        },
	        calendar : {
	            sameDay: '[اليوم عند الساعة] LT',
	            nextDay: '[غدًا عند الساعة] LT',
	            nextWeek: 'dddd [عند الساعة] LT',
	            lastDay: '[أمس عند الساعة] LT',
	            lastWeek: 'dddd [عند الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'بعد %s',
	            past : 'منذ %s',
	            s : pluralize('s'),
	            m : pluralize('m'),
	            mm : pluralize('m'),
	            h : pluralize('h'),
	            hh : pluralize('h'),
	            d : pluralize('d'),
	            dd : pluralize('d'),
	            M : pluralize('M'),
	            MM : pluralize('M'),
	            y : pluralize('y'),
	            yy : pluralize('y')
	        },
	        preparse: function (string) {
	            return string.replace(/\u200f/g, '').replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '،');
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ar_ly;

	}));

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Morocco) [ar-ma]
	//! author : ElFadili Yassine : https://github.com/ElFadiliY
	//! author : Abdel Said : https://github.com/abdelsaid

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ar_ma = moment.defineLocale('ar-ma', {
	        months : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
	        monthsShort : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
	        weekdays : 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort : 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[اليوم على الساعة] LT',
	            nextDay: '[غدا على الساعة] LT',
	            nextWeek: 'dddd [على الساعة] LT',
	            lastDay: '[أمس على الساعة] LT',
	            lastWeek: 'dddd [على الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'في %s',
	            past : 'منذ %s',
	            s : 'ثوان',
	            m : 'دقيقة',
	            mm : '%d دقائق',
	            h : 'ساعة',
	            hh : '%d ساعات',
	            d : 'يوم',
	            dd : '%d أيام',
	            M : 'شهر',
	            MM : '%d أشهر',
	            y : 'سنة',
	            yy : '%d سنوات'
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ar_ma;

	}));

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Saudi Arabia) [ar-sa]
	//! author : Suhail Alkowaileet : https://github.com/xsoh

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '١',
	        '2': '٢',
	        '3': '٣',
	        '4': '٤',
	        '5': '٥',
	        '6': '٦',
	        '7': '٧',
	        '8': '٨',
	        '9': '٩',
	        '0': '٠'
	    }, numberMap = {
	        '١': '1',
	        '٢': '2',
	        '٣': '3',
	        '٤': '4',
	        '٥': '5',
	        '٦': '6',
	        '٧': '7',
	        '٨': '8',
	        '٩': '9',
	        '٠': '0'
	    };

	    var ar_sa = moment.defineLocale('ar-sa', {
	        months : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        monthsShort : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /ص|م/,
	        isPM : function (input) {
	            return 'م' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ص';
	            } else {
	                return 'م';
	            }
	        },
	        calendar : {
	            sameDay: '[اليوم على الساعة] LT',
	            nextDay: '[غدا على الساعة] LT',
	            nextWeek: 'dddd [على الساعة] LT',
	            lastDay: '[أمس على الساعة] LT',
	            lastWeek: 'dddd [على الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'في %s',
	            past : 'منذ %s',
	            s : 'ثوان',
	            m : 'دقيقة',
	            mm : '%d دقائق',
	            h : 'ساعة',
	            hh : '%d ساعات',
	            d : 'يوم',
	            dd : '%d أيام',
	            M : 'شهر',
	            MM : '%d أشهر',
	            y : 'سنة',
	            yy : '%d سنوات'
	        },
	        preparse: function (string) {
	            return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
	                return numberMap[match];
	            }).replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '،');
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ar_sa;

	}));

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale  :  Arabic (Tunisia) [ar-tn]
	//! author : Nader Toukabri : https://github.com/naderio

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ar_tn = moment.defineLocale('ar-tn', {
	        months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[اليوم على الساعة] LT',
	            nextDay: '[غدا على الساعة] LT',
	            nextWeek: 'dddd [على الساعة] LT',
	            lastDay: '[أمس على الساعة] LT',
	            lastWeek: 'dddd [على الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'في %s',
	            past: 'منذ %s',
	            s: 'ثوان',
	            m: 'دقيقة',
	            mm: '%d دقائق',
	            h: 'ساعة',
	            hh: '%d ساعات',
	            d: 'يوم',
	            dd: '%d أيام',
	            M: 'شهر',
	            MM: '%d أشهر',
	            y: 'سنة',
	            yy: '%d سنوات'
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return ar_tn;

	}));

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Azerbaijani [az]
	//! author : topchiyev : https://github.com/topchiyev

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var suffixes = {
	        1: '-inci',
	        5: '-inci',
	        8: '-inci',
	        70: '-inci',
	        80: '-inci',
	        2: '-nci',
	        7: '-nci',
	        20: '-nci',
	        50: '-nci',
	        3: '-üncü',
	        4: '-üncü',
	        100: '-üncü',
	        6: '-ncı',
	        9: '-uncu',
	        10: '-uncu',
	        30: '-uncu',
	        60: '-ıncı',
	        90: '-ıncı'
	    };

	    var az = moment.defineLocale('az', {
	        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
	        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
	        weekdays : 'Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə'.split('_'),
	        weekdaysShort : 'Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən'.split('_'),
	        weekdaysMin : 'Bz_BE_ÇA_Çə_CA_Cü_Şə'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[bugün saat] LT',
	            nextDay : '[sabah saat] LT',
	            nextWeek : '[gələn həftə] dddd [saat] LT',
	            lastDay : '[dünən] LT',
	            lastWeek : '[keçən həftə] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s sonra',
	            past : '%s əvvəl',
	            s : 'birneçə saniyyə',
	            m : 'bir dəqiqə',
	            mm : '%d dəqiqə',
	            h : 'bir saat',
	            hh : '%d saat',
	            d : 'bir gün',
	            dd : '%d gün',
	            M : 'bir ay',
	            MM : '%d ay',
	            y : 'bir il',
	            yy : '%d il'
	        },
	        meridiemParse: /gecə|səhər|gündüz|axşam/,
	        isPM : function (input) {
	            return /^(gündüz|axşam)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'gecə';
	            } else if (hour < 12) {
	                return 'səhər';
	            } else if (hour < 17) {
	                return 'gündüz';
	            } else {
	                return 'axşam';
	            }
	        },
	        ordinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
	        ordinal : function (number) {
	            if (number === 0) {  // special case for zero
	                return number + '-ıncı';
	            }
	            var a = number % 10,
	                b = number % 100 - a,
	                c = number >= 100 ? 100 : null;
	            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return az;

	}));

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Belarusian [be]
	//! author : Dmitry Demidov : https://github.com/demidov91
	//! author: Praleska: http://praleska.pro/
	//! Author : Menelion Elensúle : https://github.com/Oire

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? 'хвіліна_хвіліны_хвілін' : 'хвіліну_хвіліны_хвілін',
	            'hh': withoutSuffix ? 'гадзіна_гадзіны_гадзін' : 'гадзіну_гадзіны_гадзін',
	            'dd': 'дзень_дні_дзён',
	            'MM': 'месяц_месяцы_месяцаў',
	            'yy': 'год_гады_гадоў'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? 'хвіліна' : 'хвіліну';
	        }
	        else if (key === 'h') {
	            return withoutSuffix ? 'гадзіна' : 'гадзіну';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }

	    var be = moment.defineLocale('be', {
	        months : {
	            format: 'студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня'.split('_'),
	            standalone: 'студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань'.split('_')
	        },
	        monthsShort : 'студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж'.split('_'),
	        weekdays : {
	            format: 'нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу'.split('_'),
	            standalone: 'нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота'.split('_'),
	            isFormat: /\[ ?[Вв] ?(?:мінулую|наступную)? ?\] ?dddd/
	        },
	        weekdaysShort : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
	        weekdaysMin : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY г.',
	            LLL : 'D MMMM YYYY г., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY г., HH:mm'
	        },
	        calendar : {
	            sameDay: '[Сёння ў] LT',
	            nextDay: '[Заўтра ў] LT',
	            lastDay: '[Учора ў] LT',
	            nextWeek: function () {
	                return '[У] dddd [ў] LT';
	            },
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[У мінулую] dddd [ў] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[У мінулы] dddd [ў] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'праз %s',
	            past : '%s таму',
	            s : 'некалькі секунд',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : relativeTimeWithPlural,
	            hh : relativeTimeWithPlural,
	            d : 'дзень',
	            dd : relativeTimeWithPlural,
	            M : 'месяц',
	            MM : relativeTimeWithPlural,
	            y : 'год',
	            yy : relativeTimeWithPlural
	        },
	        meridiemParse: /ночы|раніцы|дня|вечара/,
	        isPM : function (input) {
	            return /^(дня|вечара)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'ночы';
	            } else if (hour < 12) {
	                return 'раніцы';
	            } else if (hour < 17) {
	                return 'дня';
	            } else {
	                return 'вечара';
	            }
	        },
	        ordinalParse: /\d{1,2}-(і|ы|га)/,
	        ordinal: function (number, period) {
	            switch (period) {
	                case 'M':
	                case 'd':
	                case 'DDD':
	                case 'w':
	                case 'W':
	                    return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-і' : number + '-ы';
	                case 'D':
	                    return number + '-га';
	                default:
	                    return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return be;

	}));

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bulgarian [bg]
	//! author : Krasen Borisov : https://github.com/kraz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var bg = moment.defineLocale('bg', {
	        months : 'януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември'.split('_'),
	        monthsShort : 'янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек'.split('_'),
	        weekdays : 'неделя_понеделник_вторник_сряда_четвъртък_петък_събота'.split('_'),
	        weekdaysShort : 'нед_пон_вто_сря_чет_пет_съб'.split('_'),
	        weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'D.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : '[Днес в] LT',
	            nextDay : '[Утре в] LT',
	            nextWeek : 'dddd [в] LT',
	            lastDay : '[Вчера в] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                    case 3:
	                    case 6:
	                        return '[В изминалата] dddd [в] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[В изминалия] dddd [в] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'след %s',
	            past : 'преди %s',
	            s : 'няколко секунди',
	            m : 'минута',
	            mm : '%d минути',
	            h : 'час',
	            hh : '%d часа',
	            d : 'ден',
	            dd : '%d дни',
	            M : 'месец',
	            MM : '%d месеца',
	            y : 'година',
	            yy : '%d години'
	        },
	        ordinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
	        ordinal : function (number) {
	            var lastDigit = number % 10,
	                last2Digits = number % 100;
	            if (number === 0) {
	                return number + '-ев';
	            } else if (last2Digits === 0) {
	                return number + '-ен';
	            } else if (last2Digits > 10 && last2Digits < 20) {
	                return number + '-ти';
	            } else if (lastDigit === 1) {
	                return number + '-ви';
	            } else if (lastDigit === 2) {
	                return number + '-ри';
	            } else if (lastDigit === 7 || lastDigit === 8) {
	                return number + '-ми';
	            } else {
	                return number + '-ти';
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return bg;

	}));

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bengali [bn]
	//! author : Kaushik Gandhi : https://github.com/kaushikgandhi

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '১',
	        '2': '২',
	        '3': '৩',
	        '4': '৪',
	        '5': '৫',
	        '6': '৬',
	        '7': '৭',
	        '8': '৮',
	        '9': '৯',
	        '0': '০'
	    },
	    numberMap = {
	        '১': '1',
	        '২': '2',
	        '৩': '3',
	        '৪': '4',
	        '৫': '5',
	        '৬': '6',
	        '৭': '7',
	        '৮': '8',
	        '৯': '9',
	        '০': '0'
	    };

	    var bn = moment.defineLocale('bn', {
	        months : 'জানুয়ারী_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split('_'),
	        monthsShort : 'জানু_ফেব_মার্চ_এপ্র_মে_জুন_জুল_আগ_সেপ্ট_অক্টো_নভে_ডিসে'.split('_'),
	        weekdays : 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার'.split('_'),
	        weekdaysShort : 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি'.split('_'),
	        weekdaysMin : 'রবি_সোম_মঙ্গ_বুধ_বৃহঃ_শুক্র_শনি'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm সময়',
	            LTS : 'A h:mm:ss সময়',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm সময়',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm সময়'
	        },
	        calendar : {
	            sameDay : '[আজ] LT',
	            nextDay : '[আগামীকাল] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[গতকাল] LT',
	            lastWeek : '[গত] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s পরে',
	            past : '%s আগে',
	            s : 'কয়েক সেকেন্ড',
	            m : 'এক মিনিট',
	            mm : '%d মিনিট',
	            h : 'এক ঘন্টা',
	            hh : '%d ঘন্টা',
	            d : 'এক দিন',
	            dd : '%d দিন',
	            M : 'এক মাস',
	            MM : '%d মাস',
	            y : 'এক বছর',
	            yy : '%d বছর'
	        },
	        preparse: function (string) {
	            return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if ((meridiem === 'রাত' && hour >= 4) ||
	                    (meridiem === 'দুপুর' && hour < 5) ||
	                    meridiem === 'বিকাল') {
	                return hour + 12;
	            } else {
	                return hour;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'রাত';
	            } else if (hour < 10) {
	                return 'সকাল';
	            } else if (hour < 17) {
	                return 'দুপুর';
	            } else if (hour < 20) {
	                return 'বিকাল';
	            } else {
	                return 'রাত';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return bn;

	}));

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tibetan [bo]
	//! author : Thupten N. Chakrishar : https://github.com/vajradog

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '༡',
	        '2': '༢',
	        '3': '༣',
	        '4': '༤',
	        '5': '༥',
	        '6': '༦',
	        '7': '༧',
	        '8': '༨',
	        '9': '༩',
	        '0': '༠'
	    },
	    numberMap = {
	        '༡': '1',
	        '༢': '2',
	        '༣': '3',
	        '༤': '4',
	        '༥': '5',
	        '༦': '6',
	        '༧': '7',
	        '༨': '8',
	        '༩': '9',
	        '༠': '0'
	    };

	    var bo = moment.defineLocale('bo', {
	        months : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
	        monthsShort : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
	        weekdays : 'གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་'.split('_'),
	        weekdaysShort : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
	        weekdaysMin : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm',
	            LTS : 'A h:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm'
	        },
	        calendar : {
	            sameDay : '[དི་རིང] LT',
	            nextDay : '[སང་ཉིན] LT',
	            nextWeek : '[བདུན་ཕྲག་རྗེས་མ], LT',
	            lastDay : '[ཁ་སང] LT',
	            lastWeek : '[བདུན་ཕྲག་མཐའ་མ] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ལ་',
	            past : '%s སྔན་ལ',
	            s : 'ལམ་སང',
	            m : 'སྐར་མ་གཅིག',
	            mm : '%d སྐར་མ',
	            h : 'ཆུ་ཚོད་གཅིག',
	            hh : '%d ཆུ་ཚོད',
	            d : 'ཉིན་གཅིག',
	            dd : '%d ཉིན་',
	            M : 'ཟླ་བ་གཅིག',
	            MM : '%d ཟླ་བ',
	            y : 'ལོ་གཅིག',
	            yy : '%d ལོ'
	        },
	        preparse: function (string) {
	            return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if ((meridiem === 'མཚན་མོ' && hour >= 4) ||
	                    (meridiem === 'ཉིན་གུང' && hour < 5) ||
	                    meridiem === 'དགོང་དག') {
	                return hour + 12;
	            } else {
	                return hour;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'མཚན་མོ';
	            } else if (hour < 10) {
	                return 'ཞོགས་ཀས';
	            } else if (hour < 17) {
	                return 'ཉིན་གུང';
	            } else if (hour < 20) {
	                return 'དགོང་དག';
	            } else {
	                return 'མཚན་མོ';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return bo;

	}));

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Breton [br]
	//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function relativeTimeWithMutation(number, withoutSuffix, key) {
	        var format = {
	            'mm': 'munutenn',
	            'MM': 'miz',
	            'dd': 'devezh'
	        };
	        return number + ' ' + mutation(format[key], number);
	    }
	    function specialMutationForYears(number) {
	        switch (lastNumber(number)) {
	            case 1:
	            case 3:
	            case 4:
	            case 5:
	            case 9:
	                return number + ' bloaz';
	            default:
	                return number + ' vloaz';
	        }
	    }
	    function lastNumber(number) {
	        if (number > 9) {
	            return lastNumber(number % 10);
	        }
	        return number;
	    }
	    function mutation(text, number) {
	        if (number === 2) {
	            return softMutation(text);
	        }
	        return text;
	    }
	    function softMutation(text) {
	        var mutationTable = {
	            'm': 'v',
	            'b': 'v',
	            'd': 'z'
	        };
	        if (mutationTable[text.charAt(0)] === undefined) {
	            return text;
	        }
	        return mutationTable[text.charAt(0)] + text.substring(1);
	    }

	    var br = moment.defineLocale('br', {
	        months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
	        monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
	        weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
	        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
	        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'h[e]mm A',
	            LTS : 'h[e]mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D [a viz] MMMM YYYY',
	            LLL : 'D [a viz] MMMM YYYY h[e]mm A',
	            LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
	        },
	        calendar : {
	            sameDay : '[Hiziv da] LT',
	            nextDay : '[Warc\'hoazh da] LT',
	            nextWeek : 'dddd [da] LT',
	            lastDay : '[Dec\'h da] LT',
	            lastWeek : 'dddd [paset da] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'a-benn %s',
	            past : '%s \'zo',
	            s : 'un nebeud segondennoù',
	            m : 'ur vunutenn',
	            mm : relativeTimeWithMutation,
	            h : 'un eur',
	            hh : '%d eur',
	            d : 'un devezh',
	            dd : relativeTimeWithMutation,
	            M : 'ur miz',
	            MM : relativeTimeWithMutation,
	            y : 'ur bloaz',
	            yy : specialMutationForYears
	        },
	        ordinalParse: /\d{1,2}(añ|vet)/,
	        ordinal : function (number) {
	            var output = (number === 1) ? 'añ' : 'vet';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return br;

	}));

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bosnian [bs]
	//! author : Nedim Cholich : https://github.com/frontyard
	//! based on (hr) translation by Bojan Marković

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	            case 'm':
	                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	            case 'mm':
	                if (number === 1) {
	                    result += 'minuta';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'minute';
	                } else {
	                    result += 'minuta';
	                }
	                return result;
	            case 'h':
	                return withoutSuffix ? 'jedan sat' : 'jednog sata';
	            case 'hh':
	                if (number === 1) {
	                    result += 'sat';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'sata';
	                } else {
	                    result += 'sati';
	                }
	                return result;
	            case 'dd':
	                if (number === 1) {
	                    result += 'dan';
	                } else {
	                    result += 'dana';
	                }
	                return result;
	            case 'MM':
	                if (number === 1) {
	                    result += 'mjesec';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'mjeseca';
	                } else {
	                    result += 'mjeseci';
	                }
	                return result;
	            case 'yy':
	                if (number === 1) {
	                    result += 'godina';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'godine';
	                } else {
	                    result += 'godina';
	                }
	                return result;
	        }
	    }

	    var bs = moment.defineLocale('bs', {
	        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
	        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
	        weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
	        weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[danas u] LT',
	            nextDay  : '[sutra u] LT',
	            nextWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[u] [nedjelju] [u] LT';
	                    case 3:
	                        return '[u] [srijedu] [u] LT';
	                    case 6:
	                        return '[u] [subotu] [u] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[jučer u] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                    case 3:
	                        return '[prošlu] dddd [u] LT';
	                    case 6:
	                        return '[prošle] [subote] [u] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[prošli] dddd [u] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'par sekundi',
	            m      : translate,
	            mm     : translate,
	            h      : translate,
	            hh     : translate,
	            d      : 'dan',
	            dd     : translate,
	            M      : 'mjesec',
	            MM     : translate,
	            y      : 'godinu',
	            yy     : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return bs;

	}));

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Catalan [ca]
	//! author : Juan G. Hurtado : https://github.com/juanghurtado

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ca = moment.defineLocale('ca', {
	        months : 'gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
	        monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
	        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
	        weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            nextDay : function () {
	                return '[demà a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            lastDay : function () {
	                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'fa %s',
	            s : 'uns segons',
	            m : 'un minut',
	            mm : '%d minuts',
	            h : 'una hora',
	            hh : '%d hores',
	            d : 'un dia',
	            dd : '%d dies',
	            M : 'un mes',
	            MM : '%d mesos',
	            y : 'un any',
	            yy : '%d anys'
	        },
	        ordinalParse: /\d{1,2}(r|n|t|è|a)/,
	        ordinal : function (number, period) {
	            var output = (number === 1) ? 'r' :
	                (number === 2) ? 'n' :
	                (number === 3) ? 'r' :
	                (number === 4) ? 't' : 'è';
	            if (period === 'w' || period === 'W') {
	                output = 'a';
	            }
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return ca;

	}));

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Czech [cs]
	//! author : petrbela : https://github.com/petrbela

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var months = 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split('_'),
	        monthsShort = 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_');
	    function plural(n) {
	        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	            case 's':  // a few seconds / in a few seconds / a few seconds ago
	                return (withoutSuffix || isFuture) ? 'pár sekund' : 'pár sekundami';
	            case 'm':  // a minute / in a minute / a minute ago
	                return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
	            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'minuty' : 'minut');
	                } else {
	                    return result + 'minutami';
	                }
	                break;
	            case 'h':  // an hour / in an hour / an hour ago
	                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	            case 'hh': // 9 hours / in 9 hours / 9 hours ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'hodiny' : 'hodin');
	                } else {
	                    return result + 'hodinami';
	                }
	                break;
	            case 'd':  // a day / in a day / a day ago
	                return (withoutSuffix || isFuture) ? 'den' : 'dnem';
	            case 'dd': // 9 days / in 9 days / 9 days ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'dny' : 'dní');
	                } else {
	                    return result + 'dny';
	                }
	                break;
	            case 'M':  // a month / in a month / a month ago
	                return (withoutSuffix || isFuture) ? 'měsíc' : 'měsícem';
	            case 'MM': // 9 months / in 9 months / 9 months ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'měsíce' : 'měsíců');
	                } else {
	                    return result + 'měsíci';
	                }
	                break;
	            case 'y':  // a year / in a year / a year ago
	                return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
	            case 'yy': // 9 years / in 9 years / 9 years ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'roky' : 'let');
	                } else {
	                    return result + 'lety';
	                }
	                break;
	        }
	    }

	    var cs = moment.defineLocale('cs', {
	        months : months,
	        monthsShort : monthsShort,
	        monthsParse : (function (months, monthsShort) {
	            var i, _monthsParse = [];
	            for (i = 0; i < 12; i++) {
	                // use custom parser to solve problem with July (červenec)
	                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
	            }
	            return _monthsParse;
	        }(months, monthsShort)),
	        shortMonthsParse : (function (monthsShort) {
	            var i, _shortMonthsParse = [];
	            for (i = 0; i < 12; i++) {
	                _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
	            }
	            return _shortMonthsParse;
	        }(monthsShort)),
	        longMonthsParse : (function (months) {
	            var i, _longMonthsParse = [];
	            for (i = 0; i < 12; i++) {
	                _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
	            }
	            return _longMonthsParse;
	        }(months)),
	        weekdays : 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
	        weekdaysShort : 'ne_po_út_st_čt_pá_so'.split('_'),
	        weekdaysMin : 'ne_po_út_st_čt_pá_so'.split('_'),
	        longDateFormat : {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd D. MMMM YYYY H:mm',
	            l : 'D. M. YYYY'
	        },
	        calendar : {
	            sameDay: '[dnes v] LT',
	            nextDay: '[zítra v] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[v neděli v] LT';
	                    case 1:
	                    case 2:
	                        return '[v] dddd [v] LT';
	                    case 3:
	                        return '[ve středu v] LT';
	                    case 4:
	                        return '[ve čtvrtek v] LT';
	                    case 5:
	                        return '[v pátek v] LT';
	                    case 6:
	                        return '[v sobotu v] LT';
	                }
	            },
	            lastDay: '[včera v] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[minulou neděli v] LT';
	                    case 1:
	                    case 2:
	                        return '[minulé] dddd [v] LT';
	                    case 3:
	                        return '[minulou středu v] LT';
	                    case 4:
	                    case 5:
	                        return '[minulý] dddd [v] LT';
	                    case 6:
	                        return '[minulou sobotu v] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : 'před %s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse : /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return cs;

	}));

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chuvash [cv]
	//! author : Anatoly Mironov : https://github.com/mirontoli

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var cv = moment.defineLocale('cv', {
	        months : 'кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав'.split('_'),
	        monthsShort : 'кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш'.split('_'),
	        weekdays : 'вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун'.split('_'),
	        weekdaysShort : 'выр_тун_ытл_юн_кӗҫ_эрн_шӑм'.split('_'),
	        weekdaysMin : 'вр_тн_ыт_юн_кҫ_эр_шм'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]',
	            LLL : 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
	            LLLL : 'dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm'
	        },
	        calendar : {
	            sameDay: '[Паян] LT [сехетре]',
	            nextDay: '[Ыран] LT [сехетре]',
	            lastDay: '[Ӗнер] LT [сехетре]',
	            nextWeek: '[Ҫитес] dddd LT [сехетре]',
	            lastWeek: '[Иртнӗ] dddd LT [сехетре]',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : function (output) {
	                var affix = /сехет$/i.exec(output) ? 'рен' : /ҫул$/i.exec(output) ? 'тан' : 'ран';
	                return output + affix;
	            },
	            past : '%s каялла',
	            s : 'пӗр-ик ҫеккунт',
	            m : 'пӗр минут',
	            mm : '%d минут',
	            h : 'пӗр сехет',
	            hh : '%d сехет',
	            d : 'пӗр кун',
	            dd : '%d кун',
	            M : 'пӗр уйӑх',
	            MM : '%d уйӑх',
	            y : 'пӗр ҫул',
	            yy : '%d ҫул'
	        },
	        ordinalParse: /\d{1,2}-мӗш/,
	        ordinal : '%d-мӗш',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return cv;

	}));

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Welsh [cy]
	//! author : Robert Allen : https://github.com/robgallen
	//! author : https://github.com/ryangreaves

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var cy = moment.defineLocale('cy', {
	        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
	        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
	        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
	        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
	        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
	        weekdaysParseExact : true,
	        // time formats are the same as en-gb
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[Heddiw am] LT',
	            nextDay: '[Yfory am] LT',
	            nextWeek: 'dddd [am] LT',
	            lastDay: '[Ddoe am] LT',
	            lastWeek: 'dddd [diwethaf am] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'mewn %s',
	            past: '%s yn ôl',
	            s: 'ychydig eiliadau',
	            m: 'munud',
	            mm: '%d munud',
	            h: 'awr',
	            hh: '%d awr',
	            d: 'diwrnod',
	            dd: '%d diwrnod',
	            M: 'mis',
	            MM: '%d mis',
	            y: 'blwyddyn',
	            yy: '%d flynedd'
	        },
	        ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
	        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
	        ordinal: function (number) {
	            var b = number,
	                output = '',
	                lookup = [
	                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
	                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
	                ];
	            if (b > 20) {
	                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
	                    output = 'fed'; // not 30ain, 70ain or 90ain
	                } else {
	                    output = 'ain';
	                }
	            } else if (b > 0) {
	                output = lookup[b];
	            }
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return cy;

	}));

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Danish [da]
	//! author : Ulrik Nielsen : https://github.com/mrbase

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var da = moment.defineLocale('da', {
	        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
	        weekdaysShort : 'søn_man_tir_ons_tor_fre_lør'.split('_'),
	        weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY HH:mm',
	            LLLL : 'dddd [d.] D. MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[I dag kl.] LT',
	            nextDay : '[I morgen kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[I går kl.] LT',
	            lastWeek : '[sidste] dddd [kl] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : '%s siden',
	            s : 'få sekunder',
	            m : 'et minut',
	            mm : '%d minutter',
	            h : 'en time',
	            hh : '%d timer',
	            d : 'en dag',
	            dd : '%d dage',
	            M : 'en måned',
	            MM : '%d måneder',
	            y : 'et år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return da;

	}));

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : German [de]
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensúle: https://github.com/Oire
	//! author : Mikolaj Dadela : https://github.com/mik01aj

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eine Minute', 'einer Minute'],
	            'h': ['eine Stunde', 'einer Stunde'],
	            'd': ['ein Tag', 'einem Tag'],
	            'dd': [number + ' Tage', number + ' Tagen'],
	            'M': ['ein Monat', 'einem Monat'],
	            'MM': [number + ' Monate', number + ' Monaten'],
	            'y': ['ein Jahr', 'einem Jahr'],
	            'yy': [number + ' Jahre', number + ' Jahren']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }

	    var de = moment.defineLocale('de', {
	        months : 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY HH:mm',
	            LLLL : 'dddd, D. MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[heute um] LT [Uhr]',
	            sameElse: 'L',
	            nextDay: '[morgen um] LT [Uhr]',
	            nextWeek: 'dddd [um] LT [Uhr]',
	            lastDay: '[gestern um] LT [Uhr]',
	            lastWeek: '[letzten] dddd [um] LT [Uhr]'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : 'vor %s',
	            s : 'ein paar Sekunden',
	            m : processRelativeTime,
	            mm : '%d Minuten',
	            h : processRelativeTime,
	            hh : '%d Stunden',
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return de;

	}));

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : German (Austria) [de-at]
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensúle: https://github.com/Oire
	//! author : Martin Groller : https://github.com/MadMG
	//! author : Mikolaj Dadela : https://github.com/mik01aj

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eine Minute', 'einer Minute'],
	            'h': ['eine Stunde', 'einer Stunde'],
	            'd': ['ein Tag', 'einem Tag'],
	            'dd': [number + ' Tage', number + ' Tagen'],
	            'M': ['ein Monat', 'einem Monat'],
	            'MM': [number + ' Monate', number + ' Monaten'],
	            'y': ['ein Jahr', 'einem Jahr'],
	            'yy': [number + ' Jahre', number + ' Jahren']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }

	    var de_at = moment.defineLocale('de-at', {
	        months : 'Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort : 'Jän._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY HH:mm',
	            LLLL : 'dddd, D. MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[heute um] LT [Uhr]',
	            sameElse: 'L',
	            nextDay: '[morgen um] LT [Uhr]',
	            nextWeek: 'dddd [um] LT [Uhr]',
	            lastDay: '[gestern um] LT [Uhr]',
	            lastWeek: '[letzten] dddd [um] LT [Uhr]'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : 'vor %s',
	            s : 'ein paar Sekunden',
	            m : processRelativeTime,
	            mm : '%d Minuten',
	            h : processRelativeTime,
	            hh : '%d Stunden',
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return de_at;

	}));

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Maldivian [dv]
	//! author : Jawish Hameed : https://github.com/jawish

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var months = [
	        'ޖެނުއަރީ',
	        'ފެބްރުއަރީ',
	        'މާރިޗު',
	        'އޭޕްރީލު',
	        'މޭ',
	        'ޖޫން',
	        'ޖުލައި',
	        'އޯގަސްޓު',
	        'ސެޕްޓެމްބަރު',
	        'އޮކްޓޯބަރު',
	        'ނޮވެމްބަރު',
	        'ޑިސެމްބަރު'
	    ], weekdays = [
	        'އާދިއްތަ',
	        'ހޯމަ',
	        'އަންގާރަ',
	        'ބުދަ',
	        'ބުރާސްފަތި',
	        'ހުކުރު',
	        'ހޮނިހިރު'
	    ];

	    var dv = moment.defineLocale('dv', {
	        months : months,
	        monthsShort : months,
	        weekdays : weekdays,
	        weekdaysShort : weekdays,
	        weekdaysMin : 'އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި'.split('_'),
	        longDateFormat : {

	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'D/M/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /މކ|މފ/,
	        isPM : function (input) {
	            return 'މފ' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'މކ';
	            } else {
	                return 'މފ';
	            }
	        },
	        calendar : {
	            sameDay : '[މިއަދު] LT',
	            nextDay : '[މާދަމާ] LT',
	            nextWeek : 'dddd LT',
	            lastDay : '[އިއްޔެ] LT',
	            lastWeek : '[ފާއިތުވި] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'ތެރޭގައި %s',
	            past : 'ކުރިން %s',
	            s : 'ސިކުންތުކޮޅެއް',
	            m : 'މިނިޓެއް',
	            mm : 'މިނިޓު %d',
	            h : 'ގަޑިއިރެއް',
	            hh : 'ގަޑިއިރު %d',
	            d : 'ދުވަހެއް',
	            dd : 'ދުވަސް %d',
	            M : 'މަހެއް',
	            MM : 'މަސް %d',
	            y : 'އަހަރެއް',
	            yy : 'އަހަރު %d'
	        },
	        preparse: function (string) {
	            return string.replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/,/g, '،');
	        },
	        week : {
	            dow : 7,  // Sunday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return dv;

	}));

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Greek [el]
	//! author : Aggelos Karalias : https://github.com/mehiel

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';

	    function isFunction(input) {
	        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	    }


	    var el = moment.defineLocale('el', {
	        monthsNominativeEl : 'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split('_'),
	        monthsGenitiveEl : 'Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου'.split('_'),
	        months : function (momentToFormat, format) {
	            if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
	                return this._monthsGenitiveEl[momentToFormat.month()];
	            } else {
	                return this._monthsNominativeEl[momentToFormat.month()];
	            }
	        },
	        monthsShort : 'Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ'.split('_'),
	        weekdays : 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split('_'),
	        weekdaysShort : 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
	        weekdaysMin : 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'μμ' : 'ΜΜ';
	            } else {
	                return isLower ? 'πμ' : 'ΠΜ';
	            }
	        },
	        isPM : function (input) {
	            return ((input + '').toLowerCase()[0] === 'μ');
	        },
	        meridiemParse : /[ΠΜ]\.?Μ?\.?/i,
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendarEl : {
	            sameDay : '[Σήμερα {}] LT',
	            nextDay : '[Αύριο {}] LT',
	            nextWeek : 'dddd [{}] LT',
	            lastDay : '[Χθες {}] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 6:
	                        return '[το προηγούμενο] dddd [{}] LT';
	                    default:
	                        return '[την προηγούμενη] dddd [{}] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        calendar : function (key, mom) {
	            var output = this._calendarEl[key],
	                hours = mom && mom.hours();
	            if (isFunction(output)) {
	                output = output.apply(mom);
	            }
	            return output.replace('{}', (hours % 12 === 1 ? 'στη' : 'στις'));
	        },
	        relativeTime : {
	            future : 'σε %s',
	            past : '%s πριν',
	            s : 'λίγα δευτερόλεπτα',
	            m : 'ένα λεπτό',
	            mm : '%d λεπτά',
	            h : 'μία ώρα',
	            hh : '%d ώρες',
	            d : 'μία μέρα',
	            dd : '%d μέρες',
	            M : 'ένας μήνας',
	            MM : '%d μήνες',
	            y : 'ένας χρόνος',
	            yy : '%d χρόνια'
	        },
	        ordinalParse: /\d{1,2}η/,
	        ordinal: '%dη',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4st is the first week of the year.
	        }
	    });

	    return el;

	}));

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Australia) [en-au]
	//! author : Jared Morse : https://github.com/jarcoal

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var en_au = moment.defineLocale('en-au', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return en_au;

	}));

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Canada) [en-ca]
	//! author : Jonathan Abourbih : https://github.com/jonbca

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var en_ca = moment.defineLocale('en-ca', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'YYYY-MM-DD',
	            LL : 'MMMM D, YYYY',
	            LLL : 'MMMM D, YYYY h:mm A',
	            LLLL : 'dddd, MMMM D, YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });

	    return en_ca;

	}));

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (United Kingdom) [en-gb]
	//! author : Chris Gedrim : https://github.com/chrisgedrim

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var en_gb = moment.defineLocale('en-gb', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return en_gb;

	}));

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Ireland) [en-ie]
	//! author : Chris Cartlidge : https://github.com/chriscartlidge

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var en_ie = moment.defineLocale('en-ie', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return en_ie;

	}));

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (New Zealand) [en-nz]
	//! author : Luke McGregor : https://github.com/lukemcgregor

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var en_nz = moment.defineLocale('en-nz', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return en_nz;

	}));

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Esperanto [eo]
	//! author : Colin Dean : https://github.com/colindean
	//! komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
	//!          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var eo = moment.defineLocale('eo', {
	        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec'.split('_'),
	        weekdays : 'Dimanĉo_Lundo_Mardo_Merkredo_Ĵaŭdo_Vendredo_Sabato'.split('_'),
	        weekdaysShort : 'Dim_Lun_Mard_Merk_Ĵaŭ_Ven_Sab'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Ĵa_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D[-an de] MMMM, YYYY',
	            LLL : 'D[-an de] MMMM, YYYY HH:mm',
	            LLLL : 'dddd, [la] D[-an de] MMMM, YYYY HH:mm'
	        },
	        meridiemParse: /[ap]\.t\.m/i,
	        isPM: function (input) {
	            return input.charAt(0).toLowerCase() === 'p';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'p.t.m.' : 'P.T.M.';
	            } else {
	                return isLower ? 'a.t.m.' : 'A.T.M.';
	            }
	        },
	        calendar : {
	            sameDay : '[Hodiaŭ je] LT',
	            nextDay : '[Morgaŭ je] LT',
	            nextWeek : 'dddd [je] LT',
	            lastDay : '[Hieraŭ je] LT',
	            lastWeek : '[pasinta] dddd [je] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'je %s',
	            past : 'antaŭ %s',
	            s : 'sekundoj',
	            m : 'minuto',
	            mm : '%d minutoj',
	            h : 'horo',
	            hh : '%d horoj',
	            d : 'tago',//ne 'diurno', ĉar estas uzita por proksimumo
	            dd : '%d tagoj',
	            M : 'monato',
	            MM : '%d monatoj',
	            y : 'jaro',
	            yy : '%d jaroj'
	        },
	        ordinalParse: /\d{1,2}a/,
	        ordinal : '%da',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return eo;

	}));

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Spanish [es]
	//! author : Julio Napurí : https://github.com/julionc

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
	        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

	    var es = moment.defineLocale('es', {
	        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShort[m.month()];
	            } else {
	                return monthsShortDot[m.month()];
	            }
	        },
	        monthsParseExact : true,
	        weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
	        weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
	        weekdaysMin : 'do_lu_ma_mi_ju_vi_sá'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY H:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextDay : function () {
	                return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastDay : function () {
	                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'hace %s',
	            s : 'unos segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'una hora',
	            hh : '%d horas',
	            d : 'un día',
	            dd : '%d días',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un año',
	            yy : '%d años'
	        },
	        ordinalParse : /\d{1,2}º/,
	        ordinal : '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return es;

	}));

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Spanish (Dominican Republic) [es-do]

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
	        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

	    var es_do = moment.defineLocale('es-do', {
	        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShort[m.month()];
	            } else {
	                return monthsShortDot[m.month()];
	            }
	        },
	        monthsParseExact : true,
	        weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
	        weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
	        weekdaysMin : 'do_lu_ma_mi_ju_vi_sá'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY h:mm A',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextDay : function () {
	                return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastDay : function () {
	                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'hace %s',
	            s : 'unos segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'una hora',
	            hh : '%d horas',
	            d : 'un día',
	            dd : '%d días',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un año',
	            yy : '%d años'
	        },
	        ordinalParse : /\d{1,2}º/,
	        ordinal : '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return es_do;

	}));

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Estonian [et]
	//! author : Henry Kehlmann : https://github.com/madhenry
	//! improvements : Illimar Tambek : https://github.com/ragulka

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            's' : ['mõne sekundi', 'mõni sekund', 'paar sekundit'],
	            'm' : ['ühe minuti', 'üks minut'],
	            'mm': [number + ' minuti', number + ' minutit'],
	            'h' : ['ühe tunni', 'tund aega', 'üks tund'],
	            'hh': [number + ' tunni', number + ' tundi'],
	            'd' : ['ühe päeva', 'üks päev'],
	            'M' : ['kuu aja', 'kuu aega', 'üks kuu'],
	            'MM': [number + ' kuu', number + ' kuud'],
	            'y' : ['ühe aasta', 'aasta', 'üks aasta'],
	            'yy': [number + ' aasta', number + ' aastat']
	        };
	        if (withoutSuffix) {
	            return format[key][2] ? format[key][2] : format[key][1];
	        }
	        return isFuture ? format[key][0] : format[key][1];
	    }

	    var et = moment.defineLocale('et', {
	        months        : 'jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
	        monthsShort   : 'jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
	        weekdays      : 'pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev'.split('_'),
	        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
	        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
	        longDateFormat : {
	            LT   : 'H:mm',
	            LTS : 'H:mm:ss',
	            L    : 'DD.MM.YYYY',
	            LL   : 'D. MMMM YYYY',
	            LLL  : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[Täna,] LT',
	            nextDay  : '[Homme,] LT',
	            nextWeek : '[Järgmine] dddd LT',
	            lastDay  : '[Eile,] LT',
	            lastWeek : '[Eelmine] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s pärast',
	            past   : '%s tagasi',
	            s      : processRelativeTime,
	            m      : processRelativeTime,
	            mm     : processRelativeTime,
	            h      : processRelativeTime,
	            hh     : processRelativeTime,
	            d      : processRelativeTime,
	            dd     : '%d päeva',
	            M      : processRelativeTime,
	            MM     : processRelativeTime,
	            y      : processRelativeTime,
	            yy     : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return et;

	}));

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Basque [eu]
	//! author : Eneko Illarramendi : https://github.com/eillarra

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var eu = moment.defineLocale('eu', {
	        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
	        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
	        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
	        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY[ko] MMMM[ren] D[a]',
	            LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
	            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
	            l : 'YYYY-M-D',
	            ll : 'YYYY[ko] MMM D[a]',
	            lll : 'YYYY[ko] MMM D[a] HH:mm',
	            llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
	        },
	        calendar : {
	            sameDay : '[gaur] LT[etan]',
	            nextDay : '[bihar] LT[etan]',
	            nextWeek : 'dddd LT[etan]',
	            lastDay : '[atzo] LT[etan]',
	            lastWeek : '[aurreko] dddd LT[etan]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s barru',
	            past : 'duela %s',
	            s : 'segundo batzuk',
	            m : 'minutu bat',
	            mm : '%d minutu',
	            h : 'ordu bat',
	            hh : '%d ordu',
	            d : 'egun bat',
	            dd : '%d egun',
	            M : 'hilabete bat',
	            MM : '%d hilabete',
	            y : 'urte bat',
	            yy : '%d urte'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return eu;

	}));

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Persian [fa]
	//! author : Ebrahim Byagowi : https://github.com/ebraminio

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '۱',
	        '2': '۲',
	        '3': '۳',
	        '4': '۴',
	        '5': '۵',
	        '6': '۶',
	        '7': '۷',
	        '8': '۸',
	        '9': '۹',
	        '0': '۰'
	    }, numberMap = {
	        '۱': '1',
	        '۲': '2',
	        '۳': '3',
	        '۴': '4',
	        '۵': '5',
	        '۶': '6',
	        '۷': '7',
	        '۸': '8',
	        '۹': '9',
	        '۰': '0'
	    };

	    var fa = moment.defineLocale('fa', {
	        months : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
	        monthsShort : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
	        weekdays : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
	        weekdaysShort : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
	        weekdaysMin : 'ی_د_س_چ_پ_ج_ش'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /قبل از ظهر|بعد از ظهر/,
	        isPM: function (input) {
	            return /بعد از ظهر/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'قبل از ظهر';
	            } else {
	                return 'بعد از ظهر';
	            }
	        },
	        calendar : {
	            sameDay : '[امروز ساعت] LT',
	            nextDay : '[فردا ساعت] LT',
	            nextWeek : 'dddd [ساعت] LT',
	            lastDay : '[دیروز ساعت] LT',
	            lastWeek : 'dddd [پیش] [ساعت] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'در %s',
	            past : '%s پیش',
	            s : 'چندین ثانیه',
	            m : 'یک دقیقه',
	            mm : '%d دقیقه',
	            h : 'یک ساعت',
	            hh : '%d ساعت',
	            d : 'یک روز',
	            dd : '%d روز',
	            M : 'یک ماه',
	            MM : '%d ماه',
	            y : 'یک سال',
	            yy : '%d سال'
	        },
	        preparse: function (string) {
	            return string.replace(/[۰-۹]/g, function (match) {
	                return numberMap[match];
	            }).replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '،');
	        },
	        ordinalParse: /\d{1,2}م/,
	        ordinal : '%dم',
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12 // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return fa;

	}));

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Finnish [fi]
	//! author : Tarmo Aidantausta : https://github.com/bleadof

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var numbersPast = 'nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän'.split(' '),
	        numbersFuture = [
	            'nolla', 'yhden', 'kahden', 'kolmen', 'neljän', 'viiden', 'kuuden',
	            numbersPast[7], numbersPast[8], numbersPast[9]
	        ];
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = '';
	        switch (key) {
	            case 's':
	                return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
	            case 'm':
	                return isFuture ? 'minuutin' : 'minuutti';
	            case 'mm':
	                result = isFuture ? 'minuutin' : 'minuuttia';
	                break;
	            case 'h':
	                return isFuture ? 'tunnin' : 'tunti';
	            case 'hh':
	                result = isFuture ? 'tunnin' : 'tuntia';
	                break;
	            case 'd':
	                return isFuture ? 'päivän' : 'päivä';
	            case 'dd':
	                result = isFuture ? 'päivän' : 'päivää';
	                break;
	            case 'M':
	                return isFuture ? 'kuukauden' : 'kuukausi';
	            case 'MM':
	                result = isFuture ? 'kuukauden' : 'kuukautta';
	                break;
	            case 'y':
	                return isFuture ? 'vuoden' : 'vuosi';
	            case 'yy':
	                result = isFuture ? 'vuoden' : 'vuotta';
	                break;
	        }
	        result = verbalNumber(number, isFuture) + ' ' + result;
	        return result;
	    }
	    function verbalNumber(number, isFuture) {
	        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
	    }

	    var fi = moment.defineLocale('fi', {
	        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
	        monthsShort : 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split('_'),
	        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
	        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
	        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD.MM.YYYY',
	            LL : 'Do MMMM[ta] YYYY',
	            LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
	            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
	            l : 'D.M.YYYY',
	            ll : 'Do MMM YYYY',
	            lll : 'Do MMM YYYY, [klo] HH.mm',
	            llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
	        },
	        calendar : {
	            sameDay : '[tänään] [klo] LT',
	            nextDay : '[huomenna] [klo] LT',
	            nextWeek : 'dddd [klo] LT',
	            lastDay : '[eilen] [klo] LT',
	            lastWeek : '[viime] dddd[na] [klo] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s päästä',
	            past : '%s sitten',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return fi;

	}));

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Faroese [fo]
	//! author : Ragnar Johannesen : https://github.com/ragnar123

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var fo = moment.defineLocale('fo', {
	        months : 'januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur'.split('_'),
	        weekdaysShort : 'sun_mán_týs_mik_hós_frí_ley'.split('_'),
	        weekdaysMin : 'su_má_tý_mi_hó_fr_le'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D. MMMM, YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Í dag kl.] LT',
	            nextDay : '[Í morgin kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[Í gjár kl.] LT',
	            lastWeek : '[síðstu] dddd [kl] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'um %s',
	            past : '%s síðani',
	            s : 'fá sekund',
	            m : 'ein minutt',
	            mm : '%d minuttir',
	            h : 'ein tími',
	            hh : '%d tímar',
	            d : 'ein dagur',
	            dd : '%d dagar',
	            M : 'ein mánaði',
	            MM : '%d mánaðir',
	            y : 'eitt ár',
	            yy : '%d ár'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return fo;

	}));

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French [fr]
	//! author : John Fischer : https://github.com/jfroffice

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var fr = moment.defineLocale('fr', {
	        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui à] LT',
	            nextDay: '[Demain à] LT',
	            nextWeek: 'dddd [à] LT',
	            lastDay: '[Hier à] LT',
	            lastWeek: 'dddd [dernier à] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : '');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return fr;

	}));

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French (Canada) [fr-ca]
	//! author : Jonathan Abourbih : https://github.com/jonbca

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var fr_ca = moment.defineLocale('fr-ca', {
	        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui à] LT',
	            nextDay: '[Demain à] LT',
	            nextWeek: 'dddd [à] LT',
	            lastDay: '[Hier à] LT',
	            lastWeek: 'dddd [dernier à] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|e)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : 'e');
	        }
	    });

	    return fr_ca;

	}));

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French (Switzerland) [fr-ch]
	//! author : Gaspard Bucher : https://github.com/gaspard

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var fr_ch = moment.defineLocale('fr-ch', {
	        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui à] LT',
	            nextDay: '[Demain à] LT',
	            nextWeek: 'dddd [à] LT',
	            lastDay: '[Hier à] LT',
	            lastWeek: 'dddd [dernier à] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|e)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : 'e');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return fr_ch;

	}));

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Frisian [fy]
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
	        monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

	    var fy = moment.defineLocale('fy', {
	        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShortWithoutDots[m.month()];
	            } else {
	                return monthsShortWithDots[m.month()];
	            }
	        },
	        monthsParseExact : true,
	        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
	        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
	        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[hjoed om] LT',
	            nextDay: '[moarn om] LT',
	            nextWeek: 'dddd [om] LT',
	            lastDay: '[juster om] LT',
	            lastWeek: '[ôfrûne] dddd [om] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'oer %s',
	            past : '%s lyn',
	            s : 'in pear sekonden',
	            m : 'ien minút',
	            mm : '%d minuten',
	            h : 'ien oere',
	            hh : '%d oeren',
	            d : 'ien dei',
	            dd : '%d dagen',
	            M : 'ien moanne',
	            MM : '%d moannen',
	            y : 'ien jier',
	            yy : '%d jierren'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return fy;

	}));

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Scottish Gaelic [gd]
	//! author : Jon Ashdown : https://github.com/jonashdown

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var months = [
	        'Am Faoilleach', 'An Gearran', 'Am Màrt', 'An Giblean', 'An Cèitean', 'An t-Ògmhios', 'An t-Iuchar', 'An Lùnastal', 'An t-Sultain', 'An Dàmhair', 'An t-Samhain', 'An Dùbhlachd'
	    ];

	    var monthsShort = ['Faoi', 'Gear', 'Màrt', 'Gibl', 'Cèit', 'Ògmh', 'Iuch', 'Lùn', 'Sult', 'Dàmh', 'Samh', 'Dùbh'];

	    var weekdays = ['Didòmhnaich', 'Diluain', 'Dimàirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];

	    var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];

	    var weekdaysMin = ['Dò', 'Lu', 'Mà', 'Ci', 'Ar', 'Ha', 'Sa'];

	    var gd = moment.defineLocale('gd', {
	        months : months,
	        monthsShort : monthsShort,
	        monthsParseExact : true,
	        weekdays : weekdays,
	        weekdaysShort : weekdaysShort,
	        weekdaysMin : weekdaysMin,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[An-diugh aig] LT',
	            nextDay : '[A-màireach aig] LT',
	            nextWeek : 'dddd [aig] LT',
	            lastDay : '[An-dè aig] LT',
	            lastWeek : 'dddd [seo chaidh] [aig] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'ann an %s',
	            past : 'bho chionn %s',
	            s : 'beagan diogan',
	            m : 'mionaid',
	            mm : '%d mionaidean',
	            h : 'uair',
	            hh : '%d uairean',
	            d : 'latha',
	            dd : '%d latha',
	            M : 'mìos',
	            MM : '%d mìosan',
	            y : 'bliadhna',
	            yy : '%d bliadhna'
	        },
	        ordinalParse : /\d{1,2}(d|na|mh)/,
	        ordinal : function (number) {
	            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return gd;

	}));

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Galician [gl]
	//! author : Juan G. Hurtado : https://github.com/juanghurtado

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var gl = moment.defineLocale('gl', {
	        months : 'xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
	        monthsShort : 'xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'domingo_luns_martes_mércores_xoves_venres_sábado'.split('_'),
	        weekdaysShort : 'dom._lun._mar._mér._xov._ven._sáb.'.split('_'),
	        weekdaysMin : 'do_lu_ma_mé_xo_ve_sá'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY H:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoxe ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
	            },
	            nextDay : function () {
	                return '[mañá ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
	            },
	            lastDay : function () {
	                return '[onte ' + ((this.hours() !== 1) ? 'á' : 'a') + '] LT';
	            },
	            lastWeek : function () {
	                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : function (str) {
	                if (str.indexOf('un') === 0) {
	                    return 'n' + str;
	                }
	                return 'en ' + str;
	            },
	            past : 'hai %s',
	            s : 'uns segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'unha hora',
	            hh : '%d horas',
	            d : 'un día',
	            dd : '%d días',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un ano',
	            yy : '%d anos'
	        },
	        ordinalParse : /\d{1,2}º/,
	        ordinal : '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return gl;

	}));

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hebrew [he]
	//! author : Tomer Cohen : https://github.com/tomer
	//! author : Moshe Simantov : https://github.com/DevelopmentIL
	//! author : Tal Ater : https://github.com/TalAter

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var he = moment.defineLocale('he', {
	        months : 'ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר'.split('_'),
	        monthsShort : 'ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳'.split('_'),
	        weekdays : 'ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת'.split('_'),
	        weekdaysShort : 'א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳'.split('_'),
	        weekdaysMin : 'א_ב_ג_ד_ה_ו_ש'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [ב]MMMM YYYY',
	            LLL : 'D [ב]MMMM YYYY HH:mm',
	            LLLL : 'dddd, D [ב]MMMM YYYY HH:mm',
	            l : 'D/M/YYYY',
	            ll : 'D MMM YYYY',
	            lll : 'D MMM YYYY HH:mm',
	            llll : 'ddd, D MMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[היום ב־]LT',
	            nextDay : '[מחר ב־]LT',
	            nextWeek : 'dddd [בשעה] LT',
	            lastDay : '[אתמול ב־]LT',
	            lastWeek : '[ביום] dddd [האחרון בשעה] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'בעוד %s',
	            past : 'לפני %s',
	            s : 'מספר שניות',
	            m : 'דקה',
	            mm : '%d דקות',
	            h : 'שעה',
	            hh : function (number) {
	                if (number === 2) {
	                    return 'שעתיים';
	                }
	                return number + ' שעות';
	            },
	            d : 'יום',
	            dd : function (number) {
	                if (number === 2) {
	                    return 'יומיים';
	                }
	                return number + ' ימים';
	            },
	            M : 'חודש',
	            MM : function (number) {
	                if (number === 2) {
	                    return 'חודשיים';
	                }
	                return number + ' חודשים';
	            },
	            y : 'שנה',
	            yy : function (number) {
	                if (number === 2) {
	                    return 'שנתיים';
	                } else if (number % 10 === 0 && number !== 10) {
	                    return number + ' שנה';
	                }
	                return number + ' שנים';
	            }
	        },
	        meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,
	        isPM : function (input) {
	            return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 5) {
	                return 'לפנות בוקר';
	            } else if (hour < 10) {
	                return 'בבוקר';
	            } else if (hour < 12) {
	                return isLower ? 'לפנה"צ' : 'לפני הצהריים';
	            } else if (hour < 18) {
	                return isLower ? 'אחה"צ' : 'אחרי הצהריים';
	            } else {
	                return 'בערב';
	            }
	        }
	    });

	    return he;

	}));

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hindi [hi]
	//! author : Mayank Singhal : https://github.com/mayanksinghal

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '१',
	        '2': '२',
	        '3': '३',
	        '4': '४',
	        '5': '५',
	        '6': '६',
	        '7': '७',
	        '8': '८',
	        '9': '९',
	        '0': '०'
	    },
	    numberMap = {
	        '१': '1',
	        '२': '2',
	        '३': '3',
	        '४': '4',
	        '५': '5',
	        '६': '6',
	        '७': '7',
	        '८': '8',
	        '९': '9',
	        '०': '0'
	    };

	    var hi = moment.defineLocale('hi', {
	        months : 'जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर'.split('_'),
	        monthsShort : 'जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
	        weekdaysShort : 'रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि'.split('_'),
	        weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm बजे',
	            LTS : 'A h:mm:ss बजे',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm बजे',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm बजे'
	        },
	        calendar : {
	            sameDay : '[आज] LT',
	            nextDay : '[कल] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[कल] LT',
	            lastWeek : '[पिछले] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s में',
	            past : '%s पहले',
	            s : 'कुछ ही क्षण',
	            m : 'एक मिनट',
	            mm : '%d मिनट',
	            h : 'एक घंटा',
	            hh : '%d घंटे',
	            d : 'एक दिन',
	            dd : '%d दिन',
	            M : 'एक महीने',
	            MM : '%d महीने',
	            y : 'एक वर्ष',
	            yy : '%d वर्ष'
	        },
	        preparse: function (string) {
	            return string.replace(/[१२३४५६७८९०]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
	        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
	        meridiemParse: /रात|सुबह|दोपहर|शाम/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'रात') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === 'सुबह') {
	                return hour;
	            } else if (meridiem === 'दोपहर') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'शाम') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'रात';
	            } else if (hour < 10) {
	                return 'सुबह';
	            } else if (hour < 17) {
	                return 'दोपहर';
	            } else if (hour < 20) {
	                return 'शाम';
	            } else {
	                return 'रात';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return hi;

	}));

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Croatian [hr]
	//! author : Bojan Marković : https://github.com/bmarkovic

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	            case 'm':
	                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	            case 'mm':
	                if (number === 1) {
	                    result += 'minuta';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'minute';
	                } else {
	                    result += 'minuta';
	                }
	                return result;
	            case 'h':
	                return withoutSuffix ? 'jedan sat' : 'jednog sata';
	            case 'hh':
	                if (number === 1) {
	                    result += 'sat';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'sata';
	                } else {
	                    result += 'sati';
	                }
	                return result;
	            case 'dd':
	                if (number === 1) {
	                    result += 'dan';
	                } else {
	                    result += 'dana';
	                }
	                return result;
	            case 'MM':
	                if (number === 1) {
	                    result += 'mjesec';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'mjeseca';
	                } else {
	                    result += 'mjeseci';
	                }
	                return result;
	            case 'yy':
	                if (number === 1) {
	                    result += 'godina';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'godine';
	                } else {
	                    result += 'godina';
	                }
	                return result;
	        }
	    }

	    var hr = moment.defineLocale('hr', {
	        months : {
	            format: 'siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
	            standalone: 'siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
	        },
	        monthsShort : 'sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
	        weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
	        weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[danas u] LT',
	            nextDay  : '[sutra u] LT',
	            nextWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[u] [nedjelju] [u] LT';
	                    case 3:
	                        return '[u] [srijedu] [u] LT';
	                    case 6:
	                        return '[u] [subotu] [u] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[jučer u] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                    case 3:
	                        return '[prošlu] dddd [u] LT';
	                    case 6:
	                        return '[prošle] [subote] [u] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[prošli] dddd [u] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'par sekundi',
	            m      : translate,
	            mm     : translate,
	            h      : translate,
	            hh     : translate,
	            d      : 'dan',
	            dd     : translate,
	            M      : 'mjesec',
	            MM     : translate,
	            y      : 'godinu',
	            yy     : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return hr;

	}));

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hungarian [hu]
	//! author : Adam Brunner : https://github.com/adambrunner

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var weekEndings = 'vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton'.split(' ');
	    function translate(number, withoutSuffix, key, isFuture) {
	        var num = number,
	            suffix;
	        switch (key) {
	            case 's':
	                return (isFuture || withoutSuffix) ? 'néhány másodperc' : 'néhány másodperce';
	            case 'm':
	                return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
	            case 'mm':
	                return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
	            case 'h':
	                return 'egy' + (isFuture || withoutSuffix ? ' óra' : ' órája');
	            case 'hh':
	                return num + (isFuture || withoutSuffix ? ' óra' : ' órája');
	            case 'd':
	                return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
	            case 'dd':
	                return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
	            case 'M':
	                return 'egy' + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
	            case 'MM':
	                return num + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
	            case 'y':
	                return 'egy' + (isFuture || withoutSuffix ? ' év' : ' éve');
	            case 'yy':
	                return num + (isFuture || withoutSuffix ? ' év' : ' éve');
	        }
	        return '';
	    }
	    function week(isFuture) {
	        return (isFuture ? '' : '[múlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
	    }

	    var hu = moment.defineLocale('hu', {
	        months : 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split('_'),
	        monthsShort : 'jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec'.split('_'),
	        weekdays : 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
	        weekdaysShort : 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
	        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'YYYY.MM.DD.',
	            LL : 'YYYY. MMMM D.',
	            LLL : 'YYYY. MMMM D. H:mm',
	            LLLL : 'YYYY. MMMM D., dddd H:mm'
	        },
	        meridiemParse: /de|du/i,
	        isPM: function (input) {
	            return input.charAt(1).toLowerCase() === 'u';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower === true ? 'de' : 'DE';
	            } else {
	                return isLower === true ? 'du' : 'DU';
	            }
	        },
	        calendar : {
	            sameDay : '[ma] LT[-kor]',
	            nextDay : '[holnap] LT[-kor]',
	            nextWeek : function () {
	                return week.call(this, true);
	            },
	            lastDay : '[tegnap] LT[-kor]',
	            lastWeek : function () {
	                return week.call(this, false);
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s múlva',
	            past : '%s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return hu;

	}));

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Armenian [hy-am]
	//! author : Armendarabyan : https://github.com/armendarabyan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var hy_am = moment.defineLocale('hy-am', {
	        months : {
	            format: 'հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի'.split('_'),
	            standalone: 'հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր'.split('_')
	        },
	        monthsShort : 'հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ'.split('_'),
	        weekdays : 'կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ'.split('_'),
	        weekdaysShort : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
	        weekdaysMin : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY թ.',
	            LLL : 'D MMMM YYYY թ., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY թ., HH:mm'
	        },
	        calendar : {
	            sameDay: '[այսօր] LT',
	            nextDay: '[վաղը] LT',
	            lastDay: '[երեկ] LT',
	            nextWeek: function () {
	                return 'dddd [օրը ժամը] LT';
	            },
	            lastWeek: function () {
	                return '[անցած] dddd [օրը ժամը] LT';
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s հետո',
	            past : '%s առաջ',
	            s : 'մի քանի վայրկյան',
	            m : 'րոպե',
	            mm : '%d րոպե',
	            h : 'ժամ',
	            hh : '%d ժամ',
	            d : 'օր',
	            dd : '%d օր',
	            M : 'ամիս',
	            MM : '%d ամիս',
	            y : 'տարի',
	            yy : '%d տարի'
	        },
	        meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
	        isPM: function (input) {
	            return /^(ցերեկվա|երեկոյան)$/.test(input);
	        },
	        meridiem : function (hour) {
	            if (hour < 4) {
	                return 'գիշերվա';
	            } else if (hour < 12) {
	                return 'առավոտվա';
	            } else if (hour < 17) {
	                return 'ցերեկվա';
	            } else {
	                return 'երեկոյան';
	            }
	        },
	        ordinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
	        ordinal: function (number, period) {
	            switch (period) {
	                case 'DDD':
	                case 'w':
	                case 'W':
	                case 'DDDo':
	                    if (number === 1) {
	                        return number + '-ին';
	                    }
	                    return number + '-րդ';
	                default:
	                    return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return hy_am;

	}));

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Indonesian [id]
	//! author : Mohammad Satrio Utomo : https://github.com/tyok
	//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var id = moment.defineLocale('id', {
	        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
	        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
	        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /pagi|siang|sore|malam/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'siang') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'sore' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'siang';
	            } else if (hours < 19) {
	                return 'sore';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Besok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kemarin pukul] LT',
	            lastWeek : 'dddd [lalu pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lalu',
	            s : 'beberapa detik',
	            m : 'semenit',
	            mm : '%d menit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return id;

	}));

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Icelandic [is]
	//! author : Hinrik Örn Sigurðsson : https://github.com/hinrik

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function plural(n) {
	        if (n % 100 === 11) {
	            return true;
	        } else if (n % 10 === 1) {
	            return false;
	        }
	        return true;
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	            case 's':
	                return withoutSuffix || isFuture ? 'nokkrar sekúndur' : 'nokkrum sekúndum';
	            case 'm':
	                return withoutSuffix ? 'mínúta' : 'mínútu';
	            case 'mm':
	                if (plural(number)) {
	                    return result + (withoutSuffix || isFuture ? 'mínútur' : 'mínútum');
	                } else if (withoutSuffix) {
	                    return result + 'mínúta';
	                }
	                return result + 'mínútu';
	            case 'hh':
	                if (plural(number)) {
	                    return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
	                }
	                return result + 'klukkustund';
	            case 'd':
	                if (withoutSuffix) {
	                    return 'dagur';
	                }
	                return isFuture ? 'dag' : 'degi';
	            case 'dd':
	                if (plural(number)) {
	                    if (withoutSuffix) {
	                        return result + 'dagar';
	                    }
	                    return result + (isFuture ? 'daga' : 'dögum');
	                } else if (withoutSuffix) {
	                    return result + 'dagur';
	                }
	                return result + (isFuture ? 'dag' : 'degi');
	            case 'M':
	                if (withoutSuffix) {
	                    return 'mánuður';
	                }
	                return isFuture ? 'mánuð' : 'mánuði';
	            case 'MM':
	                if (plural(number)) {
	                    if (withoutSuffix) {
	                        return result + 'mánuðir';
	                    }
	                    return result + (isFuture ? 'mánuði' : 'mánuðum');
	                } else if (withoutSuffix) {
	                    return result + 'mánuður';
	                }
	                return result + (isFuture ? 'mánuð' : 'mánuði');
	            case 'y':
	                return withoutSuffix || isFuture ? 'ár' : 'ári';
	            case 'yy':
	                if (plural(number)) {
	                    return result + (withoutSuffix || isFuture ? 'ár' : 'árum');
	                }
	                return result + (withoutSuffix || isFuture ? 'ár' : 'ári');
	        }
	    }

	    var is = moment.defineLocale('is', {
	        months : 'janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des'.split('_'),
	        weekdays : 'sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur'.split('_'),
	        weekdaysShort : 'sun_mán_þri_mið_fim_fös_lau'.split('_'),
	        weekdaysMin : 'Su_Má_Þr_Mi_Fi_Fö_La'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] H:mm',
	            LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
	        },
	        calendar : {
	            sameDay : '[í dag kl.] LT',
	            nextDay : '[á morgun kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[í gær kl.] LT',
	            lastWeek : '[síðasta] dddd [kl.] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'eftir %s',
	            past : 'fyrir %s síðan',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : 'klukkustund',
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return is;

	}));

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Italian [it]
	//! author : Lorenzo : https://github.com/aliem
	//! author: Mattia Larentis: https://github.com/nostalgiaz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var it = moment.defineLocale('it', {
	        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
	        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
	        weekdays : 'Domenica_Lunedì_Martedì_Mercoledì_Giovedì_Venerdì_Sabato'.split('_'),
	        weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
	        weekdaysMin : 'Do_Lu_Ma_Me_Gi_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Oggi alle] LT',
	            nextDay: '[Domani alle] LT',
	            nextWeek: 'dddd [alle] LT',
	            lastDay: '[Ieri alle] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[la scorsa] dddd [alle] LT';
	                    default:
	                        return '[lo scorso] dddd [alle] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : function (s) {
	                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
	            },
	            past : '%s fa',
	            s : 'alcuni secondi',
	            m : 'un minuto',
	            mm : '%d minuti',
	            h : 'un\'ora',
	            hh : '%d ore',
	            d : 'un giorno',
	            dd : '%d giorni',
	            M : 'un mese',
	            MM : '%d mesi',
	            y : 'un anno',
	            yy : '%d anni'
	        },
	        ordinalParse : /\d{1,2}º/,
	        ordinal: '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return it;

	}));

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Japanese [ja]
	//! author : LI Long : https://github.com/baryon

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ja = moment.defineLocale('ja', {
	        months : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        weekdays : '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
	        weekdaysShort : '日_月_火_水_木_金_土'.split('_'),
	        weekdaysMin : '日_月_火_水_木_金_土'.split('_'),
	        longDateFormat : {
	            LT : 'Ah時m分',
	            LTS : 'Ah時m分s秒',
	            L : 'YYYY/MM/DD',
	            LL : 'YYYY年M月D日',
	            LLL : 'YYYY年M月D日Ah時m分',
	            LLLL : 'YYYY年M月D日Ah時m分 dddd'
	        },
	        meridiemParse: /午前|午後/i,
	        isPM : function (input) {
	            return input === '午後';
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '午前';
	            } else {
	                return '午後';
	            }
	        },
	        calendar : {
	            sameDay : '[今日] LT',
	            nextDay : '[明日] LT',
	            nextWeek : '[来週]dddd LT',
	            lastDay : '[昨日] LT',
	            lastWeek : '[前週]dddd LT',
	            sameElse : 'L'
	        },
	        ordinalParse : /\d{1,2}日/,
	        ordinal : function (number, period) {
	            switch (period) {
	                case 'd':
	                case 'D':
	                case 'DDD':
	                    return number + '日';
	                default:
	                    return number;
	            }
	        },
	        relativeTime : {
	            future : '%s後',
	            past : '%s前',
	            s : '数秒',
	            m : '1分',
	            mm : '%d分',
	            h : '1時間',
	            hh : '%d時間',
	            d : '1日',
	            dd : '%d日',
	            M : '1ヶ月',
	            MM : '%dヶ月',
	            y : '1年',
	            yy : '%d年'
	        }
	    });

	    return ja;

	}));

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Japanese [jv]
	//! author : Rony Lantip : https://github.com/lantip
	//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var jv = moment.defineLocale('jv', {
	        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
	        weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
	        weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
	        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /enjing|siyang|sonten|ndalu/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'enjing') {
	                return hour;
	            } else if (meridiem === 'siyang') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'enjing';
	            } else if (hours < 15) {
	                return 'siyang';
	            } else if (hours < 19) {
	                return 'sonten';
	            } else {
	                return 'ndalu';
	            }
	        },
	        calendar : {
	            sameDay : '[Dinten puniko pukul] LT',
	            nextDay : '[Mbenjang pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kala wingi pukul] LT',
	            lastWeek : 'dddd [kepengker pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'wonten ing %s',
	            past : '%s ingkang kepengker',
	            s : 'sawetawis detik',
	            m : 'setunggal menit',
	            mm : '%d menit',
	            h : 'setunggal jam',
	            hh : '%d jam',
	            d : 'sedinten',
	            dd : '%d dinten',
	            M : 'sewulan',
	            MM : '%d wulan',
	            y : 'setaun',
	            yy : '%d taun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return jv;

	}));

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Georgian [ka]
	//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ka = moment.defineLocale('ka', {
	        months : {
	            standalone: 'იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი'.split('_'),
	            format: 'იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს'.split('_')
	        },
	        monthsShort : 'იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ'.split('_'),
	        weekdays : {
	            standalone: 'კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი'.split('_'),
	            format: 'კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს'.split('_'),
	            isFormat: /(წინა|შემდეგ)/
	        },
	        weekdaysShort : 'კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ'.split('_'),
	        weekdaysMin : 'კვ_ორ_სა_ოთ_ხუ_პა_შა'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[დღეს] LT[-ზე]',
	            nextDay : '[ხვალ] LT[-ზე]',
	            lastDay : '[გუშინ] LT[-ზე]',
	            nextWeek : '[შემდეგ] dddd LT[-ზე]',
	            lastWeek : '[წინა] dddd LT-ზე',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : function (s) {
	                return (/(წამი|წუთი|საათი|წელი)/).test(s) ?
	                    s.replace(/ი$/, 'ში') :
	                    s + 'ში';
	            },
	            past : function (s) {
	                if ((/(წამი|წუთი|საათი|დღე|თვე)/).test(s)) {
	                    return s.replace(/(ი|ე)$/, 'ის წინ');
	                }
	                if ((/წელი/).test(s)) {
	                    return s.replace(/წელი$/, 'წლის წინ');
	                }
	            },
	            s : 'რამდენიმე წამი',
	            m : 'წუთი',
	            mm : '%d წუთი',
	            h : 'საათი',
	            hh : '%d საათი',
	            d : 'დღე',
	            dd : '%d დღე',
	            M : 'თვე',
	            MM : '%d თვე',
	            y : 'წელი',
	            yy : '%d წელი'
	        },
	        ordinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
	        ordinal : function (number) {
	            if (number === 0) {
	                return number;
	            }
	            if (number === 1) {
	                return number + '-ლი';
	            }
	            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
	                return 'მე-' + number;
	            }
	            return number + '-ე';
	        },
	        week : {
	            dow : 1,
	            doy : 7
	        }
	    });

	    return ka;

	}));

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Kazakh [kk]
	//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var suffixes = {
	        0: '-ші',
	        1: '-ші',
	        2: '-ші',
	        3: '-ші',
	        4: '-ші',
	        5: '-ші',
	        6: '-шы',
	        7: '-ші',
	        8: '-ші',
	        9: '-шы',
	        10: '-шы',
	        20: '-шы',
	        30: '-шы',
	        40: '-шы',
	        50: '-ші',
	        60: '-шы',
	        70: '-ші',
	        80: '-ші',
	        90: '-шы',
	        100: '-ші'
	    };

	    var kk = moment.defineLocale('kk', {
	        months : 'қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан'.split('_'),
	        monthsShort : 'қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел'.split('_'),
	        weekdays : 'жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі'.split('_'),
	        weekdaysShort : 'жек_дүй_сей_сәр_бей_жұм_сен'.split('_'),
	        weekdaysMin : 'жк_дй_сй_ср_бй_жм_сн'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Бүгін сағат] LT',
	            nextDay : '[Ертең сағат] LT',
	            nextWeek : 'dddd [сағат] LT',
	            lastDay : '[Кеше сағат] LT',
	            lastWeek : '[Өткен аптаның] dddd [сағат] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ішінде',
	            past : '%s бұрын',
	            s : 'бірнеше секунд',
	            m : 'бір минут',
	            mm : '%d минут',
	            h : 'бір сағат',
	            hh : '%d сағат',
	            d : 'бір күн',
	            dd : '%d күн',
	            M : 'бір ай',
	            MM : '%d ай',
	            y : 'бір жыл',
	            yy : '%d жыл'
	        },
	        ordinalParse: /\d{1,2}-(ші|шы)/,
	        ordinal : function (number) {
	            var a = number % 10,
	                b = number >= 100 ? 100 : null;
	            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return kk;

	}));

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Cambodian [km]
	//! author : Kruy Vanna : https://github.com/kruyvanna

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var km = moment.defineLocale('km', {
	        months: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
	        monthsShort: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
	        weekdays: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	        weekdaysShort: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	        weekdaysMin: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[ថ្ងៃនេះ ម៉ោង] LT',
	            nextDay: '[ស្អែក ម៉ោង] LT',
	            nextWeek: 'dddd [ម៉ោង] LT',
	            lastDay: '[ម្សិលមិញ ម៉ោង] LT',
	            lastWeek: 'dddd [សប្តាហ៍មុន] [ម៉ោង] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: '%sទៀត',
	            past: '%sមុន',
	            s: 'ប៉ុន្មានវិនាទី',
	            m: 'មួយនាទី',
	            mm: '%d នាទី',
	            h: 'មួយម៉ោង',
	            hh: '%d ម៉ោង',
	            d: 'មួយថ្ងៃ',
	            dd: '%d ថ្ងៃ',
	            M: 'មួយខែ',
	            MM: '%d ខែ',
	            y: 'មួយឆ្នាំ',
	            yy: '%d ឆ្នាំ'
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return km;

	}));

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Korean [ko]
	//! author : Kyungwook, Park : https://github.com/kyungw00k
	//! author : Jeeeyul Lee <jeeeyul@gmail.com>

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ko = moment.defineLocale('ko', {
	        months : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
	        monthsShort : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
	        weekdays : '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),
	        weekdaysShort : '일_월_화_수_목_금_토'.split('_'),
	        weekdaysMin : '일_월_화_수_목_금_토'.split('_'),
	        longDateFormat : {
	            LT : 'A h시 m분',
	            LTS : 'A h시 m분 s초',
	            L : 'YYYY.MM.DD',
	            LL : 'YYYY년 MMMM D일',
	            LLL : 'YYYY년 MMMM D일 A h시 m분',
	            LLLL : 'YYYY년 MMMM D일 dddd A h시 m분'
	        },
	        calendar : {
	            sameDay : '오늘 LT',
	            nextDay : '내일 LT',
	            nextWeek : 'dddd LT',
	            lastDay : '어제 LT',
	            lastWeek : '지난주 dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s 후',
	            past : '%s 전',
	            s : '몇 초',
	            ss : '%d초',
	            m : '일분',
	            mm : '%d분',
	            h : '한 시간',
	            hh : '%d시간',
	            d : '하루',
	            dd : '%d일',
	            M : '한 달',
	            MM : '%d달',
	            y : '일 년',
	            yy : '%d년'
	        },
	        ordinalParse : /\d{1,2}일/,
	        ordinal : '%d일',
	        meridiemParse : /오전|오후/,
	        isPM : function (token) {
	            return token === '오후';
	        },
	        meridiem : function (hour, minute, isUpper) {
	            return hour < 12 ? '오전' : '오후';
	        }
	    });

	    return ko;

	}));

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Kyrgyz [ky]
	//! author : Chyngyz Arystan uulu : https://github.com/chyngyz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';



	    var suffixes = {
	        0: '-чү',
	        1: '-чи',
	        2: '-чи',
	        3: '-чү',
	        4: '-чү',
	        5: '-чи',
	        6: '-чы',
	        7: '-чи',
	        8: '-чи',
	        9: '-чу',
	        10: '-чу',
	        20: '-чы',
	        30: '-чу',
	        40: '-чы',
	        50: '-чү',
	        60: '-чы',
	        70: '-чи',
	        80: '-чи',
	        90: '-чу',
	        100: '-чү'
	    };

	    var ky = moment.defineLocale('ky', {
	        months : 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_'),
	        monthsShort : 'янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек'.split('_'),
	        weekdays : 'Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби'.split('_'),
	        weekdaysShort : 'Жек_Дүй_Шей_Шар_Бей_Жум_Ише'.split('_'),
	        weekdaysMin : 'Жк_Дй_Шй_Шр_Бй_Жм_Иш'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Бүгүн саат] LT',
	            nextDay : '[Эртең саат] LT',
	            nextWeek : 'dddd [саат] LT',
	            lastDay : '[Кече саат] LT',
	            lastWeek : '[Өткен аптанын] dddd [күнү] [саат] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ичинде',
	            past : '%s мурун',
	            s : 'бирнече секунд',
	            m : 'бир мүнөт',
	            mm : '%d мүнөт',
	            h : 'бир саат',
	            hh : '%d саат',
	            d : 'бир күн',
	            dd : '%d күн',
	            M : 'бир ай',
	            MM : '%d ай',
	            y : 'бир жыл',
	            yy : '%d жыл'
	        },
	        ordinalParse: /\d{1,2}-(чи|чы|чү|чу)/,
	        ordinal : function (number) {
	            var a = number % 10,
	                b = number >= 100 ? 100 : null;
	            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ky;

	}));

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Luxembourgish [lb]
	//! author : mweimerskirch : https://github.com/mweimerskirch
	//! author : David Raison : https://github.com/kwisatz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eng Minutt', 'enger Minutt'],
	            'h': ['eng Stonn', 'enger Stonn'],
	            'd': ['een Dag', 'engem Dag'],
	            'M': ['ee Mount', 'engem Mount'],
	            'y': ['ee Joer', 'engem Joer']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }
	    function processFutureTime(string) {
	        var number = string.substr(0, string.indexOf(' '));
	        if (eifelerRegelAppliesToNumber(number)) {
	            return 'a ' + string;
	        }
	        return 'an ' + string;
	    }
	    function processPastTime(string) {
	        var number = string.substr(0, string.indexOf(' '));
	        if (eifelerRegelAppliesToNumber(number)) {
	            return 'viru ' + string;
	        }
	        return 'virun ' + string;
	    }
	    /**
	     * Returns true if the word before the given number loses the '-n' ending.
	     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
	     *
	     * @param number {integer}
	     * @returns {boolean}
	     */
	    function eifelerRegelAppliesToNumber(number) {
	        number = parseInt(number, 10);
	        if (isNaN(number)) {
	            return false;
	        }
	        if (number < 0) {
	            // Negative Number --> always true
	            return true;
	        } else if (number < 10) {
	            // Only 1 digit
	            if (4 <= number && number <= 7) {
	                return true;
	            }
	            return false;
	        } else if (number < 100) {
	            // 2 digits
	            var lastDigit = number % 10, firstDigit = number / 10;
	            if (lastDigit === 0) {
	                return eifelerRegelAppliesToNumber(firstDigit);
	            }
	            return eifelerRegelAppliesToNumber(lastDigit);
	        } else if (number < 10000) {
	            // 3 or 4 digits --> recursively check first digit
	            while (number >= 10) {
	                number = number / 10;
	            }
	            return eifelerRegelAppliesToNumber(number);
	        } else {
	            // Anything larger than 4 digits: recursively check first n-3 digits
	            number = number / 1000;
	            return eifelerRegelAppliesToNumber(number);
	        }
	    }

	    var lb = moment.defineLocale('lb', {
	        months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        monthsParseExact : true,
	        weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
	        weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),
	        weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat: {
	            LT: 'H:mm [Auer]',
	            LTS: 'H:mm:ss [Auer]',
	            L: 'DD.MM.YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm [Auer]',
	            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
	        },
	        calendar: {
	            sameDay: '[Haut um] LT',
	            sameElse: 'L',
	            nextDay: '[Muer um] LT',
	            nextWeek: 'dddd [um] LT',
	            lastDay: '[Gëschter um] LT',
	            lastWeek: function () {
	                // Different date string for 'Dënschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
	                switch (this.day()) {
	                    case 2:
	                    case 4:
	                        return '[Leschten] dddd [um] LT';
	                    default:
	                        return '[Leschte] dddd [um] LT';
	                }
	            }
	        },
	        relativeTime : {
	            future : processFutureTime,
	            past : processPastTime,
	            s : 'e puer Sekonnen',
	            m : processRelativeTime,
	            mm : '%d Minutten',
	            h : processRelativeTime,
	            hh : '%d Stonnen',
	            d : processRelativeTime,
	            dd : '%d Deeg',
	            M : processRelativeTime,
	            MM : '%d Méint',
	            y : processRelativeTime,
	            yy : '%d Joer'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal: '%d.',
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return lb;

	}));

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lao [lo]
	//! author : Ryan Hart : https://github.com/ryanhart2

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var lo = moment.defineLocale('lo', {
	        months : 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
	        monthsShort : 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
	        weekdays : 'ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
	        weekdaysShort : 'ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
	        weekdaysMin : 'ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'ວັນdddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
	        isPM: function (input) {
	            return input === 'ຕອນແລງ';
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ຕອນເຊົ້າ';
	            } else {
	                return 'ຕອນແລງ';
	            }
	        },
	        calendar : {
	            sameDay : '[ມື້ນີ້ເວລາ] LT',
	            nextDay : '[ມື້ອື່ນເວລາ] LT',
	            nextWeek : '[ວັນ]dddd[ໜ້າເວລາ] LT',
	            lastDay : '[ມື້ວານນີ້ເວລາ] LT',
	            lastWeek : '[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'ອີກ %s',
	            past : '%sຜ່ານມາ',
	            s : 'ບໍ່ເທົ່າໃດວິນາທີ',
	            m : '1 ນາທີ',
	            mm : '%d ນາທີ',
	            h : '1 ຊົ່ວໂມງ',
	            hh : '%d ຊົ່ວໂມງ',
	            d : '1 ມື້',
	            dd : '%d ມື້',
	            M : '1 ເດືອນ',
	            MM : '%d ເດືອນ',
	            y : '1 ປີ',
	            yy : '%d ປີ'
	        },
	        ordinalParse: /(ທີ່)\d{1,2}/,
	        ordinal : function (number) {
	            return 'ທີ່' + number;
	        }
	    });

	    return lo;

	}));

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lithuanian [lt]
	//! author : Mindaugas Mozūras : https://github.com/mmozuras

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var units = {
	        'm' : 'minutė_minutės_minutę',
	        'mm': 'minutės_minučių_minutes',
	        'h' : 'valanda_valandos_valandą',
	        'hh': 'valandos_valandų_valandas',
	        'd' : 'diena_dienos_dieną',
	        'dd': 'dienos_dienų_dienas',
	        'M' : 'mėnuo_mėnesio_mėnesį',
	        'MM': 'mėnesiai_mėnesių_mėnesius',
	        'y' : 'metai_metų_metus',
	        'yy': 'metai_metų_metus'
	    };
	    function translateSeconds(number, withoutSuffix, key, isFuture) {
	        if (withoutSuffix) {
	            return 'kelios sekundės';
	        } else {
	            return isFuture ? 'kelių sekundžių' : 'kelias sekundes';
	        }
	    }
	    function translateSingular(number, withoutSuffix, key, isFuture) {
	        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
	    }
	    function special(number) {
	        return number % 10 === 0 || (number > 10 && number < 20);
	    }
	    function forms(key) {
	        return units[key].split('_');
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        if (number === 1) {
	            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
	        } else if (withoutSuffix) {
	            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
	        } else {
	            if (isFuture) {
	                return result + forms(key)[1];
	            } else {
	                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
	            }
	        }
	    }
	    var lt = moment.defineLocale('lt', {
	        months : {
	            format: 'sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio'.split('_'),
	            standalone: 'sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis'.split('_'),
	            isFormat: /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?|MMMM?(\[[^\[\]]*\]|\s+)+D[oD]?/
	        },
	        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
	        weekdays : {
	            format: 'sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį'.split('_'),
	            standalone: 'sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis'.split('_'),
	            isFormat: /dddd HH:mm/
	        },
	        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_Šeš'.split('_'),
	        weekdaysMin : 'S_P_A_T_K_Pn_Š'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY [m.] MMMM D [d.]',
	            LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	            LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
	            l : 'YYYY-MM-DD',
	            ll : 'YYYY [m.] MMMM D [d.]',
	            lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	            llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
	        },
	        calendar : {
	            sameDay : '[Šiandien] LT',
	            nextDay : '[Rytoj] LT',
	            nextWeek : 'dddd LT',
	            lastDay : '[Vakar] LT',
	            lastWeek : '[Praėjusį] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'po %s',
	            past : 'prieš %s',
	            s : translateSeconds,
	            m : translateSingular,
	            mm : translate,
	            h : translateSingular,
	            hh : translate,
	            d : translateSingular,
	            dd : translate,
	            M : translateSingular,
	            MM : translate,
	            y : translateSingular,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}-oji/,
	        ordinal : function (number) {
	            return number + '-oji';
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return lt;

	}));

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Latvian [lv]
	//! author : Kristaps Karlsons : https://github.com/skakri
	//! author : Jānis Elmeris : https://github.com/JanisE

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var units = {
	        'm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
	        'mm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
	        'h': 'stundas_stundām_stunda_stundas'.split('_'),
	        'hh': 'stundas_stundām_stunda_stundas'.split('_'),
	        'd': 'dienas_dienām_diena_dienas'.split('_'),
	        'dd': 'dienas_dienām_diena_dienas'.split('_'),
	        'M': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
	        'MM': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
	        'y': 'gada_gadiem_gads_gadi'.split('_'),
	        'yy': 'gada_gadiem_gads_gadi'.split('_')
	    };
	    /**
	     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
	     */
	    function format(forms, number, withoutSuffix) {
	        if (withoutSuffix) {
	            // E.g. "21 minūte", "3 minūtes".
	            return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
	        } else {
	            // E.g. "21 minūtes" as in "pēc 21 minūtes".
	            // E.g. "3 minūtēm" as in "pēc 3 minūtēm".
	            return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
	        }
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        return number + ' ' + format(units[key], number, withoutSuffix);
	    }
	    function relativeTimeWithSingular(number, withoutSuffix, key) {
	        return format(units[key], number, withoutSuffix);
	    }
	    function relativeSeconds(number, withoutSuffix) {
	        return withoutSuffix ? 'dažas sekundes' : 'dažām sekundēm';
	    }

	    var lv = moment.defineLocale('lv', {
	        months : 'janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena'.split('_'),
	        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
	        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY.',
	            LL : 'YYYY. [gada] D. MMMM',
	            LLL : 'YYYY. [gada] D. MMMM, HH:mm',
	            LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
	        },
	        calendar : {
	            sameDay : '[Šodien pulksten] LT',
	            nextDay : '[Rīt pulksten] LT',
	            nextWeek : 'dddd [pulksten] LT',
	            lastDay : '[Vakar pulksten] LT',
	            lastWeek : '[Pagājušā] dddd [pulksten] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'pēc %s',
	            past : 'pirms %s',
	            s : relativeSeconds,
	            m : relativeTimeWithSingular,
	            mm : relativeTimeWithPlural,
	            h : relativeTimeWithSingular,
	            hh : relativeTimeWithPlural,
	            d : relativeTimeWithSingular,
	            dd : relativeTimeWithPlural,
	            M : relativeTimeWithSingular,
	            MM : relativeTimeWithPlural,
	            y : relativeTimeWithSingular,
	            yy : relativeTimeWithPlural
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return lv;

	}));

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Montenegrin [me]
	//! author : Miodrag Nikač <miodrag@restartit.me> : https://github.com/miodragnikac

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var translator = {
	        words: { //Different grammatical cases
	            m: ['jedan minut', 'jednog minuta'],
	            mm: ['minut', 'minuta', 'minuta'],
	            h: ['jedan sat', 'jednog sata'],
	            hh: ['sat', 'sata', 'sati'],
	            dd: ['dan', 'dana', 'dana'],
	            MM: ['mjesec', 'mjeseca', 'mjeseci'],
	            yy: ['godina', 'godine', 'godina']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };

	    var me = moment.defineLocale('me', {
	        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
	        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
	        monthsParseExact : true,
	        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
	        weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
	        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L: 'DD.MM.YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm',
	            LLLL: 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar: {
	            sameDay: '[danas u] LT',
	            nextDay: '[sjutra u] LT',

	            nextWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[u] [nedjelju] [u] LT';
	                    case 3:
	                        return '[u] [srijedu] [u] LT';
	                    case 6:
	                        return '[u] [subotu] [u] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[juče u] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[prošle] [nedjelje] [u] LT',
	                    '[prošlog] [ponedjeljka] [u] LT',
	                    '[prošlog] [utorka] [u] LT',
	                    '[prošle] [srijede] [u] LT',
	                    '[prošlog] [četvrtka] [u] LT',
	                    '[prošlog] [petka] [u] LT',
	                    '[prošle] [subote] [u] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'nekoliko sekundi',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'dan',
	            dd     : translator.translate,
	            M      : 'mjesec',
	            MM     : translator.translate,
	            y      : 'godinu',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return me;

	}));

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Maori [mi]
	//! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var mi = moment.defineLocale('mi', {
	        months: 'Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea'.split('_'),
	        monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
	        monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	        monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	        monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	        monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
	        weekdays: 'Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei'.split('_'),
	        weekdaysShort: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
	        weekdaysMin: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY [i] HH:mm',
	            LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
	        },
	        calendar: {
	            sameDay: '[i teie mahana, i] LT',
	            nextDay: '[apopo i] LT',
	            nextWeek: 'dddd [i] LT',
	            lastDay: '[inanahi i] LT',
	            lastWeek: 'dddd [whakamutunga i] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'i roto i %s',
	            past: '%s i mua',
	            s: 'te hēkona ruarua',
	            m: 'he meneti',
	            mm: '%d meneti',
	            h: 'te haora',
	            hh: '%d haora',
	            d: 'he ra',
	            dd: '%d ra',
	            M: 'he marama',
	            MM: '%d marama',
	            y: 'he tau',
	            yy: '%d tau'
	        },
	        ordinalParse: /\d{1,2}º/,
	        ordinal: '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return mi;

	}));

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Macedonian [mk]
	//! author : Borislav Mickov : https://github.com/B0k0

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var mk = moment.defineLocale('mk', {
	        months : 'јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември'.split('_'),
	        monthsShort : 'јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек'.split('_'),
	        weekdays : 'недела_понеделник_вторник_среда_четврток_петок_сабота'.split('_'),
	        weekdaysShort : 'нед_пон_вто_сре_чет_пет_саб'.split('_'),
	        weekdaysMin : 'нe_пo_вт_ср_че_пе_сa'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'D.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : '[Денес во] LT',
	            nextDay : '[Утре во] LT',
	            nextWeek : '[Во] dddd [во] LT',
	            lastDay : '[Вчера во] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                    case 3:
	                    case 6:
	                        return '[Изминатата] dddd [во] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[Изминатиот] dddd [во] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'после %s',
	            past : 'пред %s',
	            s : 'неколку секунди',
	            m : 'минута',
	            mm : '%d минути',
	            h : 'час',
	            hh : '%d часа',
	            d : 'ден',
	            dd : '%d дена',
	            M : 'месец',
	            MM : '%d месеци',
	            y : 'година',
	            yy : '%d години'
	        },
	        ordinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
	        ordinal : function (number) {
	            var lastDigit = number % 10,
	                last2Digits = number % 100;
	            if (number === 0) {
	                return number + '-ев';
	            } else if (last2Digits === 0) {
	                return number + '-ен';
	            } else if (last2Digits > 10 && last2Digits < 20) {
	                return number + '-ти';
	            } else if (lastDigit === 1) {
	                return number + '-ви';
	            } else if (lastDigit === 2) {
	                return number + '-ри';
	            } else if (lastDigit === 7 || lastDigit === 8) {
	                return number + '-ми';
	            } else {
	                return number + '-ти';
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return mk;

	}));

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malayalam [ml]
	//! author : Floyd Pink : https://github.com/floydpink

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ml = moment.defineLocale('ml', {
	        months : 'ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ'.split('_'),
	        monthsShort : 'ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച'.split('_'),
	        weekdaysShort : 'ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി'.split('_'),
	        weekdaysMin : 'ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm -നു',
	            LTS : 'A h:mm:ss -നു',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm -നു',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm -നു'
	        },
	        calendar : {
	            sameDay : '[ഇന്ന്] LT',
	            nextDay : '[നാളെ] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[ഇന്നലെ] LT',
	            lastWeek : '[കഴിഞ്ഞ] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s കഴിഞ്ഞ്',
	            past : '%s മുൻപ്',
	            s : 'അൽപ നിമിഷങ്ങൾ',
	            m : 'ഒരു മിനിറ്റ്',
	            mm : '%d മിനിറ്റ്',
	            h : 'ഒരു മണിക്കൂർ',
	            hh : '%d മണിക്കൂർ',
	            d : 'ഒരു ദിവസം',
	            dd : '%d ദിവസം',
	            M : 'ഒരു മാസം',
	            MM : '%d മാസം',
	            y : 'ഒരു വർഷം',
	            yy : '%d വർഷം'
	        },
	        meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if ((meridiem === 'രാത്രി' && hour >= 4) ||
	                    meridiem === 'ഉച്ച കഴിഞ്ഞ്' ||
	                    meridiem === 'വൈകുന്നേരം') {
	                return hour + 12;
	            } else {
	                return hour;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'രാത്രി';
	            } else if (hour < 12) {
	                return 'രാവിലെ';
	            } else if (hour < 17) {
	                return 'ഉച്ച കഴിഞ്ഞ്';
	            } else if (hour < 20) {
	                return 'വൈകുന്നേരം';
	            } else {
	                return 'രാത്രി';
	            }
	        }
	    });

	    return ml;

	}));

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Marathi [mr]
	//! author : Harshad Kale : https://github.com/kalehv
	//! author : Vivek Athalye : https://github.com/vnathalye

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '१',
	        '2': '२',
	        '3': '३',
	        '4': '४',
	        '5': '५',
	        '6': '६',
	        '7': '७',
	        '8': '८',
	        '9': '९',
	        '0': '०'
	    },
	    numberMap = {
	        '१': '1',
	        '२': '2',
	        '३': '3',
	        '४': '4',
	        '५': '5',
	        '६': '6',
	        '७': '7',
	        '८': '8',
	        '९': '9',
	        '०': '0'
	    };

	    function relativeTimeMr(number, withoutSuffix, string, isFuture)
	    {
	        var output = '';
	        if (withoutSuffix) {
	            switch (string) {
	                case 's': output = 'काही सेकंद'; break;
	                case 'm': output = 'एक मिनिट'; break;
	                case 'mm': output = '%d मिनिटे'; break;
	                case 'h': output = 'एक तास'; break;
	                case 'hh': output = '%d तास'; break;
	                case 'd': output = 'एक दिवस'; break;
	                case 'dd': output = '%d दिवस'; break;
	                case 'M': output = 'एक महिना'; break;
	                case 'MM': output = '%d महिने'; break;
	                case 'y': output = 'एक वर्ष'; break;
	                case 'yy': output = '%d वर्षे'; break;
	            }
	        }
	        else {
	            switch (string) {
	                case 's': output = 'काही सेकंदां'; break;
	                case 'm': output = 'एका मिनिटा'; break;
	                case 'mm': output = '%d मिनिटां'; break;
	                case 'h': output = 'एका तासा'; break;
	                case 'hh': output = '%d तासां'; break;
	                case 'd': output = 'एका दिवसा'; break;
	                case 'dd': output = '%d दिवसां'; break;
	                case 'M': output = 'एका महिन्या'; break;
	                case 'MM': output = '%d महिन्यां'; break;
	                case 'y': output = 'एका वर्षा'; break;
	                case 'yy': output = '%d वर्षां'; break;
	            }
	        }
	        return output.replace(/%d/i, number);
	    }

	    var mr = moment.defineLocale('mr', {
	        months : 'जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split('_'),
	        monthsShort: 'जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
	        weekdaysShort : 'रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि'.split('_'),
	        weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm वाजता',
	            LTS : 'A h:mm:ss वाजता',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm वाजता',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm वाजता'
	        },
	        calendar : {
	            sameDay : '[आज] LT',
	            nextDay : '[उद्या] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[काल] LT',
	            lastWeek: '[मागील] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future: '%sमध्ये',
	            past: '%sपूर्वी',
	            s: relativeTimeMr,
	            m: relativeTimeMr,
	            mm: relativeTimeMr,
	            h: relativeTimeMr,
	            hh: relativeTimeMr,
	            d: relativeTimeMr,
	            dd: relativeTimeMr,
	            M: relativeTimeMr,
	            MM: relativeTimeMr,
	            y: relativeTimeMr,
	            yy: relativeTimeMr
	        },
	        preparse: function (string) {
	            return string.replace(/[१२३४५६७८९०]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /रात्री|सकाळी|दुपारी|सायंकाळी/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'रात्री') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === 'सकाळी') {
	                return hour;
	            } else if (meridiem === 'दुपारी') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'सायंकाळी') {
	                return hour + 12;
	            }
	        },
	        meridiem: function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'रात्री';
	            } else if (hour < 10) {
	                return 'सकाळी';
	            } else if (hour < 17) {
	                return 'दुपारी';
	            } else if (hour < 20) {
	                return 'सायंकाळी';
	            } else {
	                return 'रात्री';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return mr;

	}));

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malay [ms]
	//! author : Weldan Jamili : https://github.com/weldan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ms = moment.defineLocale('ms', {
	        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /pagi|tengahari|petang|malam/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'tengahari') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'petang' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'tengahari';
	            } else if (hours < 19) {
	                return 'petang';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Esok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kelmarin pukul] LT',
	            lastWeek : 'dddd [lepas pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lepas',
	            s : 'beberapa saat',
	            m : 'seminit',
	            mm : '%d minit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ms;

	}));

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malay [ms-my]
	//! note : DEPRECATED, the correct one is [ms]
	//! author : Weldan Jamili : https://github.com/weldan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ms_my = moment.defineLocale('ms-my', {
	        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /pagi|tengahari|petang|malam/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'tengahari') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'petang' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'tengahari';
	            } else if (hours < 19) {
	                return 'petang';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Esok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kelmarin pukul] LT',
	            lastWeek : 'dddd [lepas pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lepas',
	            s : 'beberapa saat',
	            m : 'seminit',
	            mm : '%d minit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ms_my;

	}));

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Burmese [my]
	//! author : Squar team, mysquar.com
	//! author : David Rossellat : https://github.com/gholadr
	//! author : Tin Aung Lin : https://github.com/thanyawzinmin

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '၁',
	        '2': '၂',
	        '3': '၃',
	        '4': '၄',
	        '5': '၅',
	        '6': '၆',
	        '7': '၇',
	        '8': '၈',
	        '9': '၉',
	        '0': '၀'
	    }, numberMap = {
	        '၁': '1',
	        '၂': '2',
	        '၃': '3',
	        '၄': '4',
	        '၅': '5',
	        '၆': '6',
	        '၇': '7',
	        '၈': '8',
	        '၉': '9',
	        '၀': '0'
	    };

	    var my = moment.defineLocale('my', {
	        months: 'ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ'.split('_'),
	        monthsShort: 'ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ'.split('_'),
	        weekdays: 'တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ'.split('_'),
	        weekdaysShort: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
	        weekdaysMin: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),

	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[ယနေ.] LT [မှာ]',
	            nextDay: '[မနက်ဖြန်] LT [မှာ]',
	            nextWeek: 'dddd LT [မှာ]',
	            lastDay: '[မနေ.က] LT [မှာ]',
	            lastWeek: '[ပြီးခဲ့သော] dddd LT [မှာ]',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'လာမည့် %s မှာ',
	            past: 'လွန်ခဲ့သော %s က',
	            s: 'စက္ကန်.အနည်းငယ်',
	            m: 'တစ်မိနစ်',
	            mm: '%d မိနစ်',
	            h: 'တစ်နာရီ',
	            hh: '%d နာရီ',
	            d: 'တစ်ရက်',
	            dd: '%d ရက်',
	            M: 'တစ်လ',
	            MM: '%d လ',
	            y: 'တစ်နှစ်',
	            yy: '%d နှစ်'
	        },
	        preparse: function (string) {
	            return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return my;

	}));

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Norwegian Bokmål [nb]
	//! authors : Espen Hovlandsdal : https://github.com/rexxars
	//!           Sigurd Gartmann : https://github.com/sigurdga

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var nb = moment.defineLocale('nb', {
	        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
	        weekdaysShort : 'sø._ma._ti._on._to._fr._lø.'.split('_'),
	        weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] HH:mm',
	            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
	        },
	        calendar : {
	            sameDay: '[i dag kl.] LT',
	            nextDay: '[i morgen kl.] LT',
	            nextWeek: 'dddd [kl.] LT',
	            lastDay: '[i går kl.] LT',
	            lastWeek: '[forrige] dddd [kl.] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : '%s siden',
	            s : 'noen sekunder',
	            m : 'ett minutt',
	            mm : '%d minutter',
	            h : 'en time',
	            hh : '%d timer',
	            d : 'en dag',
	            dd : '%d dager',
	            M : 'en måned',
	            MM : '%d måneder',
	            y : 'ett år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return nb;

	}));

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Nepalese [ne]
	//! author : suvash : https://github.com/suvash

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '१',
	        '2': '२',
	        '3': '३',
	        '4': '४',
	        '5': '५',
	        '6': '६',
	        '7': '७',
	        '8': '८',
	        '9': '९',
	        '0': '०'
	    },
	    numberMap = {
	        '१': '1',
	        '२': '2',
	        '३': '3',
	        '४': '4',
	        '५': '5',
	        '६': '6',
	        '७': '7',
	        '८': '8',
	        '९': '9',
	        '०': '0'
	    };

	    var ne = moment.defineLocale('ne', {
	        months : 'जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर'.split('_'),
	        monthsShort : 'जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार'.split('_'),
	        weekdaysShort : 'आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.'.split('_'),
	        weekdaysMin : 'आ._सो._मं._बु._बि._शु._श.'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'Aको h:mm बजे',
	            LTS : 'Aको h:mm:ss बजे',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, Aको h:mm बजे',
	            LLLL : 'dddd, D MMMM YYYY, Aको h:mm बजे'
	        },
	        preparse: function (string) {
	            return string.replace(/[१२३४५६७८९०]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'राति') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === 'बिहान') {
	                return hour;
	            } else if (meridiem === 'दिउँसो') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'साँझ') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 3) {
	                return 'राति';
	            } else if (hour < 12) {
	                return 'बिहान';
	            } else if (hour < 16) {
	                return 'दिउँसो';
	            } else if (hour < 20) {
	                return 'साँझ';
	            } else {
	                return 'राति';
	            }
	        },
	        calendar : {
	            sameDay : '[आज] LT',
	            nextDay : '[भोलि] LT',
	            nextWeek : '[आउँदो] dddd[,] LT',
	            lastDay : '[हिजो] LT',
	            lastWeek : '[गएको] dddd[,] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%sमा',
	            past : '%s अगाडि',
	            s : 'केही क्षण',
	            m : 'एक मिनेट',
	            mm : '%d मिनेट',
	            h : 'एक घण्टा',
	            hh : '%d घण्टा',
	            d : 'एक दिन',
	            dd : '%d दिन',
	            M : 'एक महिना',
	            MM : '%d महिना',
	            y : 'एक बर्ष',
	            yy : '%d बर्ष'
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ne;

	}));

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Dutch [nl]
	//! author : Joris Röling : https://github.com/jorisroling
	//! author : Jacob Middag : https://github.com/middagj

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

	    var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
	    var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

	    var nl = moment.defineLocale('nl', {
	        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShortWithoutDots[m.month()];
	            } else {
	                return monthsShortWithDots[m.month()];
	            }
	        },

	        monthsRegex: monthsRegex,
	        monthsShortRegex: monthsRegex,
	        monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
	        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

	        monthsParse : monthsParse,
	        longMonthsParse : monthsParse,
	        shortMonthsParse : monthsParse,

	        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
	        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
	        weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[vandaag om] LT',
	            nextDay: '[morgen om] LT',
	            nextWeek: 'dddd [om] LT',
	            lastDay: '[gisteren om] LT',
	            lastWeek: '[afgelopen] dddd [om] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'over %s',
	            past : '%s geleden',
	            s : 'een paar seconden',
	            m : 'één minuut',
	            mm : '%d minuten',
	            h : 'één uur',
	            hh : '%d uur',
	            d : 'één dag',
	            dd : '%d dagen',
	            M : 'één maand',
	            MM : '%d maanden',
	            y : 'één jaar',
	            yy : '%d jaar'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return nl;

	}));

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Nynorsk [nn]
	//! author : https://github.com/mechuwind

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var nn = moment.defineLocale('nn', {
	        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
	        weekdaysShort : 'sun_mån_tys_ons_tor_fre_lau'.split('_'),
	        weekdaysMin : 'su_må_ty_on_to_fr_lø'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] H:mm',
	            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
	        },
	        calendar : {
	            sameDay: '[I dag klokka] LT',
	            nextDay: '[I morgon klokka] LT',
	            nextWeek: 'dddd [klokka] LT',
	            lastDay: '[I går klokka] LT',
	            lastWeek: '[Føregåande] dddd [klokka] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : '%s sidan',
	            s : 'nokre sekund',
	            m : 'eit minutt',
	            mm : '%d minutt',
	            h : 'ein time',
	            hh : '%d timar',
	            d : 'ein dag',
	            dd : '%d dagar',
	            M : 'ein månad',
	            MM : '%d månader',
	            y : 'eit år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return nn;

	}));

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Punjabi (India) [pa-in]
	//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '੧',
	        '2': '੨',
	        '3': '੩',
	        '4': '੪',
	        '5': '੫',
	        '6': '੬',
	        '7': '੭',
	        '8': '੮',
	        '9': '੯',
	        '0': '੦'
	    },
	    numberMap = {
	        '੧': '1',
	        '੨': '2',
	        '੩': '3',
	        '੪': '4',
	        '੫': '5',
	        '੬': '6',
	        '੭': '7',
	        '੮': '8',
	        '੯': '9',
	        '੦': '0'
	    };

	    var pa_in = moment.defineLocale('pa-in', {
	        // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
	        months : 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
	        monthsShort : 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
	        weekdays : 'ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ'.split('_'),
	        weekdaysShort : 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
	        weekdaysMin : 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm ਵਜੇ',
	            LTS : 'A h:mm:ss ਵਜੇ',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm ਵਜੇ',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm ਵਜੇ'
	        },
	        calendar : {
	            sameDay : '[ਅਜ] LT',
	            nextDay : '[ਕਲ] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[ਕਲ] LT',
	            lastWeek : '[ਪਿਛਲੇ] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ਵਿੱਚ',
	            past : '%s ਪਿਛਲੇ',
	            s : 'ਕੁਝ ਸਕਿੰਟ',
	            m : 'ਇਕ ਮਿੰਟ',
	            mm : '%d ਮਿੰਟ',
	            h : 'ਇੱਕ ਘੰਟਾ',
	            hh : '%d ਘੰਟੇ',
	            d : 'ਇੱਕ ਦਿਨ',
	            dd : '%d ਦਿਨ',
	            M : 'ਇੱਕ ਮਹੀਨਾ',
	            MM : '%d ਮਹੀਨੇ',
	            y : 'ਇੱਕ ਸਾਲ',
	            yy : '%d ਸਾਲ'
	        },
	        preparse: function (string) {
	            return string.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
	        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
	        meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'ਰਾਤ') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === 'ਸਵੇਰ') {
	                return hour;
	            } else if (meridiem === 'ਦੁਪਹਿਰ') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'ਸ਼ਾਮ') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'ਰਾਤ';
	            } else if (hour < 10) {
	                return 'ਸਵੇਰ';
	            } else if (hour < 17) {
	                return 'ਦੁਪਹਿਰ';
	            } else if (hour < 20) {
	                return 'ਸ਼ਾਮ';
	            } else {
	                return 'ਰਾਤ';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return pa_in;

	}));

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Polish [pl]
	//! author : Rafal Hirsz : https://github.com/evoL

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var monthsNominative = 'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split('_'),
	        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split('_');
	    function plural(n) {
	        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
	    }
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	            case 'm':
	                return withoutSuffix ? 'minuta' : 'minutę';
	            case 'mm':
	                return result + (plural(number) ? 'minuty' : 'minut');
	            case 'h':
	                return withoutSuffix  ? 'godzina'  : 'godzinę';
	            case 'hh':
	                return result + (plural(number) ? 'godziny' : 'godzin');
	            case 'MM':
	                return result + (plural(number) ? 'miesiące' : 'miesięcy');
	            case 'yy':
	                return result + (plural(number) ? 'lata' : 'lat');
	        }
	    }

	    var pl = moment.defineLocale('pl', {
	        months : function (momentToFormat, format) {
	            if (format === '') {
	                // Hack: if format empty we know this is used to generate
	                // RegExp by moment. Give then back both valid forms of months
	                // in RegExp ready format.
	                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
	            } else if (/D MMMM/.test(format)) {
	                return monthsSubjective[momentToFormat.month()];
	            } else {
	                return monthsNominative[momentToFormat.month()];
	            }
	        },
	        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
	        weekdays : 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split('_'),
	        weekdaysShort : 'nie_pon_wt_śr_czw_pt_sb'.split('_'),
	        weekdaysMin : 'Nd_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Dziś o] LT',
	            nextDay: '[Jutro o] LT',
	            nextWeek: '[W] dddd [o] LT',
	            lastDay: '[Wczoraj o] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[W zeszłą niedzielę o] LT';
	                    case 3:
	                        return '[W zeszłą środę o] LT';
	                    case 6:
	                        return '[W zeszłą sobotę o] LT';
	                    default:
	                        return '[W zeszły] dddd [o] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : '%s temu',
	            s : 'kilka sekund',
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : '1 dzień',
	            dd : '%d dni',
	            M : 'miesiąc',
	            MM : translate,
	            y : 'rok',
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return pl;

	}));

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Portuguese [pt]
	//! author : Jefferson : https://github.com/jalex79

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var pt = moment.defineLocale('pt', {
	        months : 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	        weekdays : 'Domingo_Segunda-Feira_Terça-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sábado'.split('_'),
	        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
	        weekdaysMin : 'Dom_2ª_3ª_4ª_5ª_6ª_Sáb'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY HH:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Hoje às] LT',
	            nextDay: '[Amanhã às] LT',
	            nextWeek: 'dddd [às] LT',
	            lastDay: '[Ontem às] LT',
	            lastWeek: function () {
	                return (this.day() === 0 || this.day() === 6) ?
	                    '[Último] dddd [às] LT' : // Saturday + Sunday
	                    '[Última] dddd [às] LT'; // Monday - Friday
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'em %s',
	            past : 'há %s',
	            s : 'segundos',
	            m : 'um minuto',
	            mm : '%d minutos',
	            h : 'uma hora',
	            hh : '%d horas',
	            d : 'um dia',
	            dd : '%d dias',
	            M : 'um mês',
	            MM : '%d meses',
	            y : 'um ano',
	            yy : '%d anos'
	        },
	        ordinalParse: /\d{1,2}º/,
	        ordinal : '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return pt;

	}));

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Portuguese (Brazil) [pt-br]
	//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var pt_br = moment.defineLocale('pt-br', {
	        months : 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	        weekdays : 'Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado'.split('_'),
	        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
	        weekdaysMin : 'Dom_2ª_3ª_4ª_5ª_6ª_Sáb'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY [às] HH:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY [às] HH:mm'
	        },
	        calendar : {
	            sameDay: '[Hoje às] LT',
	            nextDay: '[Amanhã às] LT',
	            nextWeek: 'dddd [às] LT',
	            lastDay: '[Ontem às] LT',
	            lastWeek: function () {
	                return (this.day() === 0 || this.day() === 6) ?
	                    '[Último] dddd [às] LT' : // Saturday + Sunday
	                    '[Última] dddd [às] LT'; // Monday - Friday
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'em %s',
	            past : '%s atrás',
	            s : 'poucos segundos',
	            m : 'um minuto',
	            mm : '%d minutos',
	            h : 'uma hora',
	            hh : '%d horas',
	            d : 'um dia',
	            dd : '%d dias',
	            M : 'um mês',
	            MM : '%d meses',
	            y : 'um ano',
	            yy : '%d anos'
	        },
	        ordinalParse: /\d{1,2}º/,
	        ordinal : '%dº'
	    });

	    return pt_br;

	}));

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Romanian [ro]
	//! author : Vlad Gurdiga : https://github.com/gurdiga
	//! author : Valentin Agachi : https://github.com/avaly

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	                'mm': 'minute',
	                'hh': 'ore',
	                'dd': 'zile',
	                'MM': 'luni',
	                'yy': 'ani'
	            },
	            separator = ' ';
	        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
	            separator = ' de ';
	        }
	        return number + separator + format[key];
	    }

	    var ro = moment.defineLocale('ro', {
	        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
	        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'duminică_luni_marți_miercuri_joi_vineri_sâmbătă'.split('_'),
	        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sâm'.split('_'),
	        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_Sâ'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay: '[azi la] LT',
	            nextDay: '[mâine la] LT',
	            nextWeek: 'dddd [la] LT',
	            lastDay: '[ieri la] LT',
	            lastWeek: '[fosta] dddd [la] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'peste %s',
	            past : '%s în urmă',
	            s : 'câteva secunde',
	            m : 'un minut',
	            mm : relativeTimeWithPlural,
	            h : 'o oră',
	            hh : relativeTimeWithPlural,
	            d : 'o zi',
	            dd : relativeTimeWithPlural,
	            M : 'o lună',
	            MM : relativeTimeWithPlural,
	            y : 'un an',
	            yy : relativeTimeWithPlural
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ro;

	}));

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Russian [ru]
	//! author : Viktorminator : https://github.com/Viktorminator
	//! Author : Menelion Elensúle : https://github.com/Oire
	//! author : Коренберг Марк : https://github.com/socketpair

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
	            'hh': 'час_часа_часов',
	            'dd': 'день_дня_дней',
	            'MM': 'месяц_месяца_месяцев',
	            'yy': 'год_года_лет'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? 'минута' : 'минуту';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	    var monthsParse = [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[йя]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i];

	    // http://new.gramota.ru/spravka/rules/139-prop : § 103
	    // Сокращения месяцев: http://new.gramota.ru/spravka/buro/search-answer?s=242637
	    // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
	    var ru = moment.defineLocale('ru', {
	        months : {
	            format: 'января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря'.split('_'),
	            standalone: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_')
	        },
	        monthsShort : {
	            // по CLDR именно "июл." и "июн.", но какой смысл менять букву на точку ?
	            format: 'янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.'.split('_'),
	            standalone: 'янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.'.split('_')
	        },
	        weekdays : {
	            standalone: 'воскресенье_понедельник_вторник_среда_четверг_пятница_суббота'.split('_'),
	            format: 'воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу'.split('_'),
	            isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/
	        },
	        weekdaysShort : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
	        weekdaysMin : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
	        monthsParse : monthsParse,
	        longMonthsParse : monthsParse,
	        shortMonthsParse : monthsParse,

	        // полные названия с падежами, по три буквы, для некоторых, по 4 буквы, сокращения с точкой и без точки
	        monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

	        // копия предыдущего
	        monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

	        // полные названия с падежами
	        monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,

	        // Выражение, которое соотвествует только сокращённым формам
	        monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY г.',
	            LLL : 'D MMMM YYYY г., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY г., HH:mm'
	        },
	        calendar : {
	            sameDay: '[Сегодня в] LT',
	            nextDay: '[Завтра в] LT',
	            lastDay: '[Вчера в] LT',
	            nextWeek: function (now) {
	                if (now.week() !== this.week()) {
	                    switch (this.day()) {
	                        case 0:
	                            return '[В следующее] dddd [в] LT';
	                        case 1:
	                        case 2:
	                        case 4:
	                            return '[В следующий] dddd [в] LT';
	                        case 3:
	                        case 5:
	                        case 6:
	                            return '[В следующую] dddd [в] LT';
	                    }
	                } else {
	                    if (this.day() === 2) {
	                        return '[Во] dddd [в] LT';
	                    } else {
	                        return '[В] dddd [в] LT';
	                    }
	                }
	            },
	            lastWeek: function (now) {
	                if (now.week() !== this.week()) {
	                    switch (this.day()) {
	                        case 0:
	                            return '[В прошлое] dddd [в] LT';
	                        case 1:
	                        case 2:
	                        case 4:
	                            return '[В прошлый] dddd [в] LT';
	                        case 3:
	                        case 5:
	                        case 6:
	                            return '[В прошлую] dddd [в] LT';
	                    }
	                } else {
	                    if (this.day() === 2) {
	                        return '[Во] dddd [в] LT';
	                    } else {
	                        return '[В] dddd [в] LT';
	                    }
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'через %s',
	            past : '%s назад',
	            s : 'несколько секунд',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : 'час',
	            hh : relativeTimeWithPlural,
	            d : 'день',
	            dd : relativeTimeWithPlural,
	            M : 'месяц',
	            MM : relativeTimeWithPlural,
	            y : 'год',
	            yy : relativeTimeWithPlural
	        },
	        meridiemParse: /ночи|утра|дня|вечера/i,
	        isPM : function (input) {
	            return /^(дня|вечера)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'ночи';
	            } else if (hour < 12) {
	                return 'утра';
	            } else if (hour < 17) {
	                return 'дня';
	            } else {
	                return 'вечера';
	            }
	        },
	        ordinalParse: /\d{1,2}-(й|го|я)/,
	        ordinal: function (number, period) {
	            switch (period) {
	                case 'M':
	                case 'd':
	                case 'DDD':
	                    return number + '-й';
	                case 'D':
	                    return number + '-го';
	                case 'w':
	                case 'W':
	                    return number + '-я';
	                default:
	                    return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ru;

	}));

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Northern Sami [se]
	//! authors : Bård Rolstad Henriksen : https://github.com/karamell

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';



	    var se = moment.defineLocale('se', {
	        months : 'ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu'.split('_'),
	        monthsShort : 'ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov'.split('_'),
	        weekdays : 'sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat'.split('_'),
	        weekdaysShort : 'sotn_vuos_maŋ_gask_duor_bear_láv'.split('_'),
	        weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'MMMM D. [b.] YYYY',
	            LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
	            LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
	        },
	        calendar : {
	            sameDay: '[otne ti] LT',
	            nextDay: '[ihttin ti] LT',
	            nextWeek: 'dddd [ti] LT',
	            lastDay: '[ikte ti] LT',
	            lastWeek: '[ovddit] dddd [ti] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s geažes',
	            past : 'maŋit %s',
	            s : 'moadde sekunddat',
	            m : 'okta minuhta',
	            mm : '%d minuhtat',
	            h : 'okta diimmu',
	            hh : '%d diimmut',
	            d : 'okta beaivi',
	            dd : '%d beaivvit',
	            M : 'okta mánnu',
	            MM : '%d mánut',
	            y : 'okta jahki',
	            yy : '%d jagit'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return se;

	}));

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Sinhalese [si]
	//! author : Sampath Sitinamaluwa : https://github.com/sampathsris

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    /*jshint -W100*/
	    var si = moment.defineLocale('si', {
	        months : 'ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්'.split('_'),
	        monthsShort : 'ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ'.split('_'),
	        weekdays : 'ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා'.split('_'),
	        weekdaysShort : 'ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන'.split('_'),
	        weekdaysMin : 'ඉ_ස_අ_බ_බ්‍ර_සි_සෙ'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'a h:mm',
	            LTS : 'a h:mm:ss',
	            L : 'YYYY/MM/DD',
	            LL : 'YYYY MMMM D',
	            LLL : 'YYYY MMMM D, a h:mm',
	            LLLL : 'YYYY MMMM D [වැනි] dddd, a h:mm:ss'
	        },
	        calendar : {
	            sameDay : '[අද] LT[ට]',
	            nextDay : '[හෙට] LT[ට]',
	            nextWeek : 'dddd LT[ට]',
	            lastDay : '[ඊයේ] LT[ට]',
	            lastWeek : '[පසුගිය] dddd LT[ට]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%sකින්',
	            past : '%sකට පෙර',
	            s : 'තත්පර කිහිපය',
	            m : 'මිනිත්තුව',
	            mm : 'මිනිත්තු %d',
	            h : 'පැය',
	            hh : 'පැය %d',
	            d : 'දිනය',
	            dd : 'දින %d',
	            M : 'මාසය',
	            MM : 'මාස %d',
	            y : 'වසර',
	            yy : 'වසර %d'
	        },
	        ordinalParse: /\d{1,2} වැනි/,
	        ordinal : function (number) {
	            return number + ' වැනි';
	        },
	        meridiemParse : /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./,
	        isPM : function (input) {
	            return input === 'ප.ව.' || input === 'පස් වරු';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'ප.ව.' : 'පස් වරු';
	            } else {
	                return isLower ? 'පෙ.ව.' : 'පෙර වරු';
	            }
	        }
	    });

	    return si;

	}));

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Slovak [sk]
	//! author : Martin Minka : https://github.com/k2s
	//! based on work of petrbela : https://github.com/petrbela

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var months = 'január_február_marec_apríl_máj_jún_júl_august_september_október_november_december'.split('_'),
	        monthsShort = 'jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec'.split('_');
	    function plural(n) {
	        return (n > 1) && (n < 5);
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	            case 's':  // a few seconds / in a few seconds / a few seconds ago
	                return (withoutSuffix || isFuture) ? 'pár sekúnd' : 'pár sekundami';
	            case 'm':  // a minute / in a minute / a minute ago
	                return withoutSuffix ? 'minúta' : (isFuture ? 'minútu' : 'minútou');
	            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'minúty' : 'minút');
	                } else {
	                    return result + 'minútami';
	                }
	                break;
	            case 'h':  // an hour / in an hour / an hour ago
	                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	            case 'hh': // 9 hours / in 9 hours / 9 hours ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'hodiny' : 'hodín');
	                } else {
	                    return result + 'hodinami';
	                }
	                break;
	            case 'd':  // a day / in a day / a day ago
	                return (withoutSuffix || isFuture) ? 'deň' : 'dňom';
	            case 'dd': // 9 days / in 9 days / 9 days ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'dni' : 'dní');
	                } else {
	                    return result + 'dňami';
	                }
	                break;
	            case 'M':  // a month / in a month / a month ago
	                return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
	            case 'MM': // 9 months / in 9 months / 9 months ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'mesiace' : 'mesiacov');
	                } else {
	                    return result + 'mesiacmi';
	                }
	                break;
	            case 'y':  // a year / in a year / a year ago
	                return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
	            case 'yy': // 9 years / in 9 years / 9 years ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'roky' : 'rokov');
	                } else {
	                    return result + 'rokmi';
	                }
	                break;
	        }
	    }

	    var sk = moment.defineLocale('sk', {
	        months : months,
	        monthsShort : monthsShort,
	        weekdays : 'nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota'.split('_'),
	        weekdaysShort : 'ne_po_ut_st_št_pi_so'.split('_'),
	        weekdaysMin : 'ne_po_ut_st_št_pi_so'.split('_'),
	        longDateFormat : {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay: '[dnes o] LT',
	            nextDay: '[zajtra o] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[v nedeľu o] LT';
	                    case 1:
	                    case 2:
	                        return '[v] dddd [o] LT';
	                    case 3:
	                        return '[v stredu o] LT';
	                    case 4:
	                        return '[vo štvrtok o] LT';
	                    case 5:
	                        return '[v piatok o] LT';
	                    case 6:
	                        return '[v sobotu o] LT';
	                }
	            },
	            lastDay: '[včera o] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[minulú nedeľu o] LT';
	                    case 1:
	                    case 2:
	                        return '[minulý] dddd [o] LT';
	                    case 3:
	                        return '[minulú stredu o] LT';
	                    case 4:
	                    case 5:
	                        return '[minulý] dddd [o] LT';
	                    case 6:
	                        return '[minulú sobotu o] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : 'pred %s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return sk;

	}));

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Slovenian [sl]
	//! author : Robert Sedovšek : https://github.com/sedovsek

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	            case 's':
	                return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
	            case 'm':
	                return withoutSuffix ? 'ena minuta' : 'eno minuto';
	            case 'mm':
	                if (number === 1) {
	                    result += withoutSuffix ? 'minuta' : 'minuto';
	                } else if (number === 2) {
	                    result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
	                } else if (number < 5) {
	                    result += withoutSuffix || isFuture ? 'minute' : 'minutami';
	                } else {
	                    result += withoutSuffix || isFuture ? 'minut' : 'minutami';
	                }
	                return result;
	            case 'h':
	                return withoutSuffix ? 'ena ura' : 'eno uro';
	            case 'hh':
	                if (number === 1) {
	                    result += withoutSuffix ? 'ura' : 'uro';
	                } else if (number === 2) {
	                    result += withoutSuffix || isFuture ? 'uri' : 'urama';
	                } else if (number < 5) {
	                    result += withoutSuffix || isFuture ? 'ure' : 'urami';
	                } else {
	                    result += withoutSuffix || isFuture ? 'ur' : 'urami';
	                }
	                return result;
	            case 'd':
	                return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
	            case 'dd':
	                if (number === 1) {
	                    result += withoutSuffix || isFuture ? 'dan' : 'dnem';
	                } else if (number === 2) {
	                    result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
	                } else {
	                    result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
	                }
	                return result;
	            case 'M':
	                return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
	            case 'MM':
	                if (number === 1) {
	                    result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
	                } else if (number === 2) {
	                    result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
	                } else if (number < 5) {
	                    result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
	                } else {
	                    result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
	                }
	                return result;
	            case 'y':
	                return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
	            case 'yy':
	                if (number === 1) {
	                    result += withoutSuffix || isFuture ? 'leto' : 'letom';
	                } else if (number === 2) {
	                    result += withoutSuffix || isFuture ? 'leti' : 'letoma';
	                } else if (number < 5) {
	                    result += withoutSuffix || isFuture ? 'leta' : 'leti';
	                } else {
	                    result += withoutSuffix || isFuture ? 'let' : 'leti';
	                }
	                return result;
	        }
	    }

	    var sl = moment.defineLocale('sl', {
	        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota'.split('_'),
	        weekdaysShort : 'ned._pon._tor._sre._čet._pet._sob.'.split('_'),
	        weekdaysMin : 'ne_po_to_sr_če_pe_so'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[danes ob] LT',
	            nextDay  : '[jutri ob] LT',

	            nextWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[v] [nedeljo] [ob] LT';
	                    case 3:
	                        return '[v] [sredo] [ob] LT';
	                    case 6:
	                        return '[v] [soboto] [ob] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[v] dddd [ob] LT';
	                }
	            },
	            lastDay  : '[včeraj ob] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[prejšnjo] [nedeljo] [ob] LT';
	                    case 3:
	                        return '[prejšnjo] [sredo] [ob] LT';
	                    case 6:
	                        return '[prejšnjo] [soboto] [ob] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[prejšnji] dddd [ob] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'čez %s',
	            past   : 'pred %s',
	            s      : processRelativeTime,
	            m      : processRelativeTime,
	            mm     : processRelativeTime,
	            h      : processRelativeTime,
	            hh     : processRelativeTime,
	            d      : processRelativeTime,
	            dd     : processRelativeTime,
	            M      : processRelativeTime,
	            MM     : processRelativeTime,
	            y      : processRelativeTime,
	            yy     : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return sl;

	}));

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Albanian [sq]
	//! author : Flakërim Ismani : https://github.com/flakerimi
	//! author : Menelion Elensúle : https://github.com/Oire
	//! author : Oerd Cukalla : https://github.com/oerd

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var sq = moment.defineLocale('sq', {
	        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor'.split('_'),
	        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj'.split('_'),
	        weekdays : 'E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë'.split('_'),
	        weekdaysShort : 'Die_Hën_Mar_Mër_Enj_Pre_Sht'.split('_'),
	        weekdaysMin : 'D_H_Ma_Më_E_P_Sh'.split('_'),
	        weekdaysParseExact : true,
	        meridiemParse: /PD|MD/,
	        isPM: function (input) {
	            return input.charAt(0) === 'M';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            return hours < 12 ? 'PD' : 'MD';
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Sot në] LT',
	            nextDay : '[Nesër në] LT',
	            nextWeek : 'dddd [në] LT',
	            lastDay : '[Dje në] LT',
	            lastWeek : 'dddd [e kaluar në] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'në %s',
	            past : '%s më parë',
	            s : 'disa sekonda',
	            m : 'një minutë',
	            mm : '%d minuta',
	            h : 'një orë',
	            hh : '%d orë',
	            d : 'një ditë',
	            dd : '%d ditë',
	            M : 'një muaj',
	            MM : '%d muaj',
	            y : 'një vit',
	            yy : '%d vite'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return sq;

	}));

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian [sr]
	//! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var translator = {
	        words: { //Different grammatical cases
	            m: ['jedan minut', 'jedne minute'],
	            mm: ['minut', 'minute', 'minuta'],
	            h: ['jedan sat', 'jednog sata'],
	            hh: ['sat', 'sata', 'sati'],
	            dd: ['dan', 'dana', 'dana'],
	            MM: ['mesec', 'meseca', 'meseci'],
	            yy: ['godina', 'godine', 'godina']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };

	    var sr = moment.defineLocale('sr', {
	        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
	        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
	        monthsParseExact: true,
	        weekdays: 'nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota'.split('_'),
	        weekdaysShort: 'ned._pon._uto._sre._čet._pet._sub.'.split('_'),
	        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L: 'DD.MM.YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm',
	            LLLL: 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar: {
	            sameDay: '[danas u] LT',
	            nextDay: '[sutra u] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[u] [nedelju] [u] LT';
	                    case 3:
	                        return '[u] [sredu] [u] LT';
	                    case 6:
	                        return '[u] [subotu] [u] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[juče u] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[prošle] [nedelje] [u] LT',
	                    '[prošlog] [ponedeljka] [u] LT',
	                    '[prošlog] [utorka] [u] LT',
	                    '[prošle] [srede] [u] LT',
	                    '[prošlog] [četvrtka] [u] LT',
	                    '[prošlog] [petka] [u] LT',
	                    '[prošle] [subote] [u] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'pre %s',
	            s      : 'nekoliko sekundi',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'dan',
	            dd     : translator.translate,
	            M      : 'mesec',
	            MM     : translator.translate,
	            y      : 'godinu',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return sr;

	}));

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian Cyrillic [sr-cyrl]
	//! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var translator = {
	        words: { //Different grammatical cases
	            m: ['један минут', 'једне минуте'],
	            mm: ['минут', 'минуте', 'минута'],
	            h: ['један сат', 'једног сата'],
	            hh: ['сат', 'сата', 'сати'],
	            dd: ['дан', 'дана', 'дана'],
	            MM: ['месец', 'месеца', 'месеци'],
	            yy: ['година', 'године', 'година']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };

	    var sr_cyrl = moment.defineLocale('sr-cyrl', {
	        months: 'јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар'.split('_'),
	        monthsShort: 'јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.'.split('_'),
	        monthsParseExact: true,
	        weekdays: 'недеља_понедељак_уторак_среда_четвртак_петак_субота'.split('_'),
	        weekdaysShort: 'нед._пон._уто._сре._чет._пет._суб.'.split('_'),
	        weekdaysMin: 'не_по_ут_ср_че_пе_су'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L: 'DD.MM.YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm',
	            LLLL: 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar: {
	            sameDay: '[данас у] LT',
	            nextDay: '[сутра у] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[у] [недељу] [у] LT';
	                    case 3:
	                        return '[у] [среду] [у] LT';
	                    case 6:
	                        return '[у] [суботу] [у] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[у] dddd [у] LT';
	                }
	            },
	            lastDay  : '[јуче у] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[прошле] [недеље] [у] LT',
	                    '[прошлог] [понедељка] [у] LT',
	                    '[прошлог] [уторка] [у] LT',
	                    '[прошле] [среде] [у] LT',
	                    '[прошлог] [четвртка] [у] LT',
	                    '[прошлог] [петка] [у] LT',
	                    '[прошле] [суботе] [у] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'за %s',
	            past   : 'пре %s',
	            s      : 'неколико секунди',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'дан',
	            dd     : translator.translate,
	            M      : 'месец',
	            MM     : translator.translate,
	            y      : 'годину',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return sr_cyrl;

	}));

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : siSwati [ss]
	//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';



	    var ss = moment.defineLocale('ss', {
	        months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
	        monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
	        weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
	        weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
	        weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Namuhla nga] LT',
	            nextDay : '[Kusasa nga] LT',
	            nextWeek : 'dddd [nga] LT',
	            lastDay : '[Itolo nga] LT',
	            lastWeek : 'dddd [leliphelile] [nga] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'nga %s',
	            past : 'wenteka nga %s',
	            s : 'emizuzwana lomcane',
	            m : 'umzuzu',
	            mm : '%d emizuzu',
	            h : 'lihora',
	            hh : '%d emahora',
	            d : 'lilanga',
	            dd : '%d emalanga',
	            M : 'inyanga',
	            MM : '%d tinyanga',
	            y : 'umnyaka',
	            yy : '%d iminyaka'
	        },
	        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'ekuseni';
	            } else if (hours < 15) {
	                return 'emini';
	            } else if (hours < 19) {
	                return 'entsambama';
	            } else {
	                return 'ebusuku';
	            }
	        },
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'ekuseni') {
	                return hour;
	            } else if (meridiem === 'emini') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
	                if (hour === 0) {
	                    return 0;
	                }
	                return hour + 12;
	            }
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return ss;

	}));

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Swedish [sv]
	//! author : Jens Alm : https://github.com/ulmus

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var sv = moment.defineLocale('sv', {
	        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
	        weekdaysShort : 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
	        weekdaysMin : 'sö_må_ti_on_to_fr_lö'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [kl.] HH:mm',
	            LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
	            lll : 'D MMM YYYY HH:mm',
	            llll : 'ddd D MMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Idag] LT',
	            nextDay: '[Imorgon] LT',
	            lastDay: '[Igår] LT',
	            nextWeek: '[På] dddd LT',
	            lastWeek: '[I] dddd[s] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : 'för %s sedan',
	            s : 'några sekunder',
	            m : 'en minut',
	            mm : '%d minuter',
	            h : 'en timme',
	            hh : '%d timmar',
	            d : 'en dag',
	            dd : '%d dagar',
	            M : 'en månad',
	            MM : '%d månader',
	            y : 'ett år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}(e|a)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'e' :
	                (b === 1) ? 'a' :
	                (b === 2) ? 'a' :
	                (b === 3) ? 'e' : 'e';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return sv;

	}));

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Swahili [sw]
	//! author : Fahad Kassim : https://github.com/fadsel

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var sw = moment.defineLocale('sw', {
	        months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
	        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
	        weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
	        weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[leo saa] LT',
	            nextDay : '[kesho saa] LT',
	            nextWeek : '[wiki ijayo] dddd [saat] LT',
	            lastDay : '[jana] LT',
	            lastWeek : '[wiki iliyopita] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s baadaye',
	            past : 'tokea %s',
	            s : 'hivi punde',
	            m : 'dakika moja',
	            mm : 'dakika %d',
	            h : 'saa limoja',
	            hh : 'masaa %d',
	            d : 'siku moja',
	            dd : 'masiku %d',
	            M : 'mwezi mmoja',
	            MM : 'miezi %d',
	            y : 'mwaka mmoja',
	            yy : 'miaka %d'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return sw;

	}));

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tamil [ta]
	//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '௧',
	        '2': '௨',
	        '3': '௩',
	        '4': '௪',
	        '5': '௫',
	        '6': '௬',
	        '7': '௭',
	        '8': '௮',
	        '9': '௯',
	        '0': '௦'
	    }, numberMap = {
	        '௧': '1',
	        '௨': '2',
	        '௩': '3',
	        '௪': '4',
	        '௫': '5',
	        '௬': '6',
	        '௭': '7',
	        '௮': '8',
	        '௯': '9',
	        '௦': '0'
	    };

	    var ta = moment.defineLocale('ta', {
	        months : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
	        monthsShort : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
	        weekdays : 'ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை'.split('_'),
	        weekdaysShort : 'ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி'.split('_'),
	        weekdaysMin : 'ஞா_தி_செ_பு_வி_வெ_ச'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, HH:mm',
	            LLLL : 'dddd, D MMMM YYYY, HH:mm'
	        },
	        calendar : {
	            sameDay : '[இன்று] LT',
	            nextDay : '[நாளை] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[நேற்று] LT',
	            lastWeek : '[கடந்த வாரம்] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s இல்',
	            past : '%s முன்',
	            s : 'ஒரு சில விநாடிகள்',
	            m : 'ஒரு நிமிடம்',
	            mm : '%d நிமிடங்கள்',
	            h : 'ஒரு மணி நேரம்',
	            hh : '%d மணி நேரம்',
	            d : 'ஒரு நாள்',
	            dd : '%d நாட்கள்',
	            M : 'ஒரு மாதம்',
	            MM : '%d மாதங்கள்',
	            y : 'ஒரு வருடம்',
	            yy : '%d ஆண்டுகள்'
	        },
	        ordinalParse: /\d{1,2}வது/,
	        ordinal : function (number) {
	            return number + 'வது';
	        },
	        preparse: function (string) {
	            return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        // refer http://ta.wikipedia.org/s/1er1
	        meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 2) {
	                return ' யாமம்';
	            } else if (hour < 6) {
	                return ' வைகறை';  // வைகறை
	            } else if (hour < 10) {
	                return ' காலை'; // காலை
	            } else if (hour < 14) {
	                return ' நண்பகல்'; // நண்பகல்
	            } else if (hour < 18) {
	                return ' எற்பாடு'; // எற்பாடு
	            } else if (hour < 22) {
	                return ' மாலை'; // மாலை
	            } else {
	                return ' யாமம்';
	            }
	        },
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'யாமம்') {
	                return hour < 2 ? hour : hour + 12;
	            } else if (meridiem === 'வைகறை' || meridiem === 'காலை') {
	                return hour;
	            } else if (meridiem === 'நண்பகல்') {
	                return hour >= 10 ? hour : hour + 12;
	            } else {
	                return hour + 12;
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ta;

	}));

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Telugu [te]
	//! author : Krishna Chaitanya Thota : https://github.com/kcthota

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var te = moment.defineLocale('te', {
	        months : 'జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జూలై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్'.split('_'),
	        monthsShort : 'జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జూలై_ఆగ._సెప్._అక్టో._నవ._డిసె.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం'.split('_'),
	        weekdaysShort : 'ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని'.split('_'),
	        weekdaysMin : 'ఆ_సో_మం_బు_గు_శు_శ'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm',
	            LTS : 'A h:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm'
	        },
	        calendar : {
	            sameDay : '[నేడు] LT',
	            nextDay : '[రేపు] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[నిన్న] LT',
	            lastWeek : '[గత] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s లో',
	            past : '%s క్రితం',
	            s : 'కొన్ని క్షణాలు',
	            m : 'ఒక నిమిషం',
	            mm : '%d నిమిషాలు',
	            h : 'ఒక గంట',
	            hh : '%d గంటలు',
	            d : 'ఒక రోజు',
	            dd : '%d రోజులు',
	            M : 'ఒక నెల',
	            MM : '%d నెలలు',
	            y : 'ఒక సంవత్సరం',
	            yy : '%d సంవత్సరాలు'
	        },
	        ordinalParse : /\d{1,2}వ/,
	        ordinal : '%dవ',
	        meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'రాత్రి') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === 'ఉదయం') {
	                return hour;
	            } else if (meridiem === 'మధ్యాహ్నం') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'సాయంత్రం') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'రాత్రి';
	            } else if (hour < 10) {
	                return 'ఉదయం';
	            } else if (hour < 17) {
	                return 'మధ్యాహ్నం';
	            } else if (hour < 20) {
	                return 'సాయంత్రం';
	            } else {
	                return 'రాత్రి';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return te;

	}));

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Thai [th]
	//! author : Kridsada Thanabulpong : https://github.com/sirn

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var th = moment.defineLocale('th', {
	        months : 'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split('_'),
	        monthsShort : 'ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
	        weekdaysShort : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'), // yes, three characters difference
	        weekdaysMin : 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'YYYY/MM/DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY เวลา H:mm',
	            LLLL : 'วันddddที่ D MMMM YYYY เวลา H:mm'
	        },
	        meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
	        isPM: function (input) {
	            return input === 'หลังเที่ยง';
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ก่อนเที่ยง';
	            } else {
	                return 'หลังเที่ยง';
	            }
	        },
	        calendar : {
	            sameDay : '[วันนี้ เวลา] LT',
	            nextDay : '[พรุ่งนี้ เวลา] LT',
	            nextWeek : 'dddd[หน้า เวลา] LT',
	            lastDay : '[เมื่อวานนี้ เวลา] LT',
	            lastWeek : '[วัน]dddd[ที่แล้ว เวลา] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'อีก %s',
	            past : '%sที่แล้ว',
	            s : 'ไม่กี่วินาที',
	            m : '1 นาที',
	            mm : '%d นาที',
	            h : '1 ชั่วโมง',
	            hh : '%d ชั่วโมง',
	            d : '1 วัน',
	            dd : '%d วัน',
	            M : '1 เดือน',
	            MM : '%d เดือน',
	            y : '1 ปี',
	            yy : '%d ปี'
	        }
	    });

	    return th;

	}));

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tagalog (Philippines) [tl-ph]
	//! author : Dan Hagman : https://github.com/hagmandan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var tl_ph = moment.defineLocale('tl-ph', {
	        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
	        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
	        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
	        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
	        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'MM/D/YYYY',
	            LL : 'MMMM D, YYYY',
	            LLL : 'MMMM D, YYYY HH:mm',
	            LLLL : 'dddd, MMMM DD, YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Ngayon sa] LT',
	            nextDay: '[Bukas sa] LT',
	            nextWeek: 'dddd [sa] LT',
	            lastDay: '[Kahapon sa] LT',
	            lastWeek: 'dddd [huling linggo] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'sa loob ng %s',
	            past : '%s ang nakalipas',
	            s : 'ilang segundo',
	            m : 'isang minuto',
	            mm : '%d minuto',
	            h : 'isang oras',
	            hh : '%d oras',
	            d : 'isang araw',
	            dd : '%d araw',
	            M : 'isang buwan',
	            MM : '%d buwan',
	            y : 'isang taon',
	            yy : '%d taon'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return tl_ph;

	}));

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Klingon [tlh]
	//! author : Dominika Kruk : https://github.com/amaranthrose

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var numbersNouns = 'pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

	    function translateFuture(output) {
	        var time = output;
	        time = (output.indexOf('jaj') !== -1) ?
	        time.slice(0, -3) + 'leS' :
	        (output.indexOf('jar') !== -1) ?
	        time.slice(0, -3) + 'waQ' :
	        (output.indexOf('DIS') !== -1) ?
	        time.slice(0, -3) + 'nem' :
	        time + ' pIq';
	        return time;
	    }

	    function translatePast(output) {
	        var time = output;
	        time = (output.indexOf('jaj') !== -1) ?
	        time.slice(0, -3) + 'Hu’' :
	        (output.indexOf('jar') !== -1) ?
	        time.slice(0, -3) + 'wen' :
	        (output.indexOf('DIS') !== -1) ?
	        time.slice(0, -3) + 'ben' :
	        time + ' ret';
	        return time;
	    }

	    function translate(number, withoutSuffix, string, isFuture) {
	        var numberNoun = numberAsNoun(number);
	        switch (string) {
	            case 'mm':
	                return numberNoun + ' tup';
	            case 'hh':
	                return numberNoun + ' rep';
	            case 'dd':
	                return numberNoun + ' jaj';
	            case 'MM':
	                return numberNoun + ' jar';
	            case 'yy':
	                return numberNoun + ' DIS';
	        }
	    }

	    function numberAsNoun(number) {
	        var hundred = Math.floor((number % 1000) / 100),
	        ten = Math.floor((number % 100) / 10),
	        one = number % 10,
	        word = '';
	        if (hundred > 0) {
	            word += numbersNouns[hundred] + 'vatlh';
	        }
	        if (ten > 0) {
	            word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
	        }
	        if (one > 0) {
	            word += ((word !== '') ? ' ' : '') + numbersNouns[one];
	        }
	        return (word === '') ? 'pagh' : word;
	    }

	    var tlh = moment.defineLocale('tlh', {
	        months : 'tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’'.split('_'),
	        monthsShort : 'jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	        weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	        weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[DaHjaj] LT',
	            nextDay: '[wa’leS] LT',
	            nextWeek: 'LLL',
	            lastDay: '[wa’Hu’] LT',
	            lastWeek: 'LLL',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : translateFuture,
	            past : translatePast,
	            s : 'puS lup',
	            m : 'wa’ tup',
	            mm : translate,
	            h : 'wa’ rep',
	            hh : translate,
	            d : 'wa’ jaj',
	            dd : translate,
	            M : 'wa’ jar',
	            MM : translate,
	            y : 'wa’ DIS',
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return tlh;

	}));

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Turkish [tr]
	//! authors : Erhan Gundogan : https://github.com/erhangundogan,
	//!           Burak Yiğit Kaya: https://github.com/BYK

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var suffixes = {
	        1: '\'inci',
	        5: '\'inci',
	        8: '\'inci',
	        70: '\'inci',
	        80: '\'inci',
	        2: '\'nci',
	        7: '\'nci',
	        20: '\'nci',
	        50: '\'nci',
	        3: '\'üncü',
	        4: '\'üncü',
	        100: '\'üncü',
	        6: '\'ncı',
	        9: '\'uncu',
	        10: '\'uncu',
	        30: '\'uncu',
	        60: '\'ıncı',
	        90: '\'ıncı'
	    };

	    var tr = moment.defineLocale('tr', {
	        months : 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split('_'),
	        monthsShort : 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
	        weekdays : 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split('_'),
	        weekdaysShort : 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
	        weekdaysMin : 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[bugün saat] LT',
	            nextDay : '[yarın saat] LT',
	            nextWeek : '[haftaya] dddd [saat] LT',
	            lastDay : '[dün] LT',
	            lastWeek : '[geçen hafta] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s sonra',
	            past : '%s önce',
	            s : 'birkaç saniye',
	            m : 'bir dakika',
	            mm : '%d dakika',
	            h : 'bir saat',
	            hh : '%d saat',
	            d : 'bir gün',
	            dd : '%d gün',
	            M : 'bir ay',
	            MM : '%d ay',
	            y : 'bir yıl',
	            yy : '%d yıl'
	        },
	        ordinalParse: /\d{1,2}'(inci|nci|üncü|ncı|uncu|ıncı)/,
	        ordinal : function (number) {
	            if (number === 0) {  // special case for zero
	                return number + '\'ıncı';
	            }
	            var a = number % 10,
	                b = number % 100 - a,
	                c = number >= 100 ? 100 : null;
	            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return tr;

	}));

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Talossan [tzl]
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v
	//! author : Iustì Canun

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
	    // This is currently too difficult (maybe even impossible) to add.
	    var tzl = moment.defineLocale('tzl', {
	        months : 'Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar'.split('_'),
	        monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
	        weekdays : 'Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi'.split('_'),
	        weekdaysShort : 'Súl_Lún_Mai_Már_Xhú_Vié_Sát'.split('_'),
	        weekdaysMin : 'Sú_Lú_Ma_Má_Xh_Vi_Sá'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM [dallas] YYYY',
	            LLL : 'D. MMMM [dallas] YYYY HH.mm',
	            LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
	        },
	        meridiemParse: /d\'o|d\'a/i,
	        isPM : function (input) {
	            return 'd\'o' === input.toLowerCase();
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'd\'o' : 'D\'O';
	            } else {
	                return isLower ? 'd\'a' : 'D\'A';
	            }
	        },
	        calendar : {
	            sameDay : '[oxhi à] LT',
	            nextDay : '[demà à] LT',
	            nextWeek : 'dddd [à] LT',
	            lastDay : '[ieiri à] LT',
	            lastWeek : '[sür el] dddd [lasteu à] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'osprei %s',
	            past : 'ja%s',
	            s : processRelativeTime,
	            m : processRelativeTime,
	            mm : processRelativeTime,
	            h : processRelativeTime,
	            hh : processRelativeTime,
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            's': ['viensas secunds', '\'iensas secunds'],
	            'm': ['\'n míut', '\'iens míut'],
	            'mm': [number + ' míuts', '' + number + ' míuts'],
	            'h': ['\'n þora', '\'iensa þora'],
	            'hh': [number + ' þoras', '' + number + ' þoras'],
	            'd': ['\'n ziua', '\'iensa ziua'],
	            'dd': [number + ' ziuas', '' + number + ' ziuas'],
	            'M': ['\'n mes', '\'iens mes'],
	            'MM': [number + ' mesen', '' + number + ' mesen'],
	            'y': ['\'n ar', '\'iens ar'],
	            'yy': [number + ' ars', '' + number + ' ars']
	        };
	        return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
	    }

	    return tzl;

	}));

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Central Atlas Tamazight [tzm]
	//! author : Abdel Said : https://github.com/abdelsaid

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var tzm = moment.defineLocale('tzm', {
	        months : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
	        monthsShort : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
	        weekdays : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	        weekdaysShort : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	        weekdaysMin : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[ⴰⵙⴷⵅ ⴴ] LT',
	            nextDay: '[ⴰⵙⴽⴰ ⴴ] LT',
	            nextWeek: 'dddd [ⴴ] LT',
	            lastDay: '[ⴰⵚⴰⵏⵜ ⴴ] LT',
	            lastWeek: 'dddd [ⴴ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s',
	            past : 'ⵢⴰⵏ %s',
	            s : 'ⵉⵎⵉⴽ',
	            m : 'ⵎⵉⵏⵓⴺ',
	            mm : '%d ⵎⵉⵏⵓⴺ',
	            h : 'ⵙⴰⵄⴰ',
	            hh : '%d ⵜⴰⵙⵙⴰⵄⵉⵏ',
	            d : 'ⴰⵙⵙ',
	            dd : '%d oⵙⵙⴰⵏ',
	            M : 'ⴰⵢoⵓⵔ',
	            MM : '%d ⵉⵢⵢⵉⵔⵏ',
	            y : 'ⴰⵙⴳⴰⵙ',
	            yy : '%d ⵉⵙⴳⴰⵙⵏ'
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return tzm;

	}));

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Central Atlas Tamazight Latin [tzm-latn]
	//! author : Abdel Said : https://github.com/abdelsaid

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var tzm_latn = moment.defineLocale('tzm-latn', {
	        months : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
	        monthsShort : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
	        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[asdkh g] LT',
	            nextDay: '[aska g] LT',
	            nextWeek: 'dddd [g] LT',
	            lastDay: '[assant g] LT',
	            lastWeek: 'dddd [g] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dadkh s yan %s',
	            past : 'yan %s',
	            s : 'imik',
	            m : 'minuḍ',
	            mm : '%d minuḍ',
	            h : 'saɛa',
	            hh : '%d tassaɛin',
	            d : 'ass',
	            dd : '%d ossan',
	            M : 'ayowr',
	            MM : '%d iyyirn',
	            y : 'asgas',
	            yy : '%d isgasn'
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return tzm_latn;

	}));

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Ukrainian [uk]
	//! author : zemlanin : https://github.com/zemlanin
	//! Author : Menelion Elensúle : https://github.com/Oire

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? 'хвилина_хвилини_хвилин' : 'хвилину_хвилини_хвилин',
	            'hh': withoutSuffix ? 'година_години_годин' : 'годину_години_годин',
	            'dd': 'день_дні_днів',
	            'MM': 'місяць_місяці_місяців',
	            'yy': 'рік_роки_років'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? 'хвилина' : 'хвилину';
	        }
	        else if (key === 'h') {
	            return withoutSuffix ? 'година' : 'годину';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': 'неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота'.split('_'),
	            'accusative': 'неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу'.split('_'),
	            'genitive': 'неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи'.split('_')
	        },
	        nounCase = (/(\[[ВвУу]\]) ?dddd/).test(format) ?
	            'accusative' :
	            ((/\[?(?:минулої|наступної)? ?\] ?dddd/).test(format) ?
	                'genitive' :
	                'nominative');
	        return weekdays[nounCase][m.day()];
	    }
	    function processHoursFunction(str) {
	        return function () {
	            return str + 'о' + (this.hours() === 11 ? 'б' : '') + '] LT';
	        };
	    }

	    var uk = moment.defineLocale('uk', {
	        months : {
	            'format': 'січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня'.split('_'),
	            'standalone': 'січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень'.split('_')
	        },
	        monthsShort : 'січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд'.split('_'),
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	        weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY р.',
	            LLL : 'D MMMM YYYY р., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY р., HH:mm'
	        },
	        calendar : {
	            sameDay: processHoursFunction('[Сьогодні '),
	            nextDay: processHoursFunction('[Завтра '),
	            lastDay: processHoursFunction('[Вчора '),
	            nextWeek: processHoursFunction('[У] dddd ['),
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                    case 3:
	                    case 5:
	                    case 6:
	                        return processHoursFunction('[Минулої] dddd [').call(this);
	                    case 1:
	                    case 2:
	                    case 4:
	                        return processHoursFunction('[Минулого] dddd [').call(this);
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'за %s',
	            past : '%s тому',
	            s : 'декілька секунд',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : 'годину',
	            hh : relativeTimeWithPlural,
	            d : 'день',
	            dd : relativeTimeWithPlural,
	            M : 'місяць',
	            MM : relativeTimeWithPlural,
	            y : 'рік',
	            yy : relativeTimeWithPlural
	        },
	        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
	        meridiemParse: /ночі|ранку|дня|вечора/,
	        isPM: function (input) {
	            return /^(дня|вечора)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'ночі';
	            } else if (hour < 12) {
	                return 'ранку';
	            } else if (hour < 17) {
	                return 'дня';
	            } else {
	                return 'вечора';
	            }
	        },
	        ordinalParse: /\d{1,2}-(й|го)/,
	        ordinal: function (number, period) {
	            switch (period) {
	                case 'M':
	                case 'd':
	                case 'DDD':
	                case 'w':
	                case 'W':
	                    return number + '-й';
	                case 'D':
	                    return number + '-го';
	                default:
	                    return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return uk;

	}));

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Uzbek [uz]
	//! author : Sardor Muminov : https://github.com/muminoff

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var uz = moment.defineLocale('uz', {
	        months : 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split('_'),
	        monthsShort : 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
	        weekdays : 'Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба'.split('_'),
	        weekdaysShort : 'Якш_Душ_Сеш_Чор_Пай_Жум_Шан'.split('_'),
	        weekdaysMin : 'Як_Ду_Се_Чо_Па_Жу_Ша'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'D MMMM YYYY, dddd HH:mm'
	        },
	        calendar : {
	            sameDay : '[Бугун соат] LT [да]',
	            nextDay : '[Эртага] LT [да]',
	            nextWeek : 'dddd [куни соат] LT [да]',
	            lastDay : '[Кеча соат] LT [да]',
	            lastWeek : '[Утган] dddd [куни соат] LT [да]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'Якин %s ичида',
	            past : 'Бир неча %s олдин',
	            s : 'фурсат',
	            m : 'бир дакика',
	            mm : '%d дакика',
	            h : 'бир соат',
	            hh : '%d соат',
	            d : 'бир кун',
	            dd : '%d кун',
	            M : 'бир ой',
	            MM : '%d ой',
	            y : 'бир йил',
	            yy : '%d йил'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return uz;

	}));

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Vietnamese [vi]
	//! author : Bang Nguyen : https://github.com/bangnk

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var vi = moment.defineLocale('vi', {
	        months : 'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split('_'),
	        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split('_'),
	        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	        weekdaysParseExact : true,
	        meridiemParse: /sa|ch/i,
	        isPM : function (input) {
	            return /^ch$/i.test(input);
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower ? 'sa' : 'SA';
	            } else {
	                return isLower ? 'ch' : 'CH';
	            }
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM [năm] YYYY',
	            LLL : 'D MMMM [năm] YYYY HH:mm',
	            LLLL : 'dddd, D MMMM [năm] YYYY HH:mm',
	            l : 'DD/M/YYYY',
	            ll : 'D MMM YYYY',
	            lll : 'D MMM YYYY HH:mm',
	            llll : 'ddd, D MMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Hôm nay lúc] LT',
	            nextDay: '[Ngày mai lúc] LT',
	            nextWeek: 'dddd [tuần tới lúc] LT',
	            lastDay: '[Hôm qua lúc] LT',
	            lastWeek: 'dddd [tuần rồi lúc] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s tới',
	            past : '%s trước',
	            s : 'vài giây',
	            m : 'một phút',
	            mm : '%d phút',
	            h : 'một giờ',
	            hh : '%d giờ',
	            d : 'một ngày',
	            dd : '%d ngày',
	            M : 'một tháng',
	            MM : '%d tháng',
	            y : 'một năm',
	            yy : '%d năm'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return vi;

	}));

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Pseudo [x-pseudo]
	//! author : Andrew Hood : https://github.com/andrewhood125

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var x_pseudo = moment.defineLocale('x-pseudo', {
	        months : 'J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér'.split('_'),
	        monthsShort : 'J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý'.split('_'),
	        weekdaysShort : 'S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát'.split('_'),
	        weekdaysMin : 'S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[T~ódá~ý át] LT',
	            nextDay : '[T~ómó~rró~w át] LT',
	            nextWeek : 'dddd [át] LT',
	            lastDay : '[Ý~ést~érdá~ý át] LT',
	            lastWeek : '[L~ást] dddd [át] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'í~ñ %s',
	            past : '%s á~gó',
	            s : 'á ~féw ~sécó~ñds',
	            m : 'á ~míñ~úté',
	            mm : '%d m~íñú~tés',
	            h : 'á~ñ hó~úr',
	            hh : '%d h~óúrs',
	            d : 'á ~dáý',
	            dd : '%d d~áýs',
	            M : 'á ~móñ~th',
	            MM : '%d m~óñt~hs',
	            y : 'á ~ýéár',
	            yy : '%d ý~éárs'
	        },
	        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return x_pseudo;

	}));

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (China) [zh-cn]
	//! author : suupic : https://github.com/suupic
	//! author : Zeno Zeng : https://github.com/zenozeng

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var zh_cn = moment.defineLocale('zh-cn', {
	        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
	        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
	        weekdaysShort : '周日_周一_周二_周三_周四_周五_周六'.split('_'),
	        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
	        longDateFormat : {
	            LT : 'Ah点mm分',
	            LTS : 'Ah点m分s秒',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY年MMMD日',
	            LLL : 'YYYY年MMMD日Ah点mm分',
	            LLLL : 'YYYY年MMMD日ddddAh点mm分',
	            l : 'YYYY-MM-DD',
	            ll : 'YYYY年MMMD日',
	            lll : 'YYYY年MMMD日Ah点mm分',
	            llll : 'YYYY年MMMD日ddddAh点mm分'
	        },
	        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '凌晨' || meridiem === '早上' ||
	                    meridiem === '上午') {
	                return hour;
	            } else if (meridiem === '下午' || meridiem === '晚上') {
	                return hour + 12;
	            } else {
	                // '中午'
	                return hour >= 11 ? hour : hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            var hm = hour * 100 + minute;
	            if (hm < 600) {
	                return '凌晨';
	            } else if (hm < 900) {
	                return '早上';
	            } else if (hm < 1130) {
	                return '上午';
	            } else if (hm < 1230) {
	                return '中午';
	            } else if (hm < 1800) {
	                return '下午';
	            } else {
	                return '晚上';
	            }
	        },
	        calendar : {
	            sameDay : function () {
	                return this.minutes() === 0 ? '[今天]Ah[点整]' : '[今天]LT';
	            },
	            nextDay : function () {
	                return this.minutes() === 0 ? '[明天]Ah[点整]' : '[明天]LT';
	            },
	            lastDay : function () {
	                return this.minutes() === 0 ? '[昨天]Ah[点整]' : '[昨天]LT';
	            },
	            nextWeek : function () {
	                var startOfWeek, prefix;
	                startOfWeek = moment().startOf('week');
	                prefix = this.diff(startOfWeek, 'days') >= 7 ? '[下]' : '[本]';
	                return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';
	            },
	            lastWeek : function () {
	                var startOfWeek, prefix;
	                startOfWeek = moment().startOf('week');
	                prefix = this.unix() < startOfWeek.unix()  ? '[上]' : '[本]';
	                return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';
	            },
	            sameElse : 'LL'
	        },
	        ordinalParse: /\d{1,2}(日|月|周)/,
	        ordinal : function (number, period) {
	            switch (period) {
	                case 'd':
	                case 'D':
	                case 'DDD':
	                    return number + '日';
	                case 'M':
	                    return number + '月';
	                case 'w':
	                case 'W':
	                    return number + '周';
	                default:
	                    return number;
	            }
	        },
	        relativeTime : {
	            future : '%s内',
	            past : '%s前',
	            s : '几秒',
	            m : '1 分钟',
	            mm : '%d 分钟',
	            h : '1 小时',
	            hh : '%d 小时',
	            d : '1 天',
	            dd : '%d 天',
	            M : '1 个月',
	            MM : '%d 个月',
	            y : '1 年',
	            yy : '%d 年'
	        },
	        week : {
	            // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return zh_cn;

	}));

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (Hong Kong) [zh-hk]
	//! author : Ben : https://github.com/ben-lin
	//! author : Chris Lam : https://github.com/hehachris
	//! author : Konstantin : https://github.com/skfd

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var zh_hk = moment.defineLocale('zh-hk', {
	        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
	        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
	        weekdaysShort : '週日_週一_週二_週三_週四_週五_週六'.split('_'),
	        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
	        longDateFormat : {
	            LT : 'Ah點mm分',
	            LTS : 'Ah點m分s秒',
	            L : 'YYYY年MMMD日',
	            LL : 'YYYY年MMMD日',
	            LLL : 'YYYY年MMMD日Ah點mm分',
	            LLLL : 'YYYY年MMMD日ddddAh點mm分',
	            l : 'YYYY年MMMD日',
	            ll : 'YYYY年MMMD日',
	            lll : 'YYYY年MMMD日Ah點mm分',
	            llll : 'YYYY年MMMD日ddddAh點mm分'
	        },
	        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
	                return hour;
	            } else if (meridiem === '中午') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === '下午' || meridiem === '晚上') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            var hm = hour * 100 + minute;
	            if (hm < 600) {
	                return '凌晨';
	            } else if (hm < 900) {
	                return '早上';
	            } else if (hm < 1130) {
	                return '上午';
	            } else if (hm < 1230) {
	                return '中午';
	            } else if (hm < 1800) {
	                return '下午';
	            } else {
	                return '晚上';
	            }
	        },
	        calendar : {
	            sameDay : '[今天]LT',
	            nextDay : '[明天]LT',
	            nextWeek : '[下]ddddLT',
	            lastDay : '[昨天]LT',
	            lastWeek : '[上]ddddLT',
	            sameElse : 'L'
	        },
	        ordinalParse: /\d{1,2}(日|月|週)/,
	        ordinal : function (number, period) {
	            switch (period) {
	                case 'd' :
	                case 'D' :
	                case 'DDD' :
	                    return number + '日';
	                case 'M' :
	                    return number + '月';
	                case 'w' :
	                case 'W' :
	                    return number + '週';
	                default :
	                    return number;
	            }
	        },
	        relativeTime : {
	            future : '%s內',
	            past : '%s前',
	            s : '幾秒',
	            m : '1 分鐘',
	            mm : '%d 分鐘',
	            h : '1 小時',
	            hh : '%d 小時',
	            d : '1 天',
	            dd : '%d 天',
	            M : '1 個月',
	            MM : '%d 個月',
	            y : '1 年',
	            yy : '%d 年'
	        }
	    });

	    return zh_hk;

	}));

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (Taiwan) [zh-tw]
	//! author : Ben : https://github.com/ben-lin
	//! author : Chris Lam : https://github.com/hehachris

	;(function (global, factory) {
	    true ? factory(__webpack_require__(195)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var zh_tw = moment.defineLocale('zh-tw', {
	        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
	        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
	        weekdaysShort : '週日_週一_週二_週三_週四_週五_週六'.split('_'),
	        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
	        longDateFormat : {
	            LT : 'Ah點mm分',
	            LTS : 'Ah點m分s秒',
	            L : 'YYYY年MMMD日',
	            LL : 'YYYY年MMMD日',
	            LLL : 'YYYY年MMMD日Ah點mm分',
	            LLLL : 'YYYY年MMMD日ddddAh點mm分',
	            l : 'YYYY年MMMD日',
	            ll : 'YYYY年MMMD日',
	            lll : 'YYYY年MMMD日Ah點mm分',
	            llll : 'YYYY年MMMD日ddddAh點mm分'
	        },
	        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
	                return hour;
	            } else if (meridiem === '中午') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === '下午' || meridiem === '晚上') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            var hm = hour * 100 + minute;
	            if (hm < 600) {
	                return '凌晨';
	            } else if (hm < 900) {
	                return '早上';
	            } else if (hm < 1130) {
	                return '上午';
	            } else if (hm < 1230) {
	                return '中午';
	            } else if (hm < 1800) {
	                return '下午';
	            } else {
	                return '晚上';
	            }
	        },
	        calendar : {
	            sameDay : '[今天]LT',
	            nextDay : '[明天]LT',
	            nextWeek : '[下]ddddLT',
	            lastDay : '[昨天]LT',
	            lastWeek : '[上]ddddLT',
	            sameElse : 'L'
	        },
	        ordinalParse: /\d{1,2}(日|月|週)/,
	        ordinal : function (number, period) {
	            switch (period) {
	                case 'd' :
	                case 'D' :
	                case 'DDD' :
	                    return number + '日';
	                case 'M' :
	                    return number + '月';
	                case 'w' :
	                case 'W' :
	                    return number + '週';
	                default :
	                    return number;
	            }
	        },
	        relativeTime : {
	            future : '%s內',
	            past : '%s前',
	            s : '幾秒',
	            m : '1 分鐘',
	            mm : '%d 分鐘',
	            h : '1 小時',
	            hh : '%d 小時',
	            d : '1 天',
	            dd : '%d 天',
	            M : '1 個月',
	            MM : '%d 個月',
	            y : '1 年',
	            yy : '%d 年'
	        }
	    });

	    return zh_tw;

	}));

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Net = __webpack_require__(302);
	var Hoek = __webpack_require__(187);
	var Isemail = __webpack_require__(303);
	var Any = __webpack_require__(186);
	var Ref = __webpack_require__(190);
	var JoiDate = __webpack_require__(194);
	var Errors = __webpack_require__(191);
	var Uri = __webpack_require__(306);
	var Ip = __webpack_require__(308);

	// Declare internals

	var internals = {
	    uriRegex: Uri.createUriRegex(),
	    ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional')
	};

	internals.String = function () {

	    Any.call(this);
	    this._type = 'string';
	    this._invalids.add('');
	};

	Hoek.inherits(internals.String, Any);

	internals.compare = function (type, compare) {

	    return function (limit, encoding) {

	        var isRef = Ref.isRef(limit);

	        Hoek.assert((Hoek.isInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');
	        Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);

	        return this._test(type, limit, function (value, state, options) {

	            var compareTo;
	            if (isRef) {
	                compareTo = limit(state.parent, options);

	                if (!Hoek.isInteger(compareTo)) {
	                    return Errors.create('string.ref', { ref: limit.key }, state, options);
	                }
	            }
	            else {
	                compareTo = limit;
	            }

	            if (compare(value, compareTo, encoding)) {
	                return null;
	            }

	            return Errors.create('string.' + type, { limit: compareTo, value: value, encoding: encoding }, state, options);
	        });
	    };
	};

	internals.String.prototype._base = function (value, state, options) {

	    if (typeof value === 'string' &&
	        options.convert) {

	        if (this._flags.case) {
	            value = (this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase());
	        }

	        if (this._flags.trim) {
	            value = value.trim();
	        }

	        if (this._inner.replacements) {

	            for (var r = 0, rl = this._inner.replacements.length; r < rl; ++r) {
	                var replacement = this._inner.replacements[r];
	                value = value.replace(replacement.pattern, replacement.replacement);
	            }
	        }
	    }

	    return {
	        value: value,
	        errors: (typeof value === 'string') ? null : Errors.create('string.base', { value: value }, state, options)
	    };
	};


	internals.String.prototype.insensitive = function () {

	    var obj = this.clone();
	    obj._flags.insensitive = true;
	    return obj;
	};


	internals.String.prototype.min = internals.compare('min', function (value, limit, encoding) {

	    var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
	    return length >= limit;
	});


	internals.String.prototype.max = internals.compare('max', function (value, limit, encoding) {

	    var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
	    return length <= limit;
	});


	internals.String.prototype.creditCard = function () {

	    return this._test('creditCard', undefined, function (value, state, options) {

	        var i = value.length;
	        var sum = 0;
	        var mul = 1;
	        var char;

	        while (i--) {
	            char = value.charAt(i) * mul;
	            sum += char - (char > 9) * 9;
	            mul ^= 3;
	        }

	        var check = (sum % 10 === 0) && (sum > 0);
	        return check ? null : Errors.create('string.creditCard', { value: value }, state, options);
	    });
	};

	internals.String.prototype.length = internals.compare('length', function (value, limit, encoding) {

	    var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
	    return length === limit;
	});


	internals.String.prototype.regex = function (pattern, name) {

	    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');

	    pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags

	    return this._test('regex', pattern, function (value, state, options) {

	        if (pattern.test(value)) {
	            return null;
	        }

	        return Errors.create((name ? 'string.regex.name' : 'string.regex.base'), { name: name, pattern: pattern, value: value }, state, options);
	    });
	};


	internals.String.prototype.alphanum = function () {

	    return this._test('alphanum', undefined, function (value, state, options) {

	        if (/^[a-zA-Z0-9]+$/.test(value)) {
	            return null;
	        }

	        return Errors.create('string.alphanum', { value: value }, state, options);
	    });
	};


	internals.String.prototype.token = function () {

	    return this._test('token', undefined, function (value, state, options) {

	        if (/^\w+$/.test(value)) {
	            return null;
	        }

	        return Errors.create('string.token', { value: value }, state, options);
	    });
	};


	internals.String.prototype.email = function (isEmailOptions) {

	    if (isEmailOptions) {
	        Hoek.assert(typeof isEmailOptions === 'object', 'email options must be an object');
	        Hoek.assert(typeof isEmailOptions.checkDNS === 'undefined', 'checkDNS option is not supported');
	        Hoek.assert(typeof isEmailOptions.tldWhitelist === 'undefined' ||
	            typeof isEmailOptions.tldWhitelist === 'object', 'tldWhitelist must be an array or object');
	        Hoek.assert(typeof isEmailOptions.minDomainAtoms === 'undefined' ||
	            Hoek.isInteger(isEmailOptions.minDomainAtoms) && isEmailOptions.minDomainAtoms > 0,
	            'minDomainAtoms must be a positive integer');
	        Hoek.assert(typeof isEmailOptions.errorLevel === 'undefined' || typeof isEmailOptions.errorLevel === 'boolean' ||
	            (Hoek.isInteger(isEmailOptions.errorLevel) && isEmailOptions.errorLevel >= 0),
	            'errorLevel must be a non-negative integer or boolean');
	    }

	    return this._test('email', isEmailOptions, function (value, state, options) {

	        try {
	            var result = Isemail(value, isEmailOptions);
	            if (result === true || result === 0) {
	                return null;
	            }
	        }
	        catch (e) {}

	        return Errors.create('string.email', { value: value }, state, options);
	    });
	};


	internals.String.prototype.ip = function (ipOptions) {

	    var regex = internals.ipRegex;
	    ipOptions = ipOptions || {};
	    Hoek.assert(typeof ipOptions === 'object', 'options must be an object');

	    if (ipOptions.cidr) {
	        Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');
	        ipOptions.cidr = ipOptions.cidr.toLowerCase();

	        Hoek.assert(ipOptions.cidr in Ip.cidrs, 'cidr must be one of ' + Object.keys(Ip.cidrs).join(', '));

	        // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is "optional" since that is the default
	        if (!ipOptions.version && ipOptions.cidr !== 'optional') {
	            regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);
	        }
	    }
	    else {

	        // Set our default cidr strategy
	        ipOptions.cidr = 'optional';
	    }

	    if (ipOptions.version) {
	        if (!Array.isArray(ipOptions.version)) {
	            ipOptions.version = [ipOptions.version];
	        }

	        Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');

	        var versions = [];
	        for (var i = 0, il = ipOptions.version.length; i < il; ++i) {
	            var version = ipOptions.version[i];
	            Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
	            version = version.toLowerCase();
	            Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));
	            versions.push(version);
	        }

	        // Make sure we have a set of versions
	        versions = Hoek.unique(versions);

	        regex = Ip.createIpRegex(versions, ipOptions.cidr);
	    }

	    return this._test('ip', ipOptions, function (value, state, options) {

	        if (regex.test(value)) {
	            return null;
	        }

	        if (versions) {
	            return Errors.create('string.ipVersion', { value: value, cidr: ipOptions.cidr, version: versions }, state, options);
	        }

	        return Errors.create('string.ip', { value: value, cidr: ipOptions.cidr }, state, options);
	    });
	};


	internals.String.prototype.uri = function (uriOptions) {

	    var customScheme = '',
	        regex = internals.uriRegex;

	    if (uriOptions) {
	        Hoek.assert(typeof uriOptions === 'object', 'options must be an object');

	        if (uriOptions.scheme) {
	            Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');

	            if (!Array.isArray(uriOptions.scheme)) {
	                uriOptions.scheme = [uriOptions.scheme];
	            }

	            Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified');

	            // Flatten the array into a string to be used to match the schemes.
	            for (var i = 0, il = uriOptions.scheme.length; i < il; ++i) {
	                var scheme = uriOptions.scheme[i];
	                Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');

	                // Add OR separators if a value already exists
	                customScheme += customScheme ? '|' : '';

	                // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.
	                if (scheme instanceof RegExp) {
	                    customScheme += scheme.source;
	                }
	                else {
	                    Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');
	                    customScheme += Hoek.escapeRegex(scheme);
	                }
	            }
	        }
	    }

	    if (customScheme) {
	        regex = Uri.createUriRegex(customScheme);
	    }

	    return this._test('uri', uriOptions, function (value, state, options) {

	        if (regex.test(value)) {
	            return null;
	        }

	        if (customScheme) {
	            return Errors.create('string.uriCustomScheme', { scheme: customScheme, value: value }, state, options);
	        }

	        return Errors.create('string.uri', { value: value }, state, options);
	    });
	};


	internals.String.prototype.isoDate = function () {

	    return this._test('isoDate', undefined, function (value, state, options) {

	        if (JoiDate._isIsoDate(value)) {
	            return null;
	        }

	        return Errors.create('string.isoDate', { value: value }, state, options);
	    });
	};


	internals.String.prototype.guid = function () {

	    var regex = /^[A-F0-9]{8}(?:-?[A-F0-9]{4}){3}-?[A-F0-9]{12}$/i;
	    var regex2 = /^\{[A-F0-9]{8}(?:-?[A-F0-9]{4}){3}-?[A-F0-9]{12}\}$/i;

	    return this._test('guid', undefined, function (value, state, options) {

	        if (regex.test(value) || regex2.test(value)) {
	            return null;
	        }

	        return Errors.create('string.guid', { value: value }, state, options);
	    });
	};


	internals.String.prototype.hex = function () {

	    var regex = /^[a-f0-9]+$/i;

	    return this._test('hex', regex, function (value, state, options) {

	        if (regex.test(value)) {
	            return null;
	        }

	        return Errors.create('string.hex', { value: value }, state, options);
	    });
	};


	internals.String.prototype.hostname = function () {

	    var regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/;

	    return this._test('hostname', undefined, function (value, state, options) {

	        if ((value.length <= 255 && regex.test(value)) ||
	            Net.isIPv6(value)) {

	            return null;
	        }

	        return Errors.create('string.hostname', { value: value }, state, options);
	    });
	};


	internals.String.prototype.lowercase = function () {

	    var obj = this._test('lowercase', undefined, function (value, state, options) {

	        if (options.convert ||
	            value === value.toLocaleLowerCase()) {

	            return null;
	        }

	        return Errors.create('string.lowercase', { value: value }, state, options);
	    });

	    obj._flags.case = 'lower';
	    return obj;
	};


	internals.String.prototype.uppercase = function () {

	    var obj = this._test('uppercase', undefined, function (value, state, options) {

	        if (options.convert ||
	            value === value.toLocaleUpperCase()) {

	            return null;
	        }

	        return Errors.create('string.uppercase', { value: value }, state, options);
	    });

	    obj._flags.case = 'upper';
	    return obj;
	};


	internals.String.prototype.trim = function () {

	    var obj = this._test('trim', undefined, function (value, state, options) {

	        if (options.convert ||
	            value === value.trim()) {

	            return null;
	        }

	        return Errors.create('string.trim', { value: value }, state, options);
	    });

	    obj._flags.trim = true;
	    return obj;
	};


	internals.String.prototype.replace = function (pattern, replacement) {

	    if (typeof pattern === 'string') {
	        pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');
	    }

	    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');
	    Hoek.assert(typeof replacement === 'string', 'replacement must be a String');

	    // This can not be considere a test like trim, we can't "reject"
	    // anything from this rule, so just clone the current object
	    var obj = this.clone();

	    if (!obj._inner.replacements) {
	        obj._inner.replacements = [];
	    }

	    obj._inner.replacements.push({
	        pattern: pattern,
	        replacement: replacement
	    });

	    return obj;
	};

	module.exports = new internals.String();


/***/ },
/* 302 */
/***/ function(module, exports) {

	module.exports = require("net");

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(304);


/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * To validate an email address according to RFCs 5321, 5322 and others
	 *
	 * Copyright © 2008-2011, Dominic Sayers
	 * Test schema documentation Copyright © 2011, Daniel Marschall
	 * Port for Node.js Copyright © 2013-2014, GlobeSherpa
	 *              and Copyright © 2014-2015, Eli Skeggs
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 *   - Redistributions of source code must retain the above copyright notice,
	 *     this list of conditions and the following disclaimer.
	 *   - Redistributions in binary form must reproduce the above copyright notice,
	 *     this list of conditions and the following disclaimer in the documentation
	 *     and/or other materials provided with the distribution.
	 *   - Neither the name of Dominic Sayers nor the names of its contributors may
	 *     be used to endorse or promote products derived from this software without
	 *     specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
	 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 *
	 * @author      Dominic Sayers <dominic@sayers.cc>
	 * @author      Eli Skeggs <skeggse@gmail.com>
	 * @copyright   2008-2011 Dominic Sayers
	 * @copyright   2013-2014 GlobeSherpa
	 * @copyright   2014-2015 Eli Skeggs
	 * @license     http://www.opensource.org/licenses/bsd-license.php BSD License
	 * @link        http://www.dominicsayers.com/isemail
	 * @link        https://github.com/hapijs/isemail
	 * @version     1.2.0 Drop Node 0.8, fix style, switch to lab/code
	 */

	var Dns = __webpack_require__(305);

	var internals = {
	    defaultThreshold: 16,
	    maxIPv6Groups: 8,
	    categories: {
	        valid: 1,
	        dnsWarn: 7,
	        rfc5321: 15,
	        cfws: 31,
	        deprecated: 63,
	        rfc5322: 127,
	        error: 255
	    },

	    diagnoses: {
	        // Address is valid
	        valid: 0,

	        // Address is valid, but the DNS check failed
	        dnsWarnNoMXRecord: 5,
	        dnsWarnNoRecord: 6,

	        // Address is valid for SMTP but has unusual elements
	        rfc5321TLD: 9,
	        rfc5321TLDNumeric: 10,
	        rfc5321QuotedString: 11,
	        rfc5321AddressLiteral: 12,

	        // Address is valid for message, but must be modified for envelope
	        cfwsComment: 17,
	        cfwsFWS: 18,

	        // Address contains deprecated elements, but may still be valid in some contexts
	        deprecatedLocalPart: 33,
	        deprecatedFWS: 34,
	        deprecatedQTEXT: 35,
	        deprecatedQP: 36,
	        deprecatedComment: 37,
	        deprecatedCTEXT: 38,
	        deprecatedIPv6: 39,
	        deprecatedCFWSNearAt: 49,

	        // Address is only valid according to broad definition in RFC 5322, but is otherwise invalid
	        rfc5322Domain: 65,
	        rfc5322TooLong: 66,
	        rfc5322LocalTooLong: 67,
	        rfc5322DomainTooLong: 68,
	        rfc5322LabelTooLong: 69,
	        rfc5322DomainLiteral: 70,
	        rfc5322DomainLiteralOBSDText: 71,
	        rfc5322IPv6GroupCount: 72,
	        rfc5322IPv62x2xColon: 73,
	        rfc5322IPv6BadCharacter: 74,
	        rfc5322IPv6MaxGroups: 75,
	        rfc5322IPv6ColonStart: 76,
	        rfc5322IPv6ColonEnd: 77,

	        // Address is invalid for any purpose
	        errExpectingDTEXT: 129,
	        errNoLocalPart: 130,
	        errNoDomain: 131,
	        errConsecutiveDots: 132,
	        errATEXTAfterCFWS: 133,
	        errATEXTAfterQS: 134,
	        errATEXTAfterDomainLiteral: 135,
	        errExpectingQPair: 136,
	        errExpectingATEXT: 137,
	        errExpectingQTEXT: 138,
	        errExpectingCTEXT: 139,
	        errBackslashEnd: 140,
	        errDotStart: 141,
	        errDotEnd: 142,
	        errDomainHyphenStart: 143,
	        errDomainHyphenEnd: 144,
	        errUnclosedQuotedString: 145,
	        errUnclosedComment: 146,
	        errUnclosedDomainLiteral: 147,
	        errFWSCRLFx2: 148,
	        errFWSCRLFEnd: 149,
	        errCRNoLF: 150,
	        errUnknownTLD: 160,
	        errDomainTooShort: 161
	    },

	    components: {
	        localpart: 0,
	        domain: 1,
	        literal: 2,
	        contextComment: 3,
	        contextFWS: 4,
	        contextQuotedString: 5,
	        contextQuotedPair: 6
	    }
	};

	// $lab:coverage:off$
	internals.defer = typeof process !== 'undefined' && process && typeof process.nextTick === 'function' ?
	    process.nextTick.bind(process) :
	    function (callback) {

	        return setTimeout(callback, 0);
	    };
	// $lab:coverage:on$


	// US-ASCII visible characters not valid for atext
	// (http://tools.ietf.org/html/rfc5322#section-3.2.3)
	var SPECIALS = '()<>[]:;@\\,."';

	// A silly little optimized function generator
	var optimizeLookup = function optimizeLookup (string) {

	    var lookup = new Array(0x100);

	    for (var i = 0xff; i >= 0; --i) {
	        lookup[i] = false;
	    }

	    for (var il = string.length; i < il; ++i) {
	        lookup[string.charCodeAt(i)] = true;
	    }

	    var body = 'return function (code) {\n';
	    body += '  return lookup[code];\n';
	    body += '}';
	    return (new Function('lookup', body))(lookup);
	};


	var specialsLookup = optimizeLookup(SPECIALS);

	// This matches valid IPv4 addresses from the end of a string
	var IPv4_REGEX =
	    /\b(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
	var IPv6_REGEX = /^[a-fA-F\d]{0,4}$/;
	var IPv6_REGEX_TEST = IPv6_REGEX.test.bind(IPv6_REGEX);

	var hasOwn = Object.prototype.hasOwnProperty;

	/**
	 * Check that an email address conforms to RFCs 5321, 5322 and others
	 *
	 * We distinguish clearly between a Mailbox as defined by RFC 5321 and an
	 * addr-spec as defined by RFC 5322. Depending on the context, either can be
	 * regarded as a valid email address. The RFC 5321 Mailbox specification is
	 * more restrictive (comments, white space and obsolete forms are not allowed).
	 *
	 * @param {string} email The email address to check.
	 * @param {Object} options The (optional) options:
	 *   {boolean} checkDNS If true then will check DNS for MX records. If
	 *     true this call to isEmail _will_ be asynchronous.
	 *   {*} errorLevel Determines the boundary between valid and invalid
	 *     addresses. Status codes above this number will be returned as-is, status
	 *     codes below will be returned as valid. Thus the calling program can
	 *     simply look for diagnoses.valid if it is only interested in whether an
	 *     address is valid or not. The errorLevel will determine how "picky"
	 *     isEmail() is about the address. If omitted or passed as false then
	 *     isEmail() will return true or false rather than an integer error or
	 *     warning. NB Note the difference between errorLevel = false and
	 *     errorLevel = 0.
	 * @param {function(number|boolean)} callback The (optional) callback handler.
	 * @return {*}
	 */
	var isEmail = function isEmail (email, options, callback) {

	    if (typeof options === 'function') {
	        callback = options;
	        options = {};
	    }

	    if (!options) {
	        options = {};
	    }

	    if (typeof callback !== 'function') {
	        if (options.checkDNS) {
	            throw new TypeError('expected callback function for checkDNS option');
	        }

	        callback = null;
	    }

	    var diagnose;
	    var threshold;

	    if (typeof options.errorLevel === 'number') {
	        diagnose = true;
	        threshold = options.errorLevel;
	    }
	    else {
	        diagnose = !!options.errorLevel;
	        threshold = internals.diagnoses.valid;
	    }

	    if (options.tldWhitelist) {
	        if (typeof options.tldWhitelist === 'string') {
	            options.tldWhitelist = [options.tldWhitelist];
	        } else if (typeof options.tldWhitelist !== 'object') {
	            throw new TypeError('expected array or object tldWhitelist');
	        }
	    }

	    if (options.minDomainAtoms && (options.minDomainAtoms !== ((+options.minDomainAtoms) | 0) || options.minDomainAtoms < 0)) {
	        throw new TypeError('expected positive integer minDomainAtoms');
	    }

	    var maxResult = internals.diagnoses.valid;

	    var updateResult = function updateResult (value) {

	        if (value > maxResult) {
	            maxResult = value;
	        }
	    };

	    var context = {
	        now: internals.components.localpart,
	        prev: internals.components.localpart,
	        stack: [internals.components.localpart]
	    };

	    var token;
	    var prevToken = '';
	    var charCode = 0;

	    var parseData = {
	        local: '',
	        domain: ''
	    };
	    var atomData = {
	        locals: [''],
	        domains: ['']
	    };

	    var elementCount = 0;
	    var elementLength = 0;
	    var crlfCount = 0;

	    var hyphenFlag = false;
	    var assertEnd = false;

	    var emailLength = email.length;

	    for (var i = 0, il = emailLength; i < il; ++i) {
	        // Token is used outside the loop, must declare similarly
	        token = email[i];

	        switch (context.now) {
	            // Local-part
	            case internals.components.localpart:
	                // http://tools.ietf.org/html/rfc5322#section-3.4.1
	                //   local-part      =   dot-atom / quoted-string / obs-local-part
	                //
	                //   dot-atom        =   [CFWS] dot-atom-text [CFWS]
	                //
	                //   dot-atom-text   =   1*atext *("." 1*atext)
	                //
	                //   quoted-string   =   [CFWS]
	                //                       DQUOTE *([FWS] qcontent) [FWS] DQUOTE
	                //                       [CFWS]
	                //
	                //   obs-local-part  =   word *("." word)
	                //
	                //   word            =   atom / quoted-string
	                //
	                //   atom            =   [CFWS] 1*atext [CFWS]
	                switch (token) {
	                    // Comment
	                    case '(':
	                        if (elementLength === 0) {
	                            // Comments are OK at the beginning of an element
	                            updateResult(elementCount === 0 ? internals.diagnoses.cfwsComment : internals.diagnoses.deprecatedComment);
	                        }
	                        else {
	                            updateResult(internals.diagnoses.cfwsComment);
	                             // Cannot start a comment in an element, should be end
	                            assertEnd = true;
	                        }

	                        context.stack.push(context.now);
	                        context.now = internals.components.contextComment;
	                        break;

	                    // Next dot-atom element
	                    case '.':
	                        if (elementLength === 0) {
	                            // Another dot, already?
	                            updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);
	                        }
	                        else {
	                            // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form
	                            if (assertEnd) {
	                                updateResult(internals.diagnoses.deprecatedLocalPart);
	                            }

	                            // CFWS & quoted strings are OK again now we're at the beginning of an element (although they are obsolete forms)
	                            assertEnd = false;
	                            elementLength = 0;
	                            ++elementCount;
	                            parseData.local += token;
	                            atomData.locals[elementCount] = '';
	                        }

	                        break;

	                    // Quoted string
	                    case '"':
	                        if (elementLength === 0) {
	                            // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form
	                            updateResult(elementCount === 0 ? internals.diagnoses.rfc5321QuotedString : internals.diagnoses.deprecatedLocalPart);

	                            parseData.local += token;
	                            atomData.locals[elementCount] += token;
	                            ++elementLength;

	                            // Quoted string must be the entire element
	                            assertEnd = true;
	                            context.stack.push(context.now);
	                            context.now = internals.components.contextQuotedString;
	                        }
	                        else {
	                            updateResult(internals.diagnoses.errExpectingATEXT);
	                        }

	                        break;

	                    // Folding white space
	                    case '\r':
	                        if (emailLength === ++i || email[i] !== '\n') {
	                            // Fatal error
	                            updateResult(internals.diagnoses.errCRNoLF);
	                            break;
	                        }

	                        // Fallthrough

	                    case ' ':
	                    case '\t':
	                        if (elementLength === 0) {
	                            updateResult(elementCount === 0 ? internals.diagnoses.cfwsFWS : internals.diagnoses.deprecatedFWS);
	                        }
	                        else {
	                            // We can't start FWS in the middle of an element, better be end
	                            assertEnd = true;
	                        }

	                        context.stack.push(context.now);
	                        context.now = internals.components.contextFWS;
	                        prevToken = token;
	                        break;

	                    case '@':
	                        // At this point we should have a valid local-part
	                        // $lab:coverage:off$
	                        if (context.stack.length !== 1) {
	                            throw new Error('unexpected item on context stack');
	                        }
	                        // $lab:coverage:on$

	                        if (parseData.local.length === 0) {
	                            // Fatal error
	                            updateResult(internals.diagnoses.errNoLocalPart);
	                        }
	                        else if (elementLength === 0) {
	                            // Fatal error
	                            updateResult(internals.diagnoses.errDotEnd);
	                        }
	                        // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1 the maximum total length of a user name or other local-part is 64
	                        //    octets
	                        else if (parseData.local.length > 64) {
	                            updateResult(internals.diagnoses.rfc5322LocalTooLong);
	                        }
	                        // http://tools.ietf.org/html/rfc5322#section-3.4.1 comments and folding white space SHOULD NOT be used around "@" in the
	                        //    addr-spec
	                        //
	                        // http://tools.ietf.org/html/rfc2119
	                        // 4. SHOULD NOT this phrase, or the phrase "NOT RECOMMENDED" mean that there may exist valid reasons in particular
	                        //    circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood
	                        //    and the case carefully weighed before implementing any behavior described with this label.
	                        else if (context.prev === internals.components.contextComment || context.prev === internals.components.contextFWS) {
	                            updateResult(internals.diagnoses.deprecatedCFWSNearAt);
	                        }

	                        // Clear everything down for the domain parsing
	                        context.now = internals.components.domain;
	                        context.stack[0] = internals.components.domain;
	                        elementCount = 0;
	                        elementLength = 0;
	                        assertEnd = false; // CFWS can only appear at the end of the element
	                        break;

	                    // ATEXT
	                    default:
	                        // http://tools.ietf.org/html/rfc5322#section-3.2.3
	                        //    atext = ALPHA / DIGIT / ; Printable US-ASCII
	                        //            "!" / "#" /     ;  characters not including
	                        //            "$" / "%" /     ;  specials.  Used for atoms.
	                        //            "&" / "'" /
	                        //            "*" / "+" /
	                        //            "-" / "/" /
	                        //            "=" / "?" /
	                        //            "^" / "_" /
	                        //            "`" / "{" /
	                        //            "|" / "}" /
	                        //            "~"
	                        if (assertEnd) {
	                            // We have encountered atext where it is no longer valid
	                            switch (context.prev) {
	                                case internals.components.contextComment:
	                                case internals.components.contextFWS:
	                                    updateResult(internals.diagnoses.errATEXTAfterCFWS);
	                                    break;

	                                case internals.components.contextQuotedString:
	                                    updateResult(internals.diagnoses.errATEXTAfterQS);
	                                    break;

	                                // $lab:coverage:off$
	                                default:
	                                    throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);
	                                // $lab:coverage:on$
	                            }
	                        }
	                        else {
	                            context.prev = context.now;
	                            charCode = token.charCodeAt(0);

	                            // Especially if charCode == 10
	                            if (charCode < 33 || charCode > 126 || specialsLookup(charCode)) {

	                                // Fatal error
	                                updateResult(internals.diagnoses.errExpectingATEXT);
	                            }

	                            parseData.local += token;
	                            atomData.locals[elementCount] += token;
	                            ++elementLength;
	                        }
	                }

	                break;

	            case internals.components.domain:
	                // http://tools.ietf.org/html/rfc5322#section-3.4.1
	                //   domain          =   dot-atom / domain-literal / obs-domain
	                //
	                //   dot-atom        =   [CFWS] dot-atom-text [CFWS]
	                //
	                //   dot-atom-text   =   1*atext *("." 1*atext)
	                //
	                //   domain-literal  =   [CFWS] "[" *([FWS] dtext) [FWS] "]" [CFWS]
	                //
	                //   dtext           =   %d33-90 /          ; Printable US-ASCII
	                //                       %d94-126 /         ;  characters not including
	                //                       obs-dtext          ;  "[", "]", or "\"
	                //
	                //   obs-domain      =   atom *("." atom)
	                //
	                //   atom            =   [CFWS] 1*atext [CFWS]

	                // http://tools.ietf.org/html/rfc5321#section-4.1.2
	                //   Mailbox        = Local-part "@" ( Domain / address-literal )
	                //
	                //   Domain         = sub-domain *("." sub-domain)
	                //
	                //   address-literal  = "[" ( IPv4-address-literal /
	                //                    IPv6-address-literal /
	                //                    General-address-literal ) "]"
	                //                    ; See Section 4.1.3

	                // http://tools.ietf.org/html/rfc5322#section-3.4.1
	                //      Note: A liberal syntax for the domain portion of addr-spec is
	                //      given here.  However, the domain portion contains addressing
	                //      information specified by and used in other protocols (e.g.,
	                //      [RFC1034], [RFC1035], [RFC1123], [RFC5321]).  It is therefore
	                //      incumbent upon implementations to conform to the syntax of
	                //      addresses for the context in which they are used.
	                //
	                // is_email() author's note: it's not clear how to interpret this in
	                // he context of a general email address validator. The conclusion I
	                // have reached is this: "addressing information" must comply with
	                // RFC 5321 (and in turn RFC 1035), anything that is "semantically
	                // invisible" must comply only with RFC 5322.
	                switch (token) {
	                    // Comment
	                    case '(':
	                        if (elementLength === 0) {
	                            // Comments at the start of the domain are deprecated in the text, comments at the start of a subdomain are obs-domain
	                            // http://tools.ietf.org/html/rfc5322#section-3.4.1
	                            updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedComment);
	                        }
	                        else {
	                            // We can't start a comment mid-element, better be at the end
	                            assertEnd = true;
	                            updateResult(internals.diagnoses.cfwsComment);
	                        }

	                        context.stack.push(context.now);
	                        context.now = internals.components.contextComment;
	                        break;

	                    // Next dot-atom element
	                    case '.':
	                        if (elementLength === 0) {
	                            // Another dot, already? Fatal error.
	                            updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);
	                        }
	                        else if (hyphenFlag) {
	                            // Previous subdomain ended in a hyphen. Fatal error.
	                            updateResult(internals.diagnoses.errDomainHyphenEnd);
	                        }
	                        else if (elementLength > 63) {
	                            // Nowhere in RFC 5321 does it say explicitly that the domain part of a Mailbox must be a valid domain according to the
	                            // DNS standards set out in RFC 1035, but this *is* implied in several places. For instance, wherever the idea of host
	                            // routing is discussed the RFC says that the domain must be looked up in the DNS. This would be nonsense unless the
	                            // domain was designed to be a valid DNS domain. Hence we must conclude that the RFC 1035 restriction on label length
	                            // also applies to RFC 5321 domains.
	                            //
	                            // http://tools.ietf.org/html/rfc1035#section-2.3.4
	                            // labels          63 octets or less

	                            updateResult(internals.diagnoses.rfc5322LabelTooLong);
	                        }

	                        // CFWS is OK again now we're at the beginning of an element (although
	                        // it may be obsolete CFWS)
	                        assertEnd = false;
	                        elementLength = 0;
	                        ++elementCount;
	                        atomData.domains[elementCount] = '';
	                        parseData.domain += token;

	                        break;

	                    // Domain literal
	                    case '[':
	                        if (parseData.domain.length === 0) {
	                            // Domain literal must be the only component
	                            assertEnd = true;
	                            ++elementLength;
	                            context.stack.push(context.now);
	                            context.now = internals.components.literal;
	                            parseData.domain += token;
	                            atomData.domains[elementCount] += token;
	                            parseData.literal = '';
	                        }
	                        else {
	                            // Fatal error
	                            updateResult(internals.diagnoses.errExpectingATEXT);
	                        }

	                        break;

	                    // Folding white space
	                    case '\r':
	                        if (emailLength === ++i || email[i] !== '\n') {
	                            // Fatal error
	                            updateResult(internals.diagnoses.errCRNoLF);
	                            break;
	                        }

	                        // Fallthrough

	                    case ' ':
	                    case '\t':
	                        if (elementLength === 0) {
	                            updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedFWS);
	                        }
	                        else {
	                            // We can't start FWS in the middle of an element, so this better be the end
	                            updateResult(internals.diagnoses.cfwsFWS);
	                            assertEnd = true;
	                        }

	                        context.stack.push(context.now);
	                        context.now = internals.components.contextFWS;
	                        prevToken = token;
	                        break;

	                    // This must be ATEXT
	                    default:
	                        // RFC 5322 allows any atext...
	                        // http://tools.ietf.org/html/rfc5322#section-3.2.3
	                        //    atext = ALPHA / DIGIT / ; Printable US-ASCII
	                        //            "!" / "#" /     ;  characters not including
	                        //            "$" / "%" /     ;  specials.  Used for atoms.
	                        //            "&" / "'" /
	                        //            "*" / "+" /
	                        //            "-" / "/" /
	                        //            "=" / "?" /
	                        //            "^" / "_" /
	                        //            "`" / "{" /
	                        //            "|" / "}" /
	                        //            "~"

	                        // But RFC 5321 only allows letter-digit-hyphen to comply with DNS rules
	                        //   (RFCs 1034 & 1123)
	                        // http://tools.ietf.org/html/rfc5321#section-4.1.2
	                        //   sub-domain     = Let-dig [Ldh-str]
	                        //
	                        //   Let-dig        = ALPHA / DIGIT
	                        //
	                        //   Ldh-str        = *( ALPHA / DIGIT / "-" ) Let-dig
	                        //
	                        if (assertEnd) {
	                            // We have encountered ATEXT where it is no longer valid
	                            switch (context.prev) {
	                                case internals.components.contextComment:
	                                case internals.components.contextFWS:
	                                    updateResult(internals.diagnoses.errATEXTAfterCFWS);
	                                    break;

	                                case internals.components.literal:
	                                    updateResult(internals.diagnoses.errATEXTAfterDomainLiteral);
	                                    break;

	                                // $lab:coverage:off$
	                                default:
	                                    throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);
	                                // $lab:coverage:on$
	                            }
	                        }

	                        charCode = token.charCodeAt(0);
	                        // Assume this token isn't a hyphen unless we discover it is
	                        hyphenFlag = false;

	                        if (charCode < 33 || charCode > 126 || specialsLookup(charCode)) {
	                            // Fatal error
	                            updateResult(internals.diagnoses.errExpectingATEXT);
	                        }
	                        else if (token === '-') {
	                            if (elementLength === 0) {
	                                // Hyphens cannot be at the beginning of a subdomain, fatal error
	                                updateResult(internals.diagnoses.errDomainHyphenStart);
	                            }

	                            hyphenFlag = true;
	                        }
	                        // Check if it's a neither a number nor a latin letter
	                        else if (charCode < 48 || charCode > 122 || (charCode > 57 && charCode < 65) || (charCode > 90 && charCode < 97)) {
	                            // This is not an RFC 5321 subdomain, but still OK by RFC 5322
	                            updateResult(internals.diagnoses.rfc5322Domain);
	                        }

	                        parseData.domain += token;
	                        atomData.domains[elementCount] += token;
	                        ++elementLength;
	                }

	                break;

	            // Domain literal
	            case internals.components.literal:
	                // http://tools.ietf.org/html/rfc5322#section-3.4.1
	                //   domain-literal  =   [CFWS] "[" *([FWS] dtext) [FWS] "]" [CFWS]
	                //
	                //   dtext           =   %d33-90 /          ; Printable US-ASCII
	                //                       %d94-126 /         ;  characters not including
	                //                       obs-dtext          ;  "[", "]", or "\"
	                //
	                //   obs-dtext       =   obs-NO-WS-CTL / quoted-pair
	                switch (token) {
	                    // End of domain literal
	                    case ']':
	                        if (maxResult < internals.categories.deprecated) {
	                            // Could be a valid RFC 5321 address literal, so let's check

	                            // http://tools.ietf.org/html/rfc5321#section-4.1.2
	                            //   address-literal  = "[" ( IPv4-address-literal /
	                            //                    IPv6-address-literal /
	                            //                    General-address-literal ) "]"
	                            //                    ; See Section 4.1.3
	                            //
	                            // http://tools.ietf.org/html/rfc5321#section-4.1.3
	                            //   IPv4-address-literal  = Snum 3("."  Snum)
	                            //
	                            //   IPv6-address-literal  = "IPv6:" IPv6-addr
	                            //
	                            //   General-address-literal  = Standardized-tag ":" 1*dcontent
	                            //
	                            //   Standardized-tag  = Ldh-str
	                            //                     ; Standardized-tag MUST be specified in a
	                            //                     ; Standards-Track RFC and registered with IANA
	                            //
	                            //   dcontent      = %d33-90 / ; Printable US-ASCII
	                            //                 %d94-126 ; excl. "[", "\", "]"
	                            //
	                            //   Snum          = 1*3DIGIT
	                            //                 ; representing a decimal integer
	                            //                 ; value in the range 0 through 255
	                            //
	                            //   IPv6-addr     = IPv6-full / IPv6-comp / IPv6v4-full / IPv6v4-comp
	                            //
	                            //   IPv6-hex      = 1*4HEXDIG
	                            //
	                            //   IPv6-full     = IPv6-hex 7(":" IPv6-hex)
	                            //
	                            //   IPv6-comp     = [IPv6-hex *5(":" IPv6-hex)] "::"
	                            //                 [IPv6-hex *5(":" IPv6-hex)]
	                            //                 ; The "::" represents at least 2 16-bit groups of
	                            //                 ; zeros.  No more than 6 groups in addition to the
	                            //                 ; "::" may be present.
	                            //
	                            //   IPv6v4-full   = IPv6-hex 5(":" IPv6-hex) ":" IPv4-address-literal
	                            //
	                            //   IPv6v4-comp   = [IPv6-hex *3(":" IPv6-hex)] "::"
	                            //                 [IPv6-hex *3(":" IPv6-hex) ":"]
	                            //                 IPv4-address-literal
	                            //                 ; The "::" represents at least 2 16-bit groups of
	                            //                 ; zeros.  No more than 4 groups in addition to the
	                            //                 ; "::" and IPv4-address-literal may be present.

	                            var index = -1;
	                            var addressLiteral = parseData.literal;
	                            var matchesIP = IPv4_REGEX.exec(addressLiteral);

	                            // Maybe extract IPv4 part from the end of the address-literal
	                            if (matchesIP) {
	                                index = matchesIP.index;
	                                if (index !== 0) {
	                                    // Convert IPv4 part to IPv6 format for futher testing
	                                    addressLiteral = addressLiteral.slice(0, index) + '0:0';
	                                }
	                            }

	                            if (index === 0) {
	                                // Nothing there except a valid IPv4 address, so...
	                                updateResult(internals.diagnoses.rfc5321AddressLiteral);
	                            }
	                            else if (addressLiteral.slice(0, 5).toLowerCase() !== 'ipv6:') {
	                                updateResult(internals.diagnoses.rfc5322DomainLiteral);
	                            }
	                            else {
	                                var match = addressLiteral.slice(5);
	                                var maxGroups = internals.maxIPv6Groups;
	                                var groups = match.split(':');
	                                index = match.indexOf('::');

	                                if (!~index) {
	                                    // Need exactly the right number of groups
	                                    if (groups.length !== maxGroups) {
	                                        updateResult(internals.diagnoses.rfc5322IPv6GroupCount);
	                                    }
	                                }
	                                else if (index !== match.lastIndexOf('::')) {
	                                    updateResult(internals.diagnoses.rfc5322IPv62x2xColon);
	                                }
	                                else {
	                                    if (index === 0 || index === match.length - 2) {
	                                        // RFC 4291 allows :: at the start or end of an address with 7 other groups in addition
	                                        ++maxGroups;
	                                    }

	                                    if (groups.length > maxGroups) {
	                                        updateResult(internals.diagnoses.rfc5322IPv6MaxGroups);
	                                    }
	                                    else if (groups.length === maxGroups) {
	                                        // Eliding a single "::"
	                                        updateResult(internals.diagnoses.deprecatedIPv6);
	                                    }
	                                }

	                                // IPv6 testing strategy
	                                if (match[0] === ':' && match[1] !== ':') {
	                                    updateResult(internals.diagnoses.rfc5322IPv6ColonStart);
	                                }
	                                else if (match[match.length - 1] === ':' && match[match.length - 2] !== ':') {
	                                    updateResult(internals.diagnoses.rfc5322IPv6ColonEnd);
	                                }
	                                else if (groups.every(IPv6_REGEX_TEST)) {
	                                    updateResult(internals.diagnoses.rfc5321AddressLiteral);
	                                }
	                                else {
	                                    updateResult(internals.diagnoses.rfc5322IPv6BadCharacter);
	                                }
	                            }
	                        }
	                        else {
	                            updateResult(internals.diagnoses.rfc5322DomainLiteral);
	                        }

	                        parseData.domain += token;
	                        atomData.domains[elementCount] += token;
	                        ++elementLength;
	                        context.prev = context.now;
	                        context.now = context.stack.pop();
	                        break;

	                    case '\\':
	                        updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);
	                        context.stack.push(context.now);
	                        context.now = internals.components.contextQuotedPair;
	                        break;

	                    // Folding white space
	                    case '\r':
	                        if (emailLength === ++i || email[i] !== '\n') {
	                            updateResult(internals.diagnoses.errCRNoLF);
	                            break;
	                        }

	                        // Fallthrough

	                    case ' ':
	                    case '\t':
	                        updateResult(internals.diagnoses.cfwsFWS);

	                        context.stack.push(context.now);
	                        context.now = internals.components.contextFWS;
	                        prevToken = token;
	                        break;

	                    // DTEXT
	                    default:
	                        // http://tools.ietf.org/html/rfc5322#section-3.4.1
	                        //   dtext         =   %d33-90 /  ; Printable US-ASCII
	                        //                     %d94-126 / ;  characters not including
	                        //                     obs-dtext  ;  "[", "]", or "\"
	                        //
	                        //   obs-dtext     =   obs-NO-WS-CTL / quoted-pair
	                        //
	                        //   obs-NO-WS-CTL =   %d1-8 /    ; US-ASCII control
	                        //                     %d11 /     ;  characters that do not
	                        //                     %d12 /     ;  include the carriage
	                        //                     %d14-31 /  ;  return, line feed, and
	                        //                     %d127      ;  white space characters
	                        charCode = token.charCodeAt(0);

	                        // '\r', '\n', ' ', and '\t' have already been parsed above
	                        if (charCode > 127 || charCode === 0 || token === '[') {
	                            // Fatal error
	                            updateResult(internals.diagnoses.errExpectingDTEXT);
	                            break;
	                        }
	                        else if (charCode < 33 || charCode === 127) {
	                            updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);
	                        }

	                        parseData.literal += token;
	                        parseData.domain += token;
	                        atomData.domains[elementCount] += token;
	                        ++elementLength;
	                }

	                break;

	            // Quoted string
	            case internals.components.contextQuotedString:
	                // http://tools.ietf.org/html/rfc5322#section-3.2.4
	                //   quoted-string = [CFWS]
	                //                   DQUOTE *([FWS] qcontent) [FWS] DQUOTE
	                //                   [CFWS]
	                //
	                //   qcontent      = qtext / quoted-pair
	                switch (token) {
	                    // Quoted pair
	                    case '\\':
	                        context.stack.push(context.now);
	                        context.now = internals.components.contextQuotedPair;
	                        break;

	                    // Folding white space. Spaces are allowed as regular characters inside a quoted string - it's only FWS if we include '\t' or '\r\n'
	                    case '\r':
	                        if (emailLength === ++i || email[i] !== '\n') {
	                            // Fatal error
	                            updateResult(internals.diagnoses.errCRNoLF);
	                            break;
	                        }

	                        // Fallthrough

	                    case '\t':
	                        // http://tools.ietf.org/html/rfc5322#section-3.2.2
	                        //   Runs of FWS, comment, or CFWS that occur between lexical tokens in
	                        //   a structured header field are semantically interpreted as a single
	                        //   space character.

	                        // http://tools.ietf.org/html/rfc5322#section-3.2.4
	                        //   the CRLF in any FWS/CFWS that appears within the quoted-string [is]
	                        //   semantically "invisible" and therefore not part of the
	                        //   quoted-string

	                        parseData.local += ' ';
	                        atomData.locals[elementCount] += ' ';
	                        ++elementLength;

	                        updateResult(internals.diagnoses.cfwsFWS);
	                        context.stack.push(context.now);
	                        context.now = internals.components.contextFWS;
	                        prevToken = token;
	                        break;

	                    // End of quoted string
	                    case '"':
	                        parseData.local += token;
	                        atomData.locals[elementCount] += token;
	                        ++elementLength;
	                        context.prev = context.now;
	                        context.now = context.stack.pop();
	                        break;

	                    // QTEXT
	                    default:
	                        // http://tools.ietf.org/html/rfc5322#section-3.2.4
	                        //   qtext          =   %d33 /             ; Printable US-ASCII
	                        //                      %d35-91 /          ;  characters not including
	                        //                      %d93-126 /         ;  "\" or the quote character
	                        //                      obs-qtext
	                        //
	                        //   obs-qtext      =   obs-NO-WS-CTL
	                        //
	                        //   obs-NO-WS-CTL  =   %d1-8 /            ; US-ASCII control
	                        //                      %d11 /             ;  characters that do not
	                        //                      %d12 /             ;  include the carriage
	                        //                      %d14-31 /          ;  return, line feed, and
	                        //                      %d127              ;  white space characters
	                        charCode = token.charCodeAt(0);

	                        if (charCode > 127 || charCode === 0 || charCode === 10) {
	                            updateResult(internals.diagnoses.errExpectingQTEXT);
	                        }
	                        else if (charCode < 32 || charCode === 127) {
	                            updateResult(internals.diagnoses.deprecatedQTEXT);
	                        }

	                        parseData.local += token;
	                        atomData.locals[elementCount] += token;
	                        ++elementLength;
	                }

	                // http://tools.ietf.org/html/rfc5322#section-3.4.1
	                //   If the string can be represented as a dot-atom (that is, it contains
	                //   no characters other than atext characters or "." surrounded by atext
	                //   characters), then the dot-atom form SHOULD be used and the quoted-
	                //   string form SHOULD NOT be used.

	                break;
	            // Quoted pair
	            case internals.components.contextQuotedPair:
	                // http://tools.ietf.org/html/rfc5322#section-3.2.1
	                //   quoted-pair     =   ("\" (VCHAR / WSP)) / obs-qp
	                //
	                //   VCHAR           =  %d33-126   ; visible (printing) characters
	                //   WSP             =  SP / HTAB  ; white space
	                //
	                //   obs-qp          =   "\" (%d0 / obs-NO-WS-CTL / LF / CR)
	                //
	                //   obs-NO-WS-CTL   =   %d1-8 /   ; US-ASCII control
	                //                       %d11 /    ;  characters that do not
	                //                       %d12 /    ;  include the carriage
	                //                       %d14-31 / ;  return, line feed, and
	                //                       %d127     ;  white space characters
	                //
	                // i.e. obs-qp       =  "\" (%d0-8, %d10-31 / %d127)
	                charCode = token.charCodeAt(0);

	                if (charCode > 127) {
	                    // Fatal error
	                    updateResult(internals.diagnoses.errExpectingQPair);
	                }
	                else if ((charCode < 31 && charCode !== 9) || charCode === 127) {
	                    // ' ' and '\t' are allowed
	                    updateResult(internals.diagnoses.deprecatedQP);
	                }

	                // At this point we know where this qpair occurred so we could check to see if the character actually needed to be quoted at all.
	                // http://tools.ietf.org/html/rfc5321#section-4.1.2
	                //   the sending system SHOULD transmit the form that uses the minimum quoting possible.

	                context.prev = context.now;
	                // End of qpair
	                context.now = context.stack.pop();
	                token = '\\' + token;

	                switch (context.now) {
	                    case internals.components.contextComment:
	                        break;

	                    case internals.components.contextQuotedString:
	                        parseData.local += token;
	                        atomData.locals[elementCount] += token;

	                        // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash
	                        elementLength += 2;
	                        break;

	                    case internals.components.literal:
	                        parseData.domain += token;
	                        atomData.domains[elementCount] += token;

	                        // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash
	                        elementLength += 2;
	                        break;

	                    // $lab:coverage:off$
	                    default:
	                        throw new Error('quoted pair logic invoked in an invalid context: ' + context.now);
	                    // $lab:coverage:on$
	                }
	                break;

	            // Comment
	            case internals.components.contextComment:
	                // http://tools.ietf.org/html/rfc5322#section-3.2.2
	                //   comment  = "(" *([FWS] ccontent) [FWS] ")"
	                //
	                //   ccontent = ctext / quoted-pair / comment
	                switch (token) {
	                    // Nested comment
	                    case '(':
	                        // Nested comments are ok
	                        context.stack.push(context.now);
	                        context.now = internals.components.contextComment;
	                        break;

	                    // End of comment
	                    case ')':
	                        context.prev = context.now;
	                        context.now = context.stack.pop();
	                        break;

	                    // Quoted pair
	                    case '\\':
	                        context.stack.push(context.now);
	                        context.now = internals.components.contextQuotedPair;
	                        break;

	                    // Folding white space
	                    case '\r':
	                        if (emailLength === ++i || email[i] !== '\n') {
	                            // Fatal error
	                            updateResult(internals.diagnoses.errCRNoLF);
	                            break;
	                        }

	                        // Fallthrough

	                    case ' ':
	                    case '\t':
	                        updateResult(internals.diagnoses.cfwsFWS);

	                        context.stack.push(context.now);
	                        context.now = internals.components.contextFWS;
	                        prevToken = token;
	                        break;

	                    // CTEXT
	                    default:
	                        // http://tools.ietf.org/html/rfc5322#section-3.2.3
	                        //   ctext         = %d33-39 /  ; Printable US-ASCII
	                        //                   %d42-91 /  ;  characters not including
	                        //                   %d93-126 / ;  "(", ")", or "\"
	                        //                   obs-ctext
	                        //
	                        //   obs-ctext     = obs-NO-WS-CTL
	                        //
	                        //   obs-NO-WS-CTL = %d1-8 /    ; US-ASCII control
	                        //                   %d11 /     ;  characters that do not
	                        //                   %d12 /     ;  include the carriage
	                        //                   %d14-31 /  ;  return, line feed, and
	                        //                   %d127      ;  white space characters
	                        charCode = token.charCodeAt(0);

	                        if (charCode > 127 || charCode === 0 || charCode === 10) {
	                            // Fatal error
	                            updateResult(internals.diagnoses.errExpectingCTEXT);
	                            break;
	                        }
	                        else if (charCode < 32 || charCode === 127) {
	                            updateResult(internals.diagnoses.deprecatedCTEXT);
	                        }
	                }

	                break;

	            // Folding white space
	            case internals.components.contextFWS:
	                // http://tools.ietf.org/html/rfc5322#section-3.2.2
	                //   FWS     =   ([*WSP CRLF] 1*WSP) /  obs-FWS
	                //                                   ; Folding white space

	                // But note the erratum:
	                // http://www.rfc-editor.org/errata_search.php?rfc=5322&eid=1908:
	                //   In the obsolete syntax, any amount of folding white space MAY be
	                //   inserted where the obs-FWS rule is allowed.  This creates the
	                //   possibility of having two consecutive "folds" in a line, and
	                //   therefore the possibility that a line which makes up a folded header
	                //   field could be composed entirely of white space.
	                //
	                //   obs-FWS =   1*([CRLF] WSP)

	                if (prevToken === '\r') {
	                    if (token === '\r') {
	                        // Fatal error
	                        updateResult(internals.diagnoses.errFWSCRLFx2);
	                        break;
	                    }

	                    if (++crlfCount > 1) {
	                        // Multiple folds => obsolete FWS
	                        updateResult(internals.diagnoses.deprecatedFWS);
	                    }
	                    else {
	                        crlfCount = 1;
	                    }
	                }

	                switch (token) {
	                    case '\r':
	                        if (emailLength === ++i || email[i] !== '\n') {
	                            // Fatal error
	                            updateResult(internals.diagnoses.errCRNoLF);
	                        }

	                        break;

	                    case ' ':
	                    case '\t':
	                        break;

	                    default:
	                        if (prevToken === '\r') {
	                            // Fatal error
	                            updateResult(internals.diagnoses.errFWSCRLFEnd);
	                        }

	                        crlfCount = 0;

	                        // End of FWS
	                        context.prev = context.now;
	                        context.now = context.stack.pop();

	                        // Look at this token again in the parent context
	                        --i;
	                }

	                prevToken = token;
	                break;

	            // Unexpected context
	            // $lab:coverage:off$
	            default:
	                throw new Error('unknown context: ' + context.now);
	            // $lab:coverage:on$
	        } // Primary state machine

	        if (maxResult > internals.categories.rfc5322) {
	            // Fatal error, no point continuing
	            break;
	        }
	    } // Token loop

	    // Check for errors
	    if (maxResult < internals.categories.rfc5322) {
	        // Fatal errors
	        if (context.now === internals.components.contextQuotedString) {
	            updateResult(internals.diagnoses.errUnclosedQuotedString);
	        }
	        else if (context.now === internals.components.contextQuotedPair) {
	            updateResult(internals.diagnoses.errBackslashEnd);
	        }
	        else if (context.now === internals.components.contextComment) {
	            updateResult(internals.diagnoses.errUnclosedComment);
	        }
	        else if (context.now === internals.components.literal) {
	            updateResult(internals.diagnoses.errUnclosedDomainLiteral);
	        }
	        else if (token === '\r') {
	            updateResult(internals.diagnoses.errFWSCRLFEnd);
	        }
	        else if (parseData.domain.length === 0) {
	            updateResult(internals.diagnoses.errNoDomain);
	        }
	        else if (elementLength === 0) {
	            updateResult(internals.diagnoses.errDotEnd);
	        }
	        else if (hyphenFlag) {
	            updateResult(internals.diagnoses.errDomainHyphenEnd);
	        }

	        // Other errors
	        else if (parseData.domain.length > 255) {
	            // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.2
	            //   The maximum total length of a domain name or number is 255 octets.
	            updateResult(internals.diagnoses.rfc5322DomainTooLong);
	        }
	        else if (parseData.local.length + parseData.domain.length + /* '@' */ 1 > 254) {
	            // http://tools.ietf.org/html/rfc5321#section-4.1.2
	            //   Forward-path   = Path
	            //
	            //   Path           = "<" [ A-d-l ":" ] Mailbox ">"
	            //
	            // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3
	            //   The maximum total length of a reverse-path or forward-path is 256 octets (including the punctuation and element separators).
	            //
	            // Thus, even without (obsolete) routing information, the Mailbox can only be 254 characters long. This is confirmed by this verified
	            // erratum to RFC 3696:
	            //
	            // http://www.rfc-editor.org/errata_search.php?rfc=3696&eid=1690
	            //   However, there is a restriction in RFC 2821 on the length of an address in MAIL and RCPT commands of 254 characters.  Since
	            //   addresses that do not fit in those fields are not normally useful, the upper limit on address lengths should normally be considered
	            //   to be 254.
	            updateResult(internals.diagnoses.rfc5322TooLong);
	        }
	        else if (elementLength > 63) {
	            // http://tools.ietf.org/html/rfc1035#section-2.3.4
	            // labels   63 octets or less
	            updateResult(internals.diagnoses.rfc5322LabelTooLong);
	        }
	        else if (options.minDomainAtoms && atomData.domains.length < options.minDomainAtoms) {
	            updateResult(internals.diagnoses.errDomainTooShort);
	        }
	        else if (options.tldWhitelist) {
	            var tldAtom = atomData.domains[elementCount];
	            if (Array.isArray(options.tldWhitelist)) {
	                var tldValid = false;
	                for (i = 0, il = options.tldWhitelist.length; i < il; ++i) {
	                    if (tldAtom === options.tldWhitelist[i]) {
	                        tldValid = true;
	                        break;
	                    }
	                }

	                if (!tldValid) {
	                    updateResult(internals.diagnoses.errUnknownTLD);
	                }
	            }
	            else if (!hasOwn.call(options.tldWhitelist, tldAtom)) {
	                updateResult(internals.diagnoses.errUnknownTLD);
	            }
	        }
	    } // Check for errors

	    var dnsPositive = false;
	    var finishImmediately = false;

	    var finish = function finish () {

	        if (!dnsPositive && maxResult < internals.categories.dnsWarn) {
	            // Per RFC 5321, domain atoms are limited to letter-digit-hyphen, so we only need to check code <= 57 to check for a digit
	            var code = atomData.domains[elementCount].charCodeAt(0);
	            if (code <= 57) {
	                updateResult(internals.diagnoses.rfc5321TLDNumeric);
	            }
	            else if (elementCount === 0) {
	                updateResult(internals.diagnoses.rfc5321TLD);
	            }
	        }

	        if (maxResult < threshold) {
	            maxResult = internals.diagnoses.valid;
	        }

	        var finishResult = diagnose ? maxResult : maxResult < internals.defaultThreshold;

	        if (callback) {
	            if (finishImmediately) {
	                callback(finishResult);
	            } else {
	                internals.defer(callback.bind(null, finishResult));
	            }
	        }

	        return finishResult;
	    }; // Finish

	    if (options.checkDNS && maxResult < internals.categories.dnsWarn) {
	        // http://tools.ietf.org/html/rfc5321#section-2.3.5
	        //   Names that can be resolved to MX RRs or address (i.e., A or AAAA) RRs (as discussed in Section 5) are permitted, as are CNAME RRs whose
	        //   targets can be resolved, in turn, to MX or address RRs.
	        //
	        // http://tools.ietf.org/html/rfc5321#section-5.1
	        //   The lookup first attempts to locate an MX record associated with the name.  If a CNAME record is found, the resulting name is processed
	        //   as if it were the initial name. ... If an empty list of MXs is returned, the address is treated as if it was associated with an implicit
	        //   MX RR, with a preference of 0, pointing to that host.
	        //
	        // isEmail() author's note: We will regard the existence of a CNAME to be sufficient evidence of the domain's existence. For performance
	        // reasons we will not repeat the DNS lookup for the CNAME's target, but we will raise a warning because we didn't immediately find an MX
	        // record.
	        if (elementCount === 0) {
	            // Checking TLD DNS only works if you explicitly check from the root
	            parseData.domain += '.';
	        }

	        var dnsDomain = parseData.domain;
	        Dns.resolveMx(dnsDomain, function resolveDNS (err, mxRecords) {

	            // If we have a fatal error, then we must assume that there are no records
	            if (err && err.code !== Dns.NODATA) {
	                updateResult(internals.diagnoses.dnsWarnNoRecord);
	                return finish();
	            }

	            if (mxRecords && mxRecords.length) {
	                dnsPositive = true;
	                return finish();
	            }

	            var count = 3;
	            var done = false;
	            updateResult(internals.diagnoses.dnsWarnNoMXRecord);

	            var handleRecords = function handleRecords (err, records) {

	                if (done) {
	                    return;
	                }

	                --count;

	                if (records && records.length) {
	                    done = true;
	                    return finish();
	                }

	                if (count === 0) {
	                    // No usable records for the domain can be found
	                    updateResult(internals.diagnoses.dnsWarnNoRecord);
	                    done = true;
	                    finish();
	                }
	            };

	            Dns.resolveCname(dnsDomain, handleRecords);
	            Dns.resolve4(dnsDomain, handleRecords);
	            Dns.resolve6(dnsDomain, handleRecords);
	        });

	        finishImmediately = true;
	    }
	    else {
	        var result = finish();
	        finishImmediately = true;
	        return result;
	    } // CheckDNS
	};


	isEmail.diagnoses = (function exportDiagnoses () {

	    var diag = {};
	    for (var key in internals.diagnoses) {
	        diag[key] = internals.diagnoses[key];
	    }
	    return diag;
	})();

	module.exports = isEmail;


/***/ },
/* 305 */
/***/ function(module, exports) {

	module.exports = require("dns");

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	var RFC3986 = __webpack_require__(307);

	var internals = {
	    Uri: {
	        createUriRegex: function (optionalScheme) {

	            var scheme = RFC3986.scheme;

	            // If we were passed a scheme, use it instead of the generic one
	            if (optionalScheme) {

	                // Have to put this in a non-capturing group to handle the OR statements
	                scheme = '(?:' + optionalScheme + ')';
	            }

	            /**
	             * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
	             */
	            return new RegExp('^' + scheme + ':' + RFC3986.hierPart + '(?:\\?' + RFC3986.query + ')?' + '(?:#' + RFC3986.fragment + ')?$');
	        }
	    }
	};

	module.exports = internals.Uri;


/***/ },
/* 307 */
/***/ function(module, exports) {

	var internals = {
	    rfc3986: {}
	};

	/**
	 * elements separated by forward slash ("/") are alternatives.
	 */
	var or = '|';

	/**
	 * DIGIT = %x30-39 ; 0-9
	 */
	var digit = '0-9';
	var digitOnly = '[' + digit + ']';

	/**
	 * ALPHA = %x41-5A / %x61-7A   ; A-Z / a-z
	 */
	var alpha = 'a-zA-Z';
	var alphaOnly = '[' + alpha + ']';

	/**
	 * cidr       = DIGIT                ; 0-9
	 *            / %x31-32 DIGIT         ; 10-29
	 *            / "3" %x30-32           ; 30-32
	 */
	internals.rfc3986.cidr = digitOnly + or + '[1-2]' + digitOnly + or + '3' + '[0-2]';

	/**
	 * HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
	 */
	var hexDigit = digit + 'A-Fa-f',
	    hexDigitOnly = '[' + hexDigit + ']';

	/**
	 * unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
	 */
	var unreserved = alpha + digit + '-\\._~';

	/**
	 * sub-delims = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
	 */
	var subDelims = '!\\$&\'\\(\\)\\*\\+,;=';

	/**
	 * pct-encoded = "%" HEXDIG HEXDIG
	 */
	var pctEncoded = '%' + hexDigit;

	/**
	 * pchar = unreserved / pct-encoded / sub-delims / ":" / "@"
	 */
	var pchar = unreserved + pctEncoded + subDelims + ':@';
	var pcharOnly = '[' + pchar + ']';

	/**
	 * Rule to support zero-padded addresses.
	 */
	var zeroPad = '0?';

	/**
	 * dec-octet   = DIGIT                 ; 0-9
	 *            / %x31-39 DIGIT         ; 10-99
	 *            / "1" 2DIGIT            ; 100-199
	 *            / "2" %x30-34 DIGIT     ; 200-249
	 *            / "25" %x30-35          ; 250-255
	 */
	var decOctect = '(?:' + zeroPad + zeroPad + digitOnly + or + zeroPad + '[1-9]' + digitOnly + or + '1' + digitOnly + digitOnly + or + '2' + '[0-4]' + digitOnly + or + '25' + '[0-5])';

	/**
	 * IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet
	 */
	internals.rfc3986.IPv4address = '(?:' + decOctect + '\\.){3}' + decOctect;

	/**
	 * h16 = 1*4HEXDIG ; 16 bits of address represented in hexadecimal
	 * ls32 = ( h16 ":" h16 ) / IPv4address ; least-significant 32 bits of address
	 * IPv6address =                            6( h16 ":" ) ls32
	 *             /                       "::" 5( h16 ":" ) ls32
	 *             / [               h16 ] "::" 4( h16 ":" ) ls32
	 *             / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
	 *             / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
	 *             / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
	 *             / [ *4( h16 ":" ) h16 ] "::"              ls32
	 *             / [ *5( h16 ":" ) h16 ] "::"              h16
	 *             / [ *6( h16 ":" ) h16 ] "::"
	 */
	var h16 = hexDigitOnly + '{1,4}';
	var ls32 = '(?:' + h16 + ':' + h16 + '|' + internals.rfc3986.IPv4address + ')';
	var IPv6SixHex = '(?:' + h16 + ':){6}' + ls32;
	var IPv6FiveHex = '::(?:' + h16 + ':){5}' + ls32;
	var IPv6FourHex = h16 + '::(?:' + h16 + ':){4}' + ls32;
	var IPv6ThreeHex = '(?:' + h16 + ':){0,1}' + h16 + '::(?:' + h16 + ':){3}' + ls32;
	var IPv6TwoHex = '(?:' + h16 + ':){0,2}' + h16 + '::(?:' + h16 + ':){2}' + ls32;
	var IPv6OneHex = '(?:' + h16 + ':){0,3}' + h16 + '::' + h16 + ':' + ls32;
	var IPv6NoneHex = '(?:' + h16 + ':){0,4}' + h16 + '::' + ls32;
	var IPv6NoneHex2 = '(?:' + h16 + ':){0,5}' + h16 + '::' + h16;
	var IPv6NoneHex3 = '(?:' + h16 + ':){0,6}' + h16 + '::';
	internals.rfc3986.IPv6address = '(?:' + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ')';

	/**
	 * IPvFuture = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
	 */
	internals.rfc3986.IPvFuture = 'v' + hexDigitOnly + '+\\.[' + unreserved + subDelims + ':]+';

	/**
	 * scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
	 */
	internals.rfc3986.scheme = alphaOnly + '[' + alpha + digit + '+-\\.]*';

	/**
	 * userinfo = *( unreserved / pct-encoded / sub-delims / ":" )
	 */
	var userinfo = '[' + unreserved + pctEncoded + subDelims + ':]*';

	/**
	 * IP-literal = "[" ( IPv6address / IPvFuture  ) "]"
	 */
	var IPLiteral = '\\[(?:' + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ')\\]';

	/**
	 * reg-name = *( unreserved / pct-encoded / sub-delims )
	 */
	var regName = '[' + unreserved + pctEncoded + subDelims + ']{0,255}';

	/**
	 * host = IP-literal / IPv4address / reg-name
	 */
	var host = '(?:' + IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ')';

	/**
	 * port = *DIGIT
	 */
	var port = digitOnly + '*';

	/**
	 * authority   = [ userinfo "@" ] host [ ":" port ]
	 */
	var authority = '(?:' + userinfo + '@)?' + host + '(?::' + port + ')?';

	/**
	 * segment       = *pchar
	 * segment-nz    = 1*pchar
	 * path          = path-abempty    ; begins with "/" or is empty
	 *               / path-absolute   ; begins with "/" but not "//"
	 *               / path-noscheme   ; begins with a non-colon segment
	 *               / path-rootless   ; begins with a segment
	 *               / path-empty      ; zero characters
	 * path-abempty  = *( "/" segment )
	 * path-absolute = "/" [ segment-nz *( "/" segment ) ]
	 * path-rootless = segment-nz *( "/" segment )
	 */
	var segment = pcharOnly + '*';
	var segmentNz = pcharOnly + '+';
	var pathAbEmpty = '(?:\\/' + segment + ')*';
	var pathAbsolute = '\\/(?:' + segmentNz + pathAbEmpty + ')?';
	var pathRootless = segmentNz + pathAbEmpty;

	/**
	 * hier-part = "//" authority path
	 */
	internals.rfc3986.hierPart = '(?:\\/\\/' + authority + pathAbEmpty + or + pathAbsolute + or + pathRootless + ')';

	/**
	 * query = *( pchar / "/" / "?" )
	 */
	internals.rfc3986.query = '[' + pchar + '\\/\\?]*(?=#|$)'; //Finish matching either at the fragment part or end of the line.

	/**
	 * fragment = *( pchar / "/" / "?" )
	 */
	internals.rfc3986.fragment = '[' + pchar + '\\/\\?]*';

	module.exports = internals.rfc3986;


/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	var RFC3986 = __webpack_require__(307);

	var internals = {
	    Ip: {
	        cidrs: {
	            required: '\\/(?:' + RFC3986.cidr + ')',
	            optional: '(?:\\/(?:' + RFC3986.cidr + '))?',
	            forbidden: ''
	        },
	        versions: {
	            ipv4: RFC3986.IPv4address,
	            ipv6: RFC3986.IPv6address,
	            ipvfuture: RFC3986.IPvFuture
	        }
	    }
	};

	internals.Ip.createIpRegex = function (versions, cidr) {

	    var regex;
	    for (var i = 0, il = versions.length; i < il; ++i) {
	        var version = versions[i];
	        if (!regex) {
	            regex = '^(?:' + internals.Ip.versions[version];
	        }
	        regex += '|' + internals.Ip.versions[version];
	    }

	    return new RegExp(regex + ')' + internals.Ip.cidrs[cidr] + '$');
	};

	module.exports = internals.Ip;


/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Any = __webpack_require__(186);
	var Ref = __webpack_require__(190);
	var Errors = __webpack_require__(191);
	var Hoek = __webpack_require__(187);


	// Declare internals

	var internals = {};


	internals.Number = function () {

	    Any.call(this);
	    this._type = 'number';
	    this._invalids.add(Infinity);
	    this._invalids.add(-Infinity);
	};

	Hoek.inherits(internals.Number, Any);

	internals.compare = function (type, compare) {

	    return function (limit) {

	        var isRef = Ref.isRef(limit);
	        var isNumber = typeof limit === 'number' && !isNaN(limit);

	        Hoek.assert(isNumber || isRef, 'limit must be a number or reference');

	        return this._test(type, limit, function (value, state, options) {

	            var compareTo;
	            if (isRef) {
	                compareTo = limit(state.parent, options);

	                if (!(typeof compareTo === 'number' && !isNaN(compareTo))) {
	                    return Errors.create('number.ref', { ref: limit.key }, state, options);
	                }
	            }
	            else {
	                compareTo = limit;
	            }

	            if (compare(value, compareTo)) {
	                return null;
	            }

	            return Errors.create('number.' + type, { limit: compareTo, value: value }, state, options);
	        });
	    };
	};


	internals.Number.prototype._base = function (value, state, options) {

	    var result = {
	        errors: null,
	        value: value
	    };

	    if (typeof value === 'string' &&
	        options.convert) {

	        var number = parseFloat(value);
	        result.value = (isNaN(number) || !isFinite(value)) ? NaN : number;
	    }

	    var isNumber = typeof result.value === 'number' && !isNaN(result.value);

	    if (options.convert && 'precision' in this._flags && isNumber) {

	        // This is conceptually equivalent to using toFixed but it should be much faster
	        var precision = Math.pow(10, this._flags.precision);
	        result.value = Math.round(result.value * precision) / precision;
	    }

	    result.errors = isNumber ? null : Errors.create('number.base', null, state, options);
	    return result;
	};


	internals.Number.prototype.min = internals.compare('min', function (value, limit) {

	    return value >= limit;
	});


	internals.Number.prototype.max = internals.compare('max', function (value, limit) {

	    return value <= limit;
	});


	internals.Number.prototype.greater = internals.compare('greater', function (value, limit) {

	    return value > limit;
	});


	internals.Number.prototype.less = internals.compare('less', function (value, limit) {

	    return value < limit;
	});


	internals.Number.prototype.multiple = function (base) {

	    Hoek.assert(Hoek.isInteger(base), 'multiple must be an integer');
	    Hoek.assert(base > 0, 'multiple must be greater than 0');

	    return this._test('multiple', base, function (value, state, options) {

	        if (value % base === 0) {
	            return null;
	        }

	        return Errors.create('number.multiple', { multiple: base, value: value }, state, options);
	    });
	};


	internals.Number.prototype.integer = function () {

	    return this._test('integer', undefined, function (value, state, options) {

	        return Hoek.isInteger(value) ? null : Errors.create('number.integer', { value: value }, state, options);
	    });
	};


	internals.Number.prototype.negative = function () {

	    return this._test('negative', undefined, function (value, state, options) {

	        if (value < 0) {
	            return null;
	        }

	        return Errors.create('number.negative', { value: value }, state, options);
	    });
	};


	internals.Number.prototype.positive = function () {

	    return this._test('positive', undefined, function (value, state, options) {

	        if (value > 0) {
	            return null;
	        }

	        return Errors.create('number.positive', { value: value }, state, options);
	    });
	};


	internals.precisionRx = /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/;


	internals.Number.prototype.precision = function (limit) {

	    Hoek.assert(Hoek.isInteger(limit), 'limit must be an integer');
	    Hoek.assert(!('precision' in this._flags), 'precision already set');

	    var obj = this._test('precision', limit, function (value, state, options){

	        var places = value.toString().match(internals.precisionRx);
	        var decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
	        if (decimals <= limit) {
	            return null;
	        }

	        return Errors.create('number.precision', { limit: limit, value: value }, state, options);
	    });

	    obj._flags.precision = limit;
	    return obj;
	};


	module.exports = new internals.Number();


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Any = __webpack_require__(186);
	var Errors = __webpack_require__(191);
	var Hoek = __webpack_require__(187);


	// Declare internals

	var internals = {};


	internals.Boolean = function () {

	    Any.call(this);
	    this._type = 'boolean';
	};

	Hoek.inherits(internals.Boolean, Any);


	internals.Boolean.prototype._base = function (value, state, options) {

	    var result = {
	        value: value
	    };

	    if (typeof value === 'string' &&
	        options.convert) {

	        var lower = value.toLowerCase();
	        result.value = (lower === 'true' || lower === 'yes' || lower === 'on' ? true
	                                                                              : (lower === 'false' || lower === 'no' || lower === 'off' ? false : value));
	    }

	    result.errors = (typeof result.value === 'boolean') ? null : Errors.create('boolean.base', null, state, options);
	    return result;
	};


	module.exports = new internals.Boolean();


/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Hoek = __webpack_require__(187);
	var Any = __webpack_require__(186);
	var Cast = __webpack_require__(193);
	var Ref = __webpack_require__(190);
	var Errors = __webpack_require__(191);


	// Declare internals

	var internals = {};


	internals.Alternatives = function () {

	    Any.call(this);
	    this._type = 'alternatives';
	    this._invalids.remove(null);

	    this._inner.matches = [];
	};

	Hoek.inherits(internals.Alternatives, Any);


	internals.Alternatives.prototype._base = function (value, state, options) {

	    var errors = [];
	    for (var i = 0, il = this._inner.matches.length; i < il; ++i) {
	        var item = this._inner.matches[i];
	        var schema = item.schema;
	        if (!schema) {
	            var failed = item.is._validate(item.ref(state.parent, options), null, options, state.parent).errors;
	            schema = failed ? item.otherwise : item.then;
	            if (!schema) {
	                continue;
	            }
	        }

	        var result = schema._validate(value, state, options);
	        if (!result.errors) {     // Found a valid match
	            return result;
	        }

	        errors = errors.concat(result.errors);
	    }

	    return { errors: errors.length ? errors : Errors.create('alternatives.base', null, state, options) };
	};


	internals.Alternatives.prototype.try = function (/* schemas */) {


	    var schemas = Hoek.flatten(Array.prototype.slice.call(arguments));
	    Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');

	    var obj = this.clone();

	    for (var i = 0, il = schemas.length; i < il; ++i) {
	        var cast = Cast.schema(schemas[i]);
	        if (cast._refs.length) {
	            obj._refs = obj._refs.concat(cast._refs);
	        }
	        obj._inner.matches.push({ schema: cast });
	    }

	    return obj;
	};


	internals.Alternatives.prototype.when = function (ref, options) {

	    Hoek.assert(Ref.isRef(ref) || typeof ref === 'string', 'Invalid reference:', ref);
	    Hoek.assert(options, 'Missing options');
	    Hoek.assert(typeof options === 'object', 'Invalid options');
	    Hoek.assert(options.hasOwnProperty('is'), 'Missing "is" directive');
	    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of "then" or "otherwise"');

	    var obj = this.clone();
	    var is = Cast.schema(options.is);

	    if (options.is === null || !options.is.isJoi) {

	        // Only apply required if this wasn't already a schema, we'll suppose people know what they're doing
	        is = is.required();
	    }

	    var item = {
	        ref: Cast.ref(ref),
	        is: is,
	        then: options.then !== undefined ? Cast.schema(options.then) : undefined,
	        otherwise: options.otherwise !== undefined ? Cast.schema(options.otherwise) : undefined
	    };

	    Ref.push(obj._refs, item.ref);
	    obj._refs = obj._refs.concat(item.is._refs);

	    if (item.then && item.then._refs) {
	        obj._refs = obj._refs.concat(item.then._refs);
	    }

	    if (item.otherwise && item.otherwise._refs) {
	        obj._refs = obj._refs.concat(item.otherwise._refs);
	    }

	    obj._inner.matches.push(item);

	    return obj;
	};


	internals.Alternatives.prototype.describe = function () {

	    var description = Any.prototype.describe.call(this);
	    var alternatives = [];
	    for (var i = 0, il = this._inner.matches.length; i < il; ++i) {
	        var item = this._inner.matches[i];
	        if (item.schema) {

	            // try()

	            alternatives.push(item.schema.describe());
	        }
	        else {

	            // when()

	            var when = {
	                ref: item.ref.toString(),
	                is: item.is.describe()
	            };

	            if (item.then) {
	                when.then = item.then.describe();
	            }

	            if (item.otherwise) {
	                when.otherwise = item.otherwise.describe();
	            }

	            alternatives.push(when);
	        }
	    }

	    description.alternatives = alternatives;
	    return description;
	};


	module.exports = new internals.Alternatives();


/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Hoek = __webpack_require__(187);
	var Topo = __webpack_require__(313);
	var Any = __webpack_require__(186);
	var Cast = __webpack_require__(193);
	var Errors = __webpack_require__(191);


	// Declare internals

	var internals = {};


	internals.Object = function () {

	    Any.call(this);
	    this._type = 'object';
	    this._inner.children = null;
	    this._inner.renames = [];
	    this._inner.dependencies = [];
	    this._inner.patterns = [];
	};

	Hoek.inherits(internals.Object, Any);


	internals.Object.prototype._base = function (value, state, options) {

	    var item, key, localState, result;
	    var target = value;
	    var errors = [];
	    var finish = function () {

	        return {
	            value: target,
	            errors: errors.length ? errors : null
	        };
	    };

	    if (typeof value === 'string' &&
	        options.convert) {

	        try {
	            value = JSON.parse(value);
	        }
	        catch (parseErr) { }
	    }

	    var type = this._flags.func ? 'function' : 'object';
	    if (!value ||
	        typeof value !== type ||
	        Array.isArray(value)) {

	        errors.push(Errors.create(type + '.base', null, state, options));
	        return finish();
	    }

	    // Skip if there are no other rules to test

	    if (!this._inner.renames.length &&
	        !this._inner.dependencies.length &&
	        !this._inner.children &&                    // null allows any keys
	        !this._inner.patterns.length) {

	        target = value;
	        return finish();
	    }

	    // Ensure target is a local copy (parsed) or shallow copy

	    if (target === value) {
	        if (type === 'object') {
	            target = Object.create(Object.getPrototypeOf(value));
	        }
	        else {
	            target = function () {

	                return value.apply(this, arguments);
	            };

	            target.prototype = Hoek.clone(value.prototype);
	        }

	        var valueKeys = Object.keys(value);
	        for (var t = 0, tl = valueKeys.length; t < tl; ++t) {
	            target[valueKeys[t]] = value[valueKeys[t]];
	        }
	    }
	    else {
	        target = value;
	    }

	    // Rename keys

	    var renamed = {};
	    for (var r = 0, rl = this._inner.renames.length; r < rl; ++r) {
	        item = this._inner.renames[r];

	        if (item.options.ignoreUndefined && target[item.from] === undefined) {
	            continue;
	        }

	        if (!item.options.multiple &&
	            renamed[item.to]) {

	            errors.push(Errors.create('object.rename.multiple', { from: item.from, to: item.to }, state, options));
	            if (options.abortEarly) {
	                return finish();
	            }
	        }

	        if (Object.prototype.hasOwnProperty.call(target, item.to) &&
	            !item.options.override &&
	            !renamed[item.to]) {

	            errors.push(Errors.create('object.rename.override', { from: item.from, to: item.to }, state, options));
	            if (options.abortEarly) {
	                return finish();
	            }
	        }

	        if (target[item.from] === undefined) {
	            delete target[item.to];
	        }
	        else {
	            target[item.to] = target[item.from];
	        }

	        renamed[item.to] = true;

	        if (!item.options.alias) {
	            delete target[item.from];
	        }
	    }

	    // Validate schema

	    if (!this._inner.children &&            // null allows any keys
	        !this._inner.patterns.length &&
	        !this._inner.dependencies.length) {

	        return finish();
	    }

	    var unprocessed = Hoek.mapToObject(Object.keys(target));

	    if (this._inner.children) {
	        for (var i = 0, il = this._inner.children.length; i < il; ++i) {
	            var child = this._inner.children[i];
	            key = child.key;
	            item = target[key];

	            delete unprocessed[key];

	            localState = { key: key, path: (state.path || '') + (state.path && key ? '.' : '') + key, parent: target, reference: state.reference };
	            result = child.schema._validate(item, localState, options);
	            if (result.errors) {
	                errors.push(Errors.create('object.child', { key: key, reason: result.errors }, localState, options));

	                if (options.abortEarly) {
	                    return finish();
	                }
	            }

	            if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {
	                delete target[key];
	            }
	            else if (result.value !== undefined) {
	                target[key] = result.value;
	            }
	        }
	    }

	    // Unknown keys

	    var unprocessedKeys = Object.keys(unprocessed);
	    if (unprocessedKeys.length &&
	        this._inner.patterns.length) {

	        for (i = 0, il = unprocessedKeys.length; i < il; ++i) {
	            key = unprocessedKeys[i];

	            for (var p = 0, pl = this._inner.patterns.length; p < pl; ++p) {
	                var pattern = this._inner.patterns[p];

	                if (pattern.regex.test(key)) {
	                    delete unprocessed[key];

	                    item = target[key];
	                    localState = { key: key, path: (state.path ? state.path + '.' : '') + key, parent: target, reference: state.reference };
	                    result = pattern.rule._validate(item, localState, options);
	                    if (result.errors) {
	                        errors.push(Errors.create('object.child', { key: key, reason: result.errors }, localState, options));

	                        if (options.abortEarly) {
	                            return finish();
	                        }
	                    }

	                    if (result.value !== undefined) {
	                        target[key] = result.value;
	                    }
	                }
	            }
	        }

	        unprocessedKeys = Object.keys(unprocessed);
	    }

	    if ((this._inner.children || this._inner.patterns.length) && unprocessedKeys.length) {
	        if (options.stripUnknown ||
	            options.skipFunctions) {

	            for (var k = 0, kl = unprocessedKeys.length; k < kl; ++k) {
	                key = unprocessedKeys[k];

	                if (options.stripUnknown) {
	                    delete target[key];
	                    delete unprocessed[key];
	                }
	                else if (typeof target[key] === 'function') {
	                    delete unprocessed[key];
	                }
	            }

	            unprocessedKeys = Object.keys(unprocessed);
	        }

	        if (unprocessedKeys.length &&
	            (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {

	            for (var e = 0, el = unprocessedKeys.length; e < el; ++e) {
	                errors.push(Errors.create('object.allowUnknown', null, { key: unprocessedKeys[e], path: state.path + (state.path ? '.' : '') + unprocessedKeys[e] }, options));
	            }
	        }
	    }

	    // Validate dependencies

	    for (var d = 0, dl = this._inner.dependencies.length; d < dl; ++d) {
	        var dep = this._inner.dependencies[d];
	        var err = internals[dep.type](dep.key !== null && value[dep.key], dep.peers, target, { key: dep.key, path: (state.path || '') + (dep.key ? '.' + dep.key : '') }, options);
	        if (err) {
	            errors.push(err);
	            if (options.abortEarly) {
	                return finish();
	            }
	        }
	    }

	    return finish();
	};


	internals.Object.prototype._func = function () {

	    var obj = this.clone();
	    obj._flags.func = true;
	    return obj;
	};


	internals.Object.prototype.keys = function (schema) {

	    Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');
	    Hoek.assert(!schema || !schema.isJoi, 'Object schema cannot be a joi schema');

	    var obj = this.clone();

	    if (!schema) {
	        obj._inner.children = null;
	        return obj;
	    }

	    var children = Object.keys(schema);

	    if (!children.length) {
	        obj._inner.children = [];
	        return obj;
	    }

	    var topo = new Topo();
	    var child;
	    if (obj._inner.children) {
	        for (var i = 0, il = obj._inner.children.length; i < il; ++i) {
	            child = obj._inner.children[i];

	            // Only add the key if we are not going to replace it later
	            if (children.indexOf(child.key) === -1) {
	                topo.add(child, { after: child._refs, group: child.key });
	            }
	        }
	    }

	    for (var c = 0, cl = children.length; c < cl; ++c) {
	        var key = children[c];
	        child = schema[key];
	        try {
	            var cast = Cast.schema(child);
	            topo.add({ key: key, schema: cast }, { after: cast._refs, group: key });
	        }
	        catch (castErr) {
	            if (castErr.hasOwnProperty('path')) {
	                castErr.path = key + '.' + castErr.path;
	            }
	            else {
	                castErr.path = key;
	            }
	            throw castErr;
	        }
	    }

	    obj._inner.children = topo.nodes;

	    return obj;
	};


	internals.Object.prototype.unknown = function (allow) {

	    var obj = this.clone();
	    obj._flags.allowUnknown = (allow !== false);
	    return obj;
	};


	internals.Object.prototype.length = function (limit) {

	    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

	    return this._test('length', limit, function (value, state, options) {

	        if (Object.keys(value).length === limit) {
	            return null;
	        }

	        return Errors.create('object.length', { limit: limit }, state, options);
	    });
	};


	internals.Object.prototype.min = function (limit) {

	    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

	    return this._test('min', limit, function (value, state, options) {

	        if (Object.keys(value).length >= limit) {
	            return null;
	        }

	        return Errors.create('object.min', { limit: limit }, state, options);
	    });
	};


	internals.Object.prototype.max = function (limit) {

	    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

	    return this._test('max', limit, function (value, state, options) {

	        if (Object.keys(value).length <= limit) {
	            return null;
	        }

	        return Errors.create('object.max', { limit: limit }, state, options);
	    });
	};


	internals.Object.prototype.pattern = function (pattern, schema) {

	    Hoek.assert(pattern instanceof RegExp, 'Invalid regular expression');
	    Hoek.assert(schema !== undefined, 'Invalid rule');

	    pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags

	    try {
	        schema = Cast.schema(schema);
	    }
	    catch (castErr) {
	        if (castErr.hasOwnProperty('path')) {
	            castErr.message += '(' + castErr.path + ')';
	        }

	        throw castErr;
	    }


	    var obj = this.clone();
	    obj._inner.patterns.push({ regex: pattern, rule: schema });
	    return obj;
	};


	internals.Object.prototype.with = function (key, peers) {

	    return this._dependency('with', key, peers);
	};


	internals.Object.prototype.without = function (key, peers) {

	    return this._dependency('without', key, peers);
	};


	internals.Object.prototype.xor = function () {

	    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
	    return this._dependency('xor', null, peers);
	};


	internals.Object.prototype.or = function () {

	    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
	    return this._dependency('or', null, peers);
	};


	internals.Object.prototype.and = function () {

	    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
	    return this._dependency('and', null, peers);
	};


	internals.Object.prototype.nand = function () {

	    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
	    return this._dependency('nand', null, peers);
	};


	internals.Object.prototype.requiredKeys = function (children) {

	    children = Hoek.flatten(Array.prototype.slice.call(arguments));
	    return this.applyFunctionToChildren(children, 'required');
	};


	internals.Object.prototype.optionalKeys = function (children) {

	    children = Hoek.flatten(Array.prototype.slice.call(arguments));
	    return this.applyFunctionToChildren(children, 'optional');
	};


	internals.renameDefaults = {
	    alias: false,                   // Keep old value in place
	    multiple: false,                // Allow renaming multiple keys into the same target
	    override: false                 // Overrides an existing key
	};


	internals.Object.prototype.rename = function (from, to, options) {

	    Hoek.assert(typeof from === 'string', 'Rename missing the from argument');
	    Hoek.assert(typeof to === 'string', 'Rename missing the to argument');
	    Hoek.assert(to !== from, 'Cannot rename key to same name:', from);

	    for (var i = 0, il = this._inner.renames.length; i < il; ++i) {
	        Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');
	    }

	    var obj = this.clone();

	    obj._inner.renames.push({
	        from: from,
	        to: to,
	        options: Hoek.applyToDefaults(internals.renameDefaults, options || {})
	    });

	    return obj;
	};


	internals.groupChildren = function (children) {

	    children.sort();

	    var grouped = {};

	    for (var c = 0, lc = children.length; c < lc; c++) {
	        var child = children[c];
	        Hoek.assert(typeof child === 'string', 'children must be strings');
	        var group = child.split('.')[0];
	        var childGroup = grouped[group] = (grouped[group] || []);
	        childGroup.push(child.substring(group.length + 1));
	    }

	    return grouped;
	};


	internals.Object.prototype.applyFunctionToChildren = function (children, fn, args, root) {

	    children = [].concat(children);
	    Hoek.assert(children.length > 0, 'expected at least one children');

	    var groupedChildren = internals.groupChildren(children);
	    var obj;

	    if ('' in groupedChildren) {
	        obj = this[fn].apply(this, args);
	        delete groupedChildren[''];
	    }
	    else {
	        obj = this.clone();
	    }

	    if (obj._inner.children) {
	        root = root ? (root + '.') : '';

	        for (var i = 0, il = obj._inner.children.length; i < il; ++i) {
	            var child = obj._inner.children[i];
	            var group = groupedChildren[child.key];

	            if (group) {
	                obj._inner.children[i] = {
	                    key: child.key,
	                    _refs: child._refs,
	                    schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)
	                };

	                delete groupedChildren[child.key];
	            }
	        }
	    }

	    var remaining = Object.keys(groupedChildren);
	    Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));

	    return obj;
	};


	internals.Object.prototype._dependency = function (type, key, peers) {

	    peers = [].concat(peers);
	    for (var i = 0, li = peers.length; i < li; i++) {
	        Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');
	    }

	    var obj = this.clone();
	    obj._inner.dependencies.push({ type: type, key: key, peers: peers });
	    return obj;
	};


	internals.with = function (value, peers, parent, state, options) {

	    if (value === undefined) {
	        return null;
	    }

	    for (var i = 0, il = peers.length; i < il; ++i) {
	        var peer = peers[i];
	        if (!Object.prototype.hasOwnProperty.call(parent, peer) ||
	            parent[peer] === undefined) {

	            return Errors.create('object.with', { peer: peer }, state, options);
	        }
	    }

	    return null;
	};


	internals.without = function (value, peers, parent, state, options) {

	    if (value === undefined) {
	        return null;
	    }

	    for (var i = 0, il = peers.length; i < il; ++i) {
	        var peer = peers[i];
	        if (Object.prototype.hasOwnProperty.call(parent, peer) &&
	            parent[peer] !== undefined) {

	            return Errors.create('object.without', { peer: peer }, state, options);
	        }
	    }

	    return null;
	};


	internals.xor = function (value, peers, parent, state, options) {

	    var present = [];
	    for (var i = 0, il = peers.length; i < il; ++i) {
	        var peer = peers[i];
	        if (Object.prototype.hasOwnProperty.call(parent, peer) &&
	            parent[peer] !== undefined) {

	            present.push(peer);
	        }
	    }

	    if (present.length === 1) {
	        return null;
	    }

	    if (present.length === 0) {
	        return Errors.create('object.missing', { peers: peers }, state, options);
	    }

	    return Errors.create('object.xor', { peers: peers }, state, options);
	};


	internals.or = function (value, peers, parent, state, options) {

	    for (var i = 0, il = peers.length; i < il; ++i) {
	        var peer = peers[i];
	        if (Object.prototype.hasOwnProperty.call(parent, peer) &&
	            parent[peer] !== undefined) {
	            return null;
	        }
	    }

	    return Errors.create('object.missing', { peers: peers }, state, options);
	};


	internals.and = function (value, peers, parent, state, options) {

	    var missing = [];
	    var present = [];
	    var count = peers.length;
	    for (var i = 0; i < count; ++i) {
	        var peer = peers[i];
	        if (!Object.prototype.hasOwnProperty.call(parent, peer) ||
	            parent[peer] === undefined) {

	            missing.push(peer);
	        }
	        else {
	            present.push(peer);
	        }
	    }

	    var aon = (missing.length === count || present.length === count);
	    return !aon ? Errors.create('object.and', { present: present, missing: missing }, state, options) : null;
	};


	internals.nand = function (value, peers, parent, state, options) {

	    var present = [];
	    for (var i = 0, il = peers.length; i < il; ++i) {
	        var peer = peers[i];
	        if (Object.prototype.hasOwnProperty.call(parent, peer) &&
	            parent[peer] !== undefined) {

	            present.push(peer);
	        }
	    }

	    var values = Hoek.clone(peers);
	    var main = values.splice(0, 1)[0];
	    var allPresent = (present.length === peers.length);
	    return allPresent ? Errors.create('object.nand', { main: main, peers: values }, state, options) : null;
	};


	internals.Object.prototype.describe = function (shallow) {

	    var description = Any.prototype.describe.call(this);

	    if (this._inner.children &&
	        !shallow) {

	        description.children = {};
	        for (var i = 0, il = this._inner.children.length; i < il; ++i) {
	            var child = this._inner.children[i];
	            description.children[child.key] = child.schema.describe();
	        }
	    }

	    if (this._inner.dependencies.length) {
	        description.dependencies = Hoek.clone(this._inner.dependencies);
	    }

	    if (this._inner.patterns.length) {
	        description.patterns = [];

	        for (var p = 0, pl = this._inner.patterns.length; p < pl; ++p) {
	            var pattern = this._inner.patterns[p];
	            description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });
	        }
	    }

	    return description;
	};


	internals.Object.prototype.assert = function (ref, schema, message) {

	    ref = Cast.ref(ref);
	    Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');
	    message = message || 'pass the assertion test';

	    var cast;
	    try {
	        cast = Cast.schema(schema);
	    }
	    catch (castErr) {
	        if (castErr.hasOwnProperty('path')) {
	            castErr.message += '(' + castErr.path + ')';
	        }

	        throw castErr;
	    }

	    var key = ref.path[ref.path.length - 1];
	    var path = ref.path.join('.');

	    return this._test('assert', { cast: cast, ref: ref }, function (value, state, options) {

	        var result = cast._validate(ref(value), null, options, value);
	        if (!result.errors) {
	            return null;
	        }

	        var localState = Hoek.merge({}, state);
	        localState.key = key;
	        localState.path = path;
	        return Errors.create('object.assert', { ref: localState.path, message: message }, localState, options);
	    });
	};


	internals.Object.prototype.type = function (constructor, name) {

	    Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');
	    name = name || constructor.name;

	    return this._test('type', name, function (value, state, options) {

	        if (value instanceof constructor) {
	            return null;
	        }

	        return Errors.create('object.type', { type: name }, state, options);
	    });
	};


	module.exports = new internals.Object();


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Hoek = __webpack_require__(187);


	// Declare internals

	var internals = {};


	exports = module.exports = internals.Topo = function () {

	    this._items = [];
	    this.nodes = [];
	};


	internals.Topo.prototype.add = function (nodes, options) {

	    var self = this;

	    options = options || {};

	    // Validate rules

	    var before = [].concat(options.before || []);
	    var after = [].concat(options.after || []);
	    var group = options.group || '?';
	    var sort = options.sort || 0;                   // Used for merging only

	    Hoek.assert(before.indexOf(group) === -1, 'Item cannot come before itself:', group);
	    Hoek.assert(before.indexOf('?') === -1, 'Item cannot come before unassociated items');
	    Hoek.assert(after.indexOf(group) === -1, 'Item cannot come after itself:', group);
	    Hoek.assert(after.indexOf('?') === -1, 'Item cannot come after unassociated items');

	    ([].concat(nodes)).forEach(function (node, i) {

	        var item = {
	            seq: self._items.length,
	            sort: sort,
	            before: before,
	            after: after,
	            group: group,
	            node: node
	        };

	        self._items.push(item);
	    });

	    // Insert event

	    var error = this._sort();
	    Hoek.assert(!error, 'item', (group !== '?' ? 'added into group ' + group : ''), 'created a dependencies error');

	    return this.nodes;
	};


	internals.Topo.prototype.merge = function (others) {

	    others = [].concat(others);
	    for (var o = 0, ol = others.length; o < ol; ++o) {
	        var other = others[o];
	        if (other) {
	            for (var i = 0, il = other._items.length; i < il; ++i) {
	                var item = Hoek.shallow(other._items[i]);
	                this._items.push(item);
	            }
	        }
	    }

	    // Sort items

	    this._items.sort(internals.mergeSort);
	    for (i = 0, il = this._items.length; i < il; ++i) {
	        this._items[i].seq = i;
	    }

	    var error = this._sort();
	    Hoek.assert(!error, 'merge created a dependencies error');

	    return this.nodes;
	};


	internals.mergeSort = function (a, b) {

	    return a.sort === b.sort ? 0 : (a.sort < b.sort ? -1 : 1);
	};


	internals.Topo.prototype._sort = function () {

	    // Construct graph

	    var groups = {};
	    var graph = {};
	    var graphAfters = {};

	    for (var i = 0, il = this._items.length; i < il; ++i) {
	        var item = this._items[i];
	        var seq = item.seq;                         // Unique across all items
	        var group = item.group;

	        // Determine Groups

	        groups[group] = groups[group] || [];
	        groups[group].push(seq);

	        // Build intermediary graph using 'before'

	        graph[seq] = item.before;

	        // Build second intermediary graph with 'after'

	        var after = item.after;
	        for (var j = 0, jl = after.length; j < jl; ++j) {
	            graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);
	        }
	    }

	    // Expand intermediary graph

	    var graphNodes = Object.keys(graph);
	    for (i = 0, il = graphNodes.length; i < il; ++i) {
	        var node = graphNodes[i];
	        var expandedGroups = [];

	        var graphNodeItems = Object.keys(graph[node]);
	        for (j = 0, jl = graphNodeItems.length; j < jl; ++j) {
	            group = graph[node][graphNodeItems[j]];
	            groups[group] = groups[group] || [];

	            for (var k = 0, kl = groups[group].length; k < kl; ++k) {

	                expandedGroups.push(groups[group][k]);
	            }
	        }
	        graph[node] = expandedGroups;
	    }

	    // Merge intermediary graph using graphAfters into final graph

	    var afterNodes = Object.keys(graphAfters);
	    for (i = 0, il = afterNodes.length; i < il; ++i) {
	        group = afterNodes[i];

	        if (groups[group]) {
	            for (j = 0, jl = groups[group].length; j < jl; ++j) {
	                node = groups[group][j];
	                graph[node] = graph[node].concat(graphAfters[group]);
	            }
	        }
	    }

	    // Compile ancestors

	    var children;
	    var ancestors = {};
	    graphNodes = Object.keys(graph);
	    for (i = 0, il = graphNodes.length; i < il; ++i) {
	        node = graphNodes[i];
	        children = graph[node];

	        for (j = 0, jl = children.length; j < jl; ++j) {
	            ancestors[children[j]] = (ancestors[children[j]] || []).concat(node);
	        }
	    }

	    // Topo sort

	    var visited = {};
	    var sorted = [];

	    for (i = 0, il = this._items.length; i < il; ++i) {
	        var next = i;

	        if (ancestors[i]) {
	            next = null;
	            for (j = 0, jl = this._items.length; j < jl; ++j) {
	                if (visited[j] === true) {
	                    continue;
	                }

	                if (!ancestors[j]) {
	                    ancestors[j] = [];
	                }

	                var shouldSeeCount = ancestors[j].length;
	                var seenCount = 0;
	                for (var l = 0, ll = shouldSeeCount; l < ll; ++l) {
	                    if (sorted.indexOf(ancestors[j][l]) >= 0) {
	                        ++seenCount;
	                    }
	                }

	                if (seenCount === shouldSeeCount) {
	                    next = j;
	                    break;
	                }
	            }
	        }

	        if (next !== null) {
	            next = next.toString();         // Normalize to string TODO: replace with seq
	            visited[next] = true;
	            sorted.push(next);
	        }
	    }

	    if (sorted.length !== this._items.length) {
	        return new Error('Invalid dependencies');
	    }

	    var seqIndex = {};
	    for (i = 0, il = this._items.length; i < il; ++i) {

	        item = this._items[i];
	        seqIndex[item.seq] = item;
	    }

	    var sortedNodes = [];
	    this._items = sorted.map(function (value) {

	        var sortedItem = seqIndex[value];
	        sortedNodes.push(sortedItem.node);
	        return sortedItem;
	    });

	    this.nodes = sortedNodes;
	};


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Any = __webpack_require__(186);
	var Cast = __webpack_require__(193);
	var Errors = __webpack_require__(191);
	var Hoek = __webpack_require__(187);


	// Declare internals

	var internals = {};


	internals.fastSplice = function (arr, i) {

	    var il = arr.length;
	    var pos = i;

	    while (pos < il) {
	        arr[pos++] = arr[pos];
	    }

	    --arr.length;
	};


	internals.Array = function () {

	    Any.call(this);
	    this._type = 'array';
	    this._inner.items = [];
	    this._inner.ordereds = [];
	    this._inner.inclusions = [];
	    this._inner.exclusions = [];
	    this._inner.requireds = [];
	    this._flags.sparse = false;
	};

	Hoek.inherits(internals.Array, Any);


	internals.Array.prototype._base = function (value, state, options) {

	    var result = {
	        value: value
	    };

	    if (typeof value === 'string' &&
	        options.convert) {

	        try {
	            var converted = JSON.parse(value);
	            if (Array.isArray(converted)) {
	                result.value = converted;
	            }
	        }
	        catch (e) { }
	    }

	    var isArray = Array.isArray(result.value);
	    var wasArray = isArray;
	    if (options.convert && this._flags.single && !isArray) {
	        result.value = [result.value];
	        isArray = true;
	    }

	    if (!isArray) {
	        result.errors = Errors.create('array.base', null, state, options);
	        return result;
	    }

	    if (this._inner.inclusions.length ||
	        this._inner.exclusions.length ||
	        !this._flags.sparse) {

	        // Clone the array so that we don't modify the original
	        if (wasArray) {
	            result.value = result.value.slice(0);
	        }

	        result.errors = internals.checkItems.call(this, result.value, wasArray, state, options);

	        if (result.errors && wasArray && options.convert && this._flags.single) {

	            // Attempt a 2nd pass by putting the array inside one.
	            var previousErrors = result.errors;

	            result.value = [result.value];
	            result.errors = internals.checkItems.call(this, result.value, wasArray, state, options);

	            if (result.errors) {

	                // Restore previous errors and value since this didn't validate either.
	                result.errors = previousErrors;
	                result.value = result.value[0];
	            }
	        }
	    }

	    return result;
	};


	internals.checkItems = function (items, wasArray, state, options) {

	    var errors = [];
	    var errored;

	    var requireds = this._inner.requireds.slice();
	    var ordereds = this._inner.ordereds.slice();
	    var inclusions = this._inner.inclusions.concat(requireds);

	    for (var v = 0, vl = items.length; v < vl; ++v) {
	        errored = false;
	        var item = items[v];
	        var isValid = false;
	        var localState = { key: v, path: (state.path ? state.path + '.' : '') + v, parent: items, reference: state.reference };
	        var res;

	        // Sparse

	        if (!this._flags.sparse && item === undefined) {
	            errors.push(Errors.create('array.sparse', null, { key: state.key, path: localState.path }, options));

	            if (options.abortEarly) {
	                return errors;
	            }

	            continue;
	        }

	        // Exclusions

	        for (var i = 0, il = this._inner.exclusions.length; i < il; ++i) {
	            res = this._inner.exclusions[i]._validate(item, localState, {});                // Not passing options to use defaults

	            if (!res.errors) {
	                errors.push(Errors.create(wasArray ? 'array.excludes' : 'array.excludesSingle', { pos: v, value: item }, { key: state.key, path: localState.path }, options));
	                errored = true;

	                if (options.abortEarly) {
	                    return errors;
	                }

	                break;
	            }
	        }

	        if (errored) {
	            continue;
	        }

	        // Ordered
	        if (this._inner.ordereds.length) {
	            if (ordereds.length > 0) {
	                var ordered = ordereds.shift();
	                res = ordered._validate(item, localState, options);
	                if (!res.errors) {
	                    if (ordered._flags.strip) {
	                        internals.fastSplice(items, v);
	                        --v;
	                        --vl;
	                    }
	                    else {
	                        items[v] = res.value;
	                    }
	                }
	                else {
	                    errors.push(Errors.create('array.ordered', { pos: v, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));
	                    if (options.abortEarly) {
	                        return errors;
	                    }
	                }
	                continue;
	            }
	            else if (!this._inner.items.length) {
	                errors.push(Errors.create('array.orderedLength', { pos: v, limit: this._inner.ordereds.length }, { key: state.key, path: localState.path }, options));
	                if (options.abortEarly) {
	                    return errors;
	                }
	                continue;
	            }
	        }

	        // Requireds

	        var requiredChecks = [];
	        for (i = 0, il = requireds.length; i < il; ++i) {
	            res = requiredChecks[i] = requireds[i]._validate(item, localState, options);
	            if (!res.errors) {
	                items[v] = res.value;
	                isValid = true;
	                internals.fastSplice(requireds, i);
	                --i;
	                --il;
	                break;
	            }
	        }

	        if (isValid) {
	            continue;
	        }

	        // Inclusions

	        for (i = 0, il = inclusions.length; i < il; ++i) {
	            var inclusion = inclusions[i];

	            // Avoid re-running requireds that already didn't match in the previous loop
	            var previousCheck = requireds.indexOf(inclusion);
	            if (previousCheck !== -1) {
	                res = requiredChecks[previousCheck];
	            }
	            else {
	                res = inclusion._validate(item, localState, options);

	                if (!res.errors) {
	                    if (inclusion._flags.strip) {
	                        internals.fastSplice(items, v);
	                        --v;
	                        --vl;
	                    }
	                    else {
	                        items[v] = res.value;
	                    }
	                    isValid = true;
	                    break;
	                }
	            }

	            // Return the actual error if only one inclusion defined
	            if (il === 1) {
	                if (options.stripUnknown) {
	                    internals.fastSplice(items, v);
	                    --v;
	                    --vl;
	                    isValid = true;
	                    break;
	                }

	                errors.push(Errors.create(wasArray ? 'array.includesOne' : 'array.includesOneSingle', { pos: v, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));
	                errored = true;

	                if (options.abortEarly) {
	                    return errors;
	                }

	                break;
	            }
	        }

	        if (errored) {
	            continue;
	        }

	        if (this._inner.inclusions.length && !isValid) {
	            if (options.stripUnknown) {
	                internals.fastSplice(items, v);
	                --v;
	                --vl;
	                continue;
	            }

	            errors.push(Errors.create(wasArray ? 'array.includes' : 'array.includesSingle', { pos: v, value: item }, { key: state.key, path: localState.path }, options));

	            if (options.abortEarly) {
	                return errors;
	            }
	        }
	    }

	    if (requireds.length) {
	        internals.fillMissedErrors(errors, requireds, state, options);
	    }

	    if (ordereds.length) {
	        internals.fillOrderedErrors(errors, ordereds, state, options);
	    }

	    return errors.length ? errors : null;
	};

	internals.fillMissedErrors = function (errors, requireds, state, options) {

	    var knownMisses = [];
	    var unknownMisses = 0;
	    for (var i = 0, il = requireds.length; i < il; ++i) {
	        var label = Hoek.reach(requireds[i], '_settings.language.label');
	        if (label) {
	            knownMisses.push(label);
	        }
	        else {
	            ++unknownMisses;
	        }
	    }

	    if (knownMisses.length) {
	        if (unknownMisses) {
	            errors.push(Errors.create('array.includesRequiredBoth', { knownMisses: knownMisses, unknownMisses: unknownMisses }, { key: state.key, path: state.patk }, options));
	        }
	        else {
	            errors.push(Errors.create('array.includesRequiredKnowns', { knownMisses: knownMisses }, { key: state.key, path: state.path }, options));
	        }
	    }
	    else {
	        errors.push(Errors.create('array.includesRequiredUnknowns', { unknownMisses: unknownMisses }, { key: state.key, path: state.path }, options));
	    }
	};

	internals.fillOrderedErrors = function (errors, ordereds, state, options) {

	    var requiredOrdereds = [];

	    for (var i = 0, il = ordereds.length; i < il; ++i) {
	        var presence = Hoek.reach(ordereds[i], '_flags.presence');
	        if (presence === 'required') {
	            requiredOrdereds.push(ordereds[i]);
	        }
	    }

	    if (requiredOrdereds.length) {
	        internals.fillMissedErrors(errors, requiredOrdereds, state, options);
	    }
	};

	internals.Array.prototype.describe = function () {

	    var description = Any.prototype.describe.call(this);

	    if (this._inner.ordereds.length) {
	        description.orderedItems = [];

	        for (var o = 0, ol = this._inner.ordereds.length; o < ol; ++o) {
	            description.orderedItems.push(this._inner.ordereds[o].describe());
	        }
	    }

	    if (this._inner.items.length) {
	        description.items = [];

	        for (var i = 0, il = this._inner.items.length; i < il; ++i) {
	            description.items.push(this._inner.items[i].describe());
	        }
	    }

	    return description;
	};


	internals.Array.prototype.items = function () {

	    var obj = this.clone();

	    Hoek.flatten(Array.prototype.slice.call(arguments)).forEach(function (type, index) {

	        try {
	            type = Cast.schema(type);
	        }
	        catch (castErr) {
	            if (castErr.hasOwnProperty('path')) {
	                castErr.path = index + '.' + castErr.path;
	            }
	            else {
	                castErr.path = index;
	            }
	            castErr.message += '(' + castErr.path + ')';
	            throw castErr;
	        }

	        obj._inner.items.push(type);

	        if (type._flags.presence === 'required') {
	            obj._inner.requireds.push(type);
	        }
	        else if (type._flags.presence === 'forbidden') {
	            obj._inner.exclusions.push(type.optional());
	        }
	        else {
	            obj._inner.inclusions.push(type);
	        }
	    });

	    return obj;
	};


	internals.Array.prototype.ordered = function () {

	    var obj = this.clone();

	    Hoek.flatten(Array.prototype.slice.call(arguments)).forEach(function (type, index) {

	        try {
	            type = Cast.schema(type);
	        }
	        catch (castErr) {
	            if (castErr.hasOwnProperty('path')) {
	                castErr.path = index + '.' + castErr.path;
	            }
	            else {
	                castErr.path = index;
	            }
	            castErr.message += '(' + castErr.path + ')';
	            throw castErr;
	        }
	        obj._inner.ordereds.push(type);
	    });

	    return obj;
	};


	internals.Array.prototype.min = function (limit) {

	    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

	    return this._test('min', limit, function (value, state, options) {

	        if (value.length >= limit) {
	            return null;
	        }

	        return Errors.create('array.min', { limit: limit, value: value }, state, options);
	    });
	};


	internals.Array.prototype.max = function (limit) {

	    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

	    return this._test('max', limit, function (value, state, options) {

	        if (value.length <= limit) {
	            return null;
	        }

	        return Errors.create('array.max', { limit: limit, value: value }, state, options);
	    });
	};


	internals.Array.prototype.length = function (limit) {

	    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

	    return this._test('length', limit, function (value, state, options) {

	        if (value.length === limit) {
	            return null;
	        }

	        return Errors.create('array.length', { limit: limit, value: value }, state, options);
	    });
	};


	internals.Array.prototype.unique = function () {

	    return this._test('unique', undefined, function (value, state, options) {

	        var found = {
	            string: {},
	            number: {},
	            undefined: {},
	            boolean: {},
	            object: [],
	            function: []
	        };

	        for (var i = 0, il = value.length; i < il; ++i) {
	            var item = value[i];
	            var type = typeof item;
	            var records = found[type];

	            // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.
	            // I still want to keep the test for future js versions with new types (eg. Symbol).
	            if (/* $lab:coverage:off$ */ records /* $lab:coverage:on$ */) {
	                if (Array.isArray(records)) {
	                    for (var r = 0, rl = records.length; r < rl; ++r) {
	                        if (Hoek.deepEqual(records[r], item)) {
	                            return Errors.create('array.unique', { pos: i, value: item }, state, options);
	                        }
	                    }

	                    records.push(item);
	                }
	                else {
	                    if (records[item]) {
	                        return Errors.create('array.unique', { pos: i, value: item }, state, options);
	                    }

	                    records[item] = true;
	                }
	            }
	        }
	    });
	};


	internals.Array.prototype.sparse = function (enabled) {

	    var obj = this.clone();
	    obj._flags.sparse = enabled === undefined ? true : !!enabled;
	    return obj;
	};


	internals.Array.prototype.single = function (enabled) {

	    var obj = this.clone();
	    obj._flags.single = enabled === undefined ? true : !!enabled;
	    return obj;
	};


	module.exports = new internals.Array();


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Any = __webpack_require__(186);
	var Errors = __webpack_require__(191);
	var Hoek = __webpack_require__(187);


	// Declare internals

	var internals = {};


	internals.Binary = function () {

	    Any.call(this);
	    this._type = 'binary';
	};

	Hoek.inherits(internals.Binary, Any);


	internals.Binary.prototype._base = function (value, state, options) {

	    var result = {
	        value: value
	    };

	    if (typeof value === 'string' &&
	        options.convert) {

	        try {
	            var converted = new Buffer(value, this._flags.encoding);
	            result.value = converted;
	        }
	        catch (e) { }
	    }

	    result.errors = Buffer.isBuffer(result.value) ? null : Errors.create('binary.base', null, state, options);
	    return result;
	};


	internals.Binary.prototype.encoding = function (encoding) {

	    Hoek.assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);

	    var obj = this.clone();
	    obj._flags.encoding = encoding;
	    return obj;
	};


	internals.Binary.prototype.min = function (limit) {

	    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

	    return this._test('min', limit, function (value, state, options) {

	        if (value.length >= limit) {
	            return null;
	        }

	        return Errors.create('binary.min', { limit: limit, value: value }, state, options);
	    });
	};


	internals.Binary.prototype.max = function (limit) {

	    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

	    return this._test('max', limit, function (value, state, options) {

	        if (value.length <= limit) {
	            return null;
	        }

	        return Errors.create('binary.max', { limit: limit, value: value }, state, options);
	    });
	};


	internals.Binary.prototype.length = function (limit) {

	    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

	    return this._test('length', limit, function (value, state, options) {

	        if (value.length === limit) {
	            return null;
	        }

	        return Errors.create('binary.length', { limit: limit, value: value }, state, options);
	    });
	};


	module.exports = new internals.Binary();


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	var ms = __webpack_require__(182);

	module.exports = function (time, iat) {
	  var timestamp = iat || Math.floor(Date.now() / 1000);

	  if (typeof time === 'string') {
	    var milliseconds = ms(time);
	    if (typeof milliseconds === 'undefined') {
	      return;
	    }
	    return Math.floor(timestamp + milliseconds / 1000);
	  } else if (typeof time === 'number') {
	    return timestamp + time;
	  } else {
	    return;
	  }

	};

/***/ },
/* 317 */
/***/ function(module, exports) {

	/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308,
	    NAN = 0 / 0;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Creates a function that invokes `func`, with the `this` binding and arguments
	 * of the created function, while it's called less than `n` times. Subsequent
	 * calls to the created function return the result of the last `func` invocation.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Function
	 * @param {number} n The number of calls at which `func` is no longer invoked.
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new restricted function.
	 * @example
	 *
	 * jQuery(element).on('click', _.before(5, addContactToList));
	 * // => Allows adding up to 4 contacts to the list.
	 */
	function before(n, func) {
	  var result;
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  n = toInteger(n);
	  return function() {
	    if (--n > 0) {
	      result = func.apply(this, arguments);
	    }
	    if (n <= 1) {
	      func = undefined;
	    }
	    return result;
	  };
	}

	/**
	 * Creates a function that is restricted to invoking `func` once. Repeat calls
	 * to the function return the value of the first invocation. The `func` is
	 * invoked with the `this` binding and arguments of the created function.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new restricted function.
	 * @example
	 *
	 * var initialize = _.once(createApplication);
	 * initialize();
	 * initialize();
	 * // => `createApplication` is invoked once
	 */
	function once(func) {
	  return before(2, func);
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	module.exports = once;


/***/ }
/******/ ]);